{"version":3,"file":"index.js","sources":["../src/tools.ts","../src/eventsource.ts","../../node_modules/tslib/tslib.es6.js","../src/mixins.ts","../src/events.ts","../src/logging.ts"],"sourcesContent":[" /** Similar to underscore `_.defaults` */\r\nexport function defaults< T >( dest : T, ...sources : Object[] ) : T\r\nexport function defaults< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) && !dest.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && defaults( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Check if value is raw JSON */\r\nexport function isValidJSON( value : any ) : boolean {\r\n    if( value === null ){\r\n        return true;\r\n    }\r\n\r\n    switch( typeof value ){\r\n    case 'number' :\r\n    case 'string' :\r\n    case 'boolean' :\r\n        return true;\r\n\r\n    case 'object':\r\n        var proto = Object.getPrototypeOf( value );\r\n\r\n        if( proto === Object.prototype || proto === Array.prototype ){\r\n            return every( value, isValidJSON );\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Get the base class constructor function.\r\n * @param Class Subclass constructor function.\r\n * @returns Base class constructor function.\r\n */\r\nexport function getBaseClass( Class : Function ) {\r\n    return Object.getPrototypeOf( Class.prototype ).constructor\r\n}\r\n\r\nexport function assignToClassProto<T, K extends keyof T>( Class, definition : T, ...names : K[] ) : void {\r\n    for( let name of names ){\r\n        const value = definition[ name ];\r\n        value === void 0 || ( Class.prototype[ name ] = value );\r\n    }\r\n}\r\n\r\n/** Checks whenever given object is an empty hash `{}` */\r\nexport function isEmpty( obj : {} ) : boolean {\r\n    if( obj ){\r\n        for( let key in obj ){\r\n            if( obj.hasOwnProperty( key ) ){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport type Iteratee = ( value : any, key? : string | number ) => any;\r\n\r\nfunction someArray( arr : any[], fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let i = 0; i < arr.length; i++ ){\r\n        if( result = fun( arr[ i ], i ) ){\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction someObject( obj : {}, fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let key in obj ){\r\n        if( obj.hasOwnProperty( key ) ){\r\n            if( result = fun( obj[ key ], key ) ){\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.some` */\r\nexport function some( obj, fun : Iteratee ) : any {\r\n    if( Object.getPrototypeOf( obj ) === ArrayProto ){\r\n        return someArray( obj, fun );\r\n    }\r\n    else{\r\n        return someObject( obj, fun );\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.every` */\r\nexport function every( obj : { }, predicate : Iteratee ) : boolean {\r\n    return !some( obj, x => !predicate( x ) );\r\n}\r\n\r\n/** Similar to `getOwnPropertyDescriptor`, but traverse the whole prototype chain. */\r\nexport function getPropertyDescriptor( obj : {}, prop : string ) : PropertyDescriptor {\r\n    let desc : PropertyDescriptor;\r\n\r\n    for( let proto = obj; !desc && proto; proto = Object.getPrototypeOf( proto ) ) {\r\n        desc = Object.getOwnPropertyDescriptor( proto, prop );\r\n    }\r\n\r\n    return desc;\r\n}\r\n\r\n/** Similar to underscore `_.omit` */\r\nexport function omit( source : {}, ...rest : string[] ) : {}\r\nexport function omit( source ) : {} {\r\n    const dest = {}, discard = {};\r\n\r\n    for( let i = 1; i < arguments.length; i ++ ){\r\n        discard[ arguments[ i ] ] = true;\r\n    }\r\n\r\n    for( var name in source ) {\r\n        if( !discard.hasOwnProperty( name ) && source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** map `source` object properties with a given function, and assign the result to the `dest` object.\r\n * When `fun` returns `undefined`, skip this value. \r\n */\r\nexport function transform< A, B >( dest : { [ key : string ] : A }, source : { [ key : string ] : B }, fun : ( value : B, key : string ) => A | void ) : { [ key : string ] : A } {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            var value = fun( source[ name ], name );\r\n            value === void 0 || ( dest[ name ] = < A >value );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastAssign< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        dest[ name ] = source[ name ];\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastDefaults< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        if( dest[ name ] === void 0 ){\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.extend` and `Object.assign` */\r\nexport function assign< T >( dest : T, ...sources : Object[] ) : T\r\nexport function assign< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && assign( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.keys` */\r\nexport function keys( o : any ) : string[]{\r\n    return o ? Object.keys( o ) : [];\r\n}\r\n\r\n/** Similar to underscore `_.once` */\r\nexport function once( func : Function ) : Function {\r\n    var memo, first = true;\r\n    return function() {\r\n        if ( first ) {\r\n            first = false;\r\n            memo = func.apply(this, arguments);\r\n            func = null;\r\n        }\r\n        return memo;\r\n    };\r\n}\r\n\r\nconst ArrayProto = Array.prototype,\r\n      DateProto = Date.prototype,\r\n      ObjectProto = Object.prototype;\r\n\r\n/**\r\n * Determine whenever two values are not equal, deeply traversing \r\n * arrays and plain JS objects (hashes). Dates are compared by enclosed timestamps, all other\r\n * values are compared with strict comparison.\r\n */\r\nexport function notEqual( a : any, b : any) : boolean {\r\n    if( a === b ) return false;\r\n\r\n    if( a && b && typeof a == 'object' && typeof b == 'object' ) {\r\n        const protoA = Object.getPrototypeOf( a );\r\n\r\n        if( protoA !== Object.getPrototypeOf( b ) ) return true;\r\n\r\n        switch( protoA ){\r\n            case DateProto   : return +a !== +b;\r\n            case ArrayProto  : return arraysNotEqual( a, b );\r\n            case ObjectProto :\r\n            case null:\r\n                return objectsNotEqual( a, b );\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction objectsNotEqual( a, b ) {\r\n    const keysA = Object.keys( a );\r\n\r\n    if( keysA.length !== Object.keys( b ).length ) return true;\r\n\r\n    for( let i = 0; i < keysA.length; i++ ) {\r\n        const key = keysA[ i ];\r\n\r\n        if( !b.hasOwnProperty( key ) || notEqual( a[ key ], b[ key ] ) ) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction arraysNotEqual( a, b ) {\r\n    if( a.length !== b.length ) return true;\r\n\r\n    for( let i = 0; i < a.length; i++ ) {\r\n        if( notEqual( a[ i ], b[ i ] ) ) return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Create an object without Object prototype members except hasOwnProperty.\r\n * @param obj - optional parameter to populate the hash map from.\r\n */\r\nconst HashProto = Object.create( null );\r\nHashProto.hasOwnProperty = ObjectProto.hasOwnProperty;\r\n\r\nexport function hashMap( obj? ){\r\n    const hash = Object.create( HashProto );\r\n    return obj ? assign( hash, obj ) : hash;\r\n}\r\n\r\nexport function compare( a : any, b : any ) : -1 | 0 | 1 {\r\n    // Handle strictly equal values.\r\n    if( a == b ) return 0;\r\n\r\n    // Handle nulls.\r\n    if( a == null ) return -1;\r\n    if( b == null ) return 1;\r\n\r\n    // No nulls. Convert values to primitives.\r\n    const av = a.valueOf(),\r\n        bv = b.valueOf();\r\n\r\n    return  av < bv ? -1 :\r\n            av > bv ? 1 :\r\n            0;\r\n}\r\n\r\nexport function groupBy<A,R>( arr : R[], attr : keyof R | (( m : R ) => string )) : { [ key : string ] : R[] };\r\nexport function groupBy<A,R>(\r\n    arr : R[],\r\n    attr : keyof R | (( m : R ) => string ),\r\n    a_reducer : ( acc : A, model? : R, key? : string ) => A\r\n) : { [ key : string ] : A };\r\nexport function groupBy<A,R>(\r\n    arr : R[],\r\n    attr : keyof R | (( m : R ) => string ),\r\n    a_reducer : ( acc : A, model? : R, key? : string ) => void,\r\n    init : ( key? : string ) => A\r\n) : { [ key : string ] : A };\r\nexport function groupBy<A,R>(\r\n    arr : R[],\r\n    attr : keyof R | (( m : R ) => string ),\r\n    a_reducer? : ( acc : A, model? : R, key? : string ) => A,\r\n    init? : ( key? : string ) => A\r\n){\r\n    const map : any = typeof attr === 'string' ?\r\n        x => x[ attr ] :\r\n        attr;\r\n\r\n    return a_reducer ? (\r\n            init ?\r\n                mutableGroupBy( arr, map, a_reducer, init ) :\r\n                immutableGroupBy( arr, map, a_reducer )\r\n        ) :\r\n            mutableGroupBy( arr, map, arrayGroup, arrayGroupInit );\r\n}\r\n\r\nconst arrayGroup = ( acc : any[], x : any) => {\r\n    acc.push( x );\r\n}\r\n\r\nconst arrayGroupInit = () => [];\r\n\r\nfunction immutableGroupBy<A,R>(\r\n    arr : R[],\r\n    map : (( m : R ) => string ),\r\n    reducer : ( acc : A, model? : R, key? : string ) => A\r\n){\r\n    const results = {};\r\n\r\n    for( let model of arr ){\r\n        const key = map( model );\r\n\r\n        if( key != null ){\r\n            results[ key ] = reducer( results[ key ], model, key );\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\nfunction mutableGroupBy<A,R>(\r\n    arr : R[],\r\n    map : (( m : R ) => string ),\r\n    reducer : ( acc : A, model? : R, key? : string ) => void,\r\n    init : ( key? : string ) => A\r\n){\r\n    const results = {};\r\n\r\n    for( let model of arr ){\r\n        const key = map( model );\r\n\r\n        if( key != null ){\r\n            let acc = results[ key ];\r\n\r\n            if( acc === undefined ){\r\n                acc = results[ key ] = init( key );\r\n            }\r\n\r\n            reducer( acc, model, key );\r\n        }\r\n    }\r\n\r\n    return results;\r\n}","import { once as _once } from './tools'\r\n\r\n/*******************\r\n * Prebuilt events map, used for optimized bulk event subscriptions.\r\n *\r\n * const events = new EventMap({\r\n *      'change' : true, // Resend this event from self as it is.\r\n *      'change:attr' : 'localTargetFunction',\r\n *      'executedInTargetContext' : function(){ ... }\r\n *      'executedInNativeContext' : '^props.handler'\r\n * })\r\n */\r\nexport interface EventsDefinition {\r\n    [ events : string ] : Function | string | boolean\r\n}\r\n\r\nexport class EventMap {\r\n    handlers : EventDescriptor[] = [];\r\n\r\n    constructor( map? : EventsDefinition | EventMap ){\r\n        if( map ){\r\n            if( map instanceof EventMap ){\r\n                this.handlers = map.handlers.slice();\r\n            }\r\n            else{\r\n                map && this.addEventsMap( map );\r\n            }\r\n        }\r\n    }\r\n\r\n    merge( map : EventMap ){\r\n        this.handlers = this.handlers.concat( map.handlers );\r\n    }\r\n\r\n    addEventsMap( map : EventsDefinition ){\r\n        for( let names in map ){\r\n            this.addEvent( names, map[ names ] )\r\n        }\r\n    }\r\n\r\n    bubbleEvents( names : string ){\r\n        for( let name of names.split( eventSplitter ) ){\r\n            this.addEvent( name, getBubblingHandler( name ) );\r\n        }\r\n    }\r\n\r\n    addEvent( names : string, callback : Function | string | boolean ){\r\n        const { handlers } = this;\r\n\r\n        for( let name of names.split( eventSplitter ) ){\r\n            handlers.push( new EventDescriptor( name, callback ) );\r\n        }\r\n    }\r\n\r\n    subscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            on( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n\r\n    unsubscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            off( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n}\r\n\r\nexport class EventDescriptor {\r\n    callback : Function\r\n\r\n    constructor(\r\n        public name : string,\r\n        callback : Function | string | boolean\r\n    ){\r\n        if( callback === true ){\r\n            this.callback = getBubblingHandler( name );\r\n        }\r\n        else if( typeof callback === 'string' ){\r\n            this.callback =\r\n                function localCallback(){\r\n                    const handler = this[ callback ];\r\n                    handler && handler.apply( this, arguments );\r\n                };\r\n        }\r\n        else{\r\n            this.callback = <Function>callback;\r\n        }\r\n    }\r\n}\r\n\r\nconst _bubblingHandlers = {};\r\n\r\nfunction getBubblingHandler( event : string ){\r\n    return _bubblingHandlers[ event ] || (\r\n        _bubblingHandlers[ event ] = function( a?, b?, c?, d?, e? ){\r\n            if( d !== void 0 || e !== void 0 ) trigger5( this, event, a, b, c, d, e );\r\n            if( c !== void 0 ) trigger3( this, event, a, b, c );\r\n            else trigger2( this, event, a, b );\r\n        }\r\n    );\r\n}\r\n\r\nexport interface HandlersByEvent {\r\n    [ name : string ] : EventHandler\r\n}\r\n\r\nexport class EventHandler {\r\n    constructor( public callback : Callback, public context : any, public next = null ){}\r\n}\r\n\r\nfunction listOff( _events : HandlersByEvent, name : string, callback : Callback, context : any ){\r\n    const head = _events[ name ];\r\n\r\n    let filteredHead, prev;\r\n\r\n    for( let ev = head; ev; ev = ev.next ){\r\n        // Element must be kept\r\n        if( ( callback && callback !== ev.callback && callback !== ev.callback._callback ) ||\r\n            ( context && context !== ev.context ) ){\r\n            \r\n            prev = ev;\r\n            filteredHead || ( filteredHead = ev );\r\n        }\r\n        // Element must be skipped\r\n        else{\r\n            if( prev ) prev.next = ev.next;\r\n        }\r\n    }\r\n\r\n    if( head !== filteredHead ) _events[ name ] = filteredHead;\r\n}\r\n\r\nfunction listSend2( head : EventHandler, a, b ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b );\r\n}\r\n\r\nfunction listSend3( head : EventHandler, a, b, c ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c );\r\n}\r\n\r\nfunction listSend4( head : EventHandler, a, b, c, d ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d );\r\n}\r\n\r\nfunction listSend5( head : EventHandler, a, b, c, d, e ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e );\r\n}\r\n\r\nfunction listSend6( head : EventHandler, a, b, c, d, e, f ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e, f );\r\n}\r\n\r\nexport interface Callback extends Function {\r\n    _callback? : Function\r\n}\r\n\r\nexport function on( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const _events = source._events || ( source._events = Object.create( null ) );\r\n        _events[ name ] = new EventHandler( callback, context, _events[ name ] );\r\n    }\r\n}\r\n\r\nexport function once( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const once : Callback = _once( function(){\r\n            off( source, name, once );\r\n            callback.apply(this, arguments);\r\n        });\r\n\r\n        once._callback = callback;\r\n        on( source, name, once, context );\r\n    }\r\n}\r\n\r\nexport function off( source : EventSource, name? : string, callback? : Callback, context? : any ) : void {\r\n    const { _events } = source;\r\n    if( _events ){\r\n        if( callback || context ) {\r\n            if( name ){\r\n                listOff( _events, name, callback, context );\r\n            }\r\n            else{\r\n                for( let name in _events ){\r\n                    listOff( _events, name, callback, context );\r\n                }\r\n            }\r\n        }\r\n        else if( name ){\r\n            _events[ name ] = void 0;\r\n        }\r\n        else{\r\n            source._events = void 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport interface EventSource {\r\n    /** @internal */\r\n    _events : HandlersByEvent\r\n}\r\n\r\nconst eventSplitter = /\\s+/;\r\n\r\nexport function strings( api : ApiEntry, source : EventSource, events : string, callback : Callback, context ){\r\n    if( eventSplitter.test( events ) ){\r\n        const names = events.split( eventSplitter );\r\n        for( let name of names ) api( source, name, callback, context );\r\n    }\r\n    else api( source, events, callback, context );\r\n}\r\n\r\nexport type ApiEntry = ( source : EventSource, event : string, callback : Callback, context? : any ) => void\r\n\r\n/*********************************\r\n * Event-triggering API\r\n */\r\n\r\n export function trigger2( self : EventSource, name : string, a, b ) : void {\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend2( queue, a, b );\r\n        listSend3( all, name, a, b );\r\n    }\r\n};\r\n\r\nexport function trigger3( self : EventSource, name : string, a, b, c ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend3( queue, a, b, c );\r\n        listSend4( all, name, a, b, c );\r\n    }\r\n};\r\n\r\nexport function trigger5( self : EventSource, name : string, a, b, c, d, e ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend5( queue, a, b, c, d, e );\r\n        listSend6( all, name, a, b, c, d, e );\r\n    }\r\n};","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/*****************************************************************\r\n * Mixins engine and @define metaprogramming class extensions\r\n *\r\n * Vlad Balin & Volicon, (c) 2016-2017\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { assign, defaults, getBaseClass, hashMap, transform } from './tools';\r\n\r\nexport interface Subclass< T > extends MixableConstructor {\r\n    new ( ...args ) : T\r\n    prototype : T\r\n}\r\n\r\nexport interface MixableConstructor extends Function{\r\n    __super__? : object;\r\n    mixins? : MixinsState;\r\n    onExtend? : ( BaseClass : Function ) => void;\r\n    onDefine? : ( definition : object, BaseClass : Function ) => void;\r\n    define? : ( definition? : object, statics? : object ) => MixableConstructor;\r\n    extend? : <T extends object>( definition? : T, statics? : object ) => Subclass<T>;\r\n}\r\n\r\nexport interface MixableDefinition {\r\n    mixins? : Mixin[]\r\n}\r\n\r\n/**\r\n * Base class, holding metaprogramming class extensions.\r\n * Supports mixins and Class.define metaprogramming method.\r\n */\r\nexport class Mixable {\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static onDefine : ( definition : object, BaseClass : Function ) => object;    \r\n    static __super__ : object\r\n    static mixins : MixinsState;\r\n\r\n    /** \r\n     *  Must be called after inheritance and before 'define'.\r\n     */\r\n    static define( protoProps : MixableDefinition = {}, staticProps? : object ) : MixableConstructor {\r\n        const BaseClass : MixableConstructor = getBaseClass( this );\r\n\r\n        // Assign statics.\r\n        staticProps && assign( this, staticProps );\r\n\r\n        // Extract and apply mixins from the definition.\r\n        const { mixins, ...defineMixin } = protoProps;\r\n        mixins && this.mixins.merge( mixins );\r\n\r\n        // Unshift definition to the the prototype.\r\n        this.mixins.mergeObject( this.prototype, defineMixin, true );\r\n\r\n        // Unshift definition from statics to the prototype.\r\n        this.mixins.mergeObject( this.prototype, this.mixins.getStaticDefinitions( BaseClass ), true );\r\n\r\n        // Call onDefine hook, if it's present.\r\n        this.onDefine && this.onDefine( this.mixins.definitions, BaseClass );\r\n        \r\n        // Apply merge rules to inherited members. No mixins can be added after this point.\r\n        this.mixins.mergeInheritedMembers( BaseClass );\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Backbone-compatible extend method to be used in ES5 and for backward compatibility */\r\n    static extend< T extends object>(spec? : T, statics? : {} ) : Subclass< T > {\r\n        let TheSubclass : Subclass< T >;\r\n\r\n        // 1. Create the subclass (ES5 compatibility shim).\r\n        // If constructor function is given...\r\n        if( spec && spec.hasOwnProperty( 'constructor' ) ){\r\n            // ...we need to manually call internal TypeScript __extend function. Hack! Hack!\r\n            TheSubclass = spec.constructor as any;\r\n            __extends( TheSubclass, this );\r\n        }\r\n        // Otherwise, create the subclall in usual way.\r\n        else{\r\n            TheSubclass = class Subclass extends this {} as any;\r\n        }\r\n\r\n        predefine( TheSubclass );\r\n        spec && TheSubclass.define( spec, statics );\r\n\r\n        return TheSubclass;\r\n    }\r\n}\r\n\r\n/** @decorator `@predefine` for forward definitions. Can be used with [[Mixable]] classes only.\r\n * Forwards the call to the [[Mixable.predefine]];\r\n */\r\nexport function predefine( Constructor : MixableConstructor ) : void {\r\n    const BaseClass : MixableConstructor = getBaseClass( Constructor );\r\n\r\n    // Legacy systems support\r\n    Constructor.__super__ = BaseClass.prototype;\r\n    \r\n    // Initialize mixins structures...\r\n    Constructor.define || MixinsState.get( Mixable ).populate( Constructor );\r\n\r\n    // Make sure Ctor.mixins are ready before the callback...\r\n    MixinsState.get( Constructor );\r\n\r\n    // Call extend hook.\r\n    Constructor.onExtend && Constructor.onExtend( BaseClass );\r\n}\r\n\r\n/** @decorator `@define` for metaprogramming magic. Can be used with [[Mixable]] classes only.\r\n *  Forwards the call to [[Mixable.define]].\r\n */\r\nexport function define( ClassOrDefinition : Function ) : void;\r\nexport function define( ClassOrDefinition : object ) : ClassDecorator;\r\nexport function define( ClassOrDefinition : object | MixableConstructor ){\r\n    // @define class\r\n    if( typeof ClassOrDefinition === 'function' ){\r\n        predefine( ClassOrDefinition );\r\n        ( ClassOrDefinition as MixableConstructor ).define();\r\n    }\r\n    // @define({ prop : val, ... }) class\r\n    else{\r\n        return function( Ctor : MixableConstructor ){\r\n            predefine( Ctor );\r\n            Ctor.define( ClassOrDefinition );\r\n        } as any;\r\n    }\r\n}\r\n\r\nexport function definitions( rules : MixinMergeRules ) : ClassDecorator {\r\n    return ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.definitionRules = defaults( hashMap(), rules, mixins.definitionRules );\r\n    }\r\n}\r\n\r\n// Create simple property list decorator\r\nexport function propertyListDecorator( listName: string ) : PropertyDecorator {\r\n    return function propList(proto, name : string) {\r\n        const list = proto.hasOwnProperty( listName ) ?\r\n            proto[ listName ] : (proto[ listName ] = (proto[ listName ] || []).slice());  \r\n\r\n        list.push(name);\r\n    }\r\n}\r\n\r\nexport function definitionDecorator( definitionKey, value ){\r\n    return ( proto : object, name : string ) => {\r\n        MixinsState\r\n            .get( proto.constructor )\r\n            .mergeObject( proto, {\r\n                [ definitionKey ] : {\r\n                    [ name ] : value\r\n                }\r\n            });\r\n    }\r\n}\r\n\r\nexport class MixinsState {\r\n    mergeRules : MixinMergeRules;\r\n    definitionRules : MixinMergeRules;\r\n    definitions : object = {};\r\n    appliedMixins : Mixin[];\r\n\r\n    // Return mixins state for the class. Initialize if it's not exist.\r\n    static get( Class ) : MixinsState {\r\n        const { mixins } = Class;\r\n    \r\n        return mixins && Class === mixins.Class ? mixins :\r\n             Class.mixins = new MixinsState( Class );\r\n    }\r\n\r\n    constructor( public Class : MixableConstructor ){\r\n        const { mixins } = getBaseClass( Class );\r\n\r\n        this.mergeRules = ( mixins && mixins.mergeRules ) || hashMap();\r\n        this.definitionRules = ( mixins && mixins.definitionRules ) || hashMap();\r\n        this.appliedMixins = ( mixins && mixins.appliedMixins ) || [];\r\n    }\r\n\r\n    getStaticDefinitions( BaseClass : Function ){\r\n        const definitions = hashMap(),\r\n            { Class } = this;\r\n\r\n        return transform( definitions, this.definitionRules, ( rule, name ) =>{\r\n            if( BaseClass[ name ] !== Class[ name ]){\r\n                return Class[ name ];\r\n            }\r\n        });\r\n    }\r\n\r\n    merge( mixins : Mixin[] ){\r\n        const proto      = this.Class.prototype,\r\n            { mergeRules } = this;\r\n\r\n        // Copy applied mixins array as it's going to be updated.\r\n        const appliedMixins = this.appliedMixins = this.appliedMixins.slice();\r\n\r\n        // Apply mixins in sequence...\r\n        for( let mixin of mixins ) {\r\n            // Mixins array should be flattened.\r\n            if( Array.isArray( mixin ) ) {\r\n                this.merge( mixin );\r\n            }\r\n            // Don't apply mixins twice.\r\n            else if( appliedMixins.indexOf( mixin ) < 0 ){\r\n                appliedMixins.push( mixin );\r\n\r\n                // For constructors, merge _both_ static and prototype members.\r\n                if( typeof mixin === 'function' ){\r\n                    // Merge static members\r\n                    this.mergeObject( this.Class, mixin );\r\n\r\n                    // merge definitionRules and mergeRules\r\n                    const sourceMixins = ( mixin as any ).mixins;\r\n                    if( sourceMixins ){\r\n                        this.mergeRules = defaults( hashMap(), this.mergeRules, sourceMixins.mergeRules );\r\n                        this.definitionRules = defaults( hashMap(), this.definitionRules, sourceMixins.definitionRules );\r\n                        this.appliedMixins = this.appliedMixins.concat( sourceMixins.appliedMixins );\r\n                    }\r\n\r\n                    // Prototypes are merged according with rules.\r\n                    this.mergeObject( proto, mixin.prototype );\r\n                }\r\n                // Handle plain object mixins.\r\n                else {\r\n                    this.mergeObject( proto, mixin );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    populate( ...ctors : Function[] ){\r\n        for( let Ctor of ctors ) {\r\n            MixinsState.get( Ctor ).merge([ this.Class ]);\r\n        }\r\n    }\r\n\r\n    mergeObject( dest : object, source : object, unshift? : boolean ) {\r\n        forEachOwnProp( source, name => {\r\n            const sourceProp = Object.getOwnPropertyDescriptor( source, name );\r\n            let rule : MixinMergeRule;\r\n\r\n            if( rule = this.definitionRules[ name ] ){\r\n                assignProperty( this.definitions, name, sourceProp, rule, unshift );\r\n            }\r\n\r\n            if( !rule || rule === mixinRules.protoValue  ){\r\n                assignProperty( dest, name, sourceProp, this.mergeRules[ name ], unshift );\r\n            }\r\n        });\r\n    }\r\n\r\n    mergeInheritedMembers( BaseClass : Function ){\r\n        const { mergeRules, Class } = this;\r\n\r\n        if( mergeRules ){\r\n            const proto = Class.prototype,\r\n                baseProto = BaseClass.prototype;\r\n\r\n            for( let name in mergeRules ) {\r\n                const rule = mergeRules[ name ];\r\n\r\n                if( proto.hasOwnProperty( name ) && name in baseProto ){\r\n                    proto[ name ] = resolveRule( proto[ name ], baseProto[ name ], rule );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst dontMix = {\r\n    function : hashMap({\r\n        length : true,\r\n        prototype : true,\r\n        caller : true,\r\n        arguments : true,\r\n        name : true,\r\n        __super__ : true\r\n    }),\r\n    \r\n    object : hashMap({\r\n        constructor : true\r\n    })    \r\n}\r\n\r\nfunction forEachOwnProp( object : object, fun : ( name : string ) => void ){\r\n    const ignore = dontMix[ typeof object ];\r\n\r\n    for( let name of Object.getOwnPropertyNames( object ) ) {\r\n        ignore[ name ] || fun( name );\r\n    }\r\n}\r\n\r\nexport interface MixinMergeRules {\r\n    [ name : string ] : MixinMergeRule\r\n}\r\n\r\nexport type MixinMergeRule = ( a : any, b : any ) => any\r\nexport type Mixin = { [ key : string ] : any } | Function\r\n\r\n// @mixins( A, B, ... ) decorator.\r\nexport interface MixinRulesDecorator {\r\n    ( rules : MixinMergeRules ) : ClassDecorator\r\n    value( a : object, b : object) : object;\r\n    protoValue( a : object, b : object) : object;\r\n    merge( a : object, b : object ) : object;\r\n    pipe( a: Function, b : Function ) : Function;\r\n    defaults( a: Function, b : Function ) : Function;\r\n    classFirst( a: Function, b : Function ) : Function;\r\n    classLast( a: Function, b : Function ) : Function;\r\n    every( a: Function, b : Function ) : Function;\r\n    some( a: Function, b : Function ) : Function;\r\n}\r\n\r\nexport const mixins = ( ...list : Mixin[] ) => (\r\n    ( Class : Function ) => MixinsState.get( Class ).merge( list )\r\n);\r\n\r\n// @mixinRules({ name : rule, ... }) decorator.\r\nexport const mixinRules = ( ( rules : MixinMergeRules ) => (\r\n    ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.mergeRules = defaults( rules, mixins.mergeRules );\r\n    }\r\n) ) as MixinRulesDecorator;\r\n\r\n// Pre-defined mixin merge rules\r\n\r\nmixinRules.value = ( a, b ) => a;\r\n\r\nmixinRules.protoValue = ( a, b ) => a;\r\n\r\n// Recursively merge members\r\nmixinRules.merge = ( a, b ) => defaults( {}, a, b );\r\n\r\n    // Execute methods in pipe, with the class method executed last.\r\nmixinRules.pipe = ( a, b ) => (\r\n    function( x : any ) : any {\r\n        return a.call( this, b.call( this, x ) );\r\n    }\r\n);\r\n\r\n    // Assume methods return an object, and merge results with defaults (class method executed first)\r\nmixinRules.defaults = ( a : Function, b : Function ) => (\r\n    function() : object {\r\n        return defaults( a.apply( this, arguments ), b.apply( this, arguments ) );\r\n    }\r\n);\r\n\r\n// Execute methods in sequence staring with the class method.\r\nmixinRules.classFirst = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        a.apply( this, arguments );\r\n        b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n    // Execute methods in sequence ending with the class method.\r\nmixinRules.classLast = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        b.apply( this, arguments );\r\n        a.apply( this, arguments );\r\n    }\r\n)\r\n\r\n    // Execute methods in sequence returning the first falsy result.\r\nmixinRules.every = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) && b.apply( this, arguments );\r\n    }\r\n);\r\n    // Execute methods in sequence returning the first truthy result.\r\nmixinRules.some = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) || b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nfunction assignProperty( dest : object, name : string, sourceProp : PropertyDescriptor, rule : MixinMergeRule, unshift? : boolean ){\r\n// Destination prop is defined, thus the merge rules must be applied.\r\n    if( dest.hasOwnProperty( name ) ){\r\n        const destProp = Object.getOwnPropertyDescriptor( dest, name );\r\n\r\n        if( destProp.configurable && 'value' in destProp ){\r\n            dest[ name ] = unshift ?\r\n                resolveRule( sourceProp.value, destProp.value, rule ) :\r\n                resolveRule( destProp.value, sourceProp.value, rule ) ;\r\n        }\r\n    }\r\n    // If destination is empty, just copy the prop over.\r\n    else{\r\n        Object.defineProperty( dest, name, sourceProp );\r\n    }\r\n}\r\n\r\nfunction resolveRule( dest, source, rule : MixinMergeRule ){\r\n    // When destination is empty, take the source.\r\n    if( dest === void 0 ) return source;\r\n\r\n    // In these cases we take non-empty destination:\r\n    if( !rule || source === void 0 ) return dest;\r\n\r\n    // In other cases we must merge values.\r\n    return rule( dest, source );\r\n}","import * as _eventsApi from './eventsource';\r\nimport { EventMap, EventsDefinition, EventSource, HandlersByEvent } from './eventsource';\r\nimport { define, definitions, Mixable, MixableConstructor, mixinRules, MixinsState } from './mixins';\r\nimport { omit, transform } from './tools';\r\n\r\nconst { strings, on, off, once, trigger5, trigger2, trigger3 } = _eventsApi;\r\n\r\nlet _idCount = 0;\r\n\r\nfunction uniqueId() : string {\r\n    return 'l' + _idCount++;\r\n}\r\n\r\nexport { EventMap, EventsDefinition };\r\n\r\nexport interface MessengerDefinition {\r\n    _localEvents? : EventMap\r\n    localEvents? : EventsDefinition\r\n    properties? : PropertyMap\r\n    [ name : string ] : any\r\n}\r\n\r\nexport interface PropertyMap {\r\n    [ name : string ] : Property\r\n}\r\n\r\nexport type Property = PropertyDescriptor | ( () => any )\r\n\r\nexport interface MessengersByCid {\r\n    [ cid : string ] : Messenger\r\n}\r\n\r\nexport type EventCallbacks<Context> = { [ events : string ] : EventCallback<Context> }\r\nexport type EventCallback<Context> = ( this : Context, ...args : any[] ) => void\r\n\r\n/*************************\r\n * Messenger is mixable class with capabilities of sending and receiving synchronous events.\r\n * This class itself can serve as both mixin and base class.\r\n */\r\n\r\n@define\r\n@definitions({\r\n    properties : mixinRules.merge,\r\n    localEvents : mixinRules.merge\r\n})\r\nexport class Messenger implements Mixable, EventSource {\r\n    // Define extendable mixin static properties.\r\n    /** @internal */\r\n    static __super__ : object;\r\n    static mixins : MixinsState;\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static define : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static extend : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static onDefine({ localEvents, _localEvents, properties } : MessengerDefinition, BaseClass? : typeof Mixable ){\r\n        // Handle localEvents definition\r\n        if( localEvents || _localEvents ){\r\n            const eventsMap = new EventMap( this.prototype._localEvents );\r\n\r\n            localEvents && eventsMap.addEventsMap( localEvents );\r\n            _localEvents && eventsMap.merge( _localEvents );\r\n            \r\n            this.prototype._localEvents = eventsMap;\r\n        }\r\n\r\n        // Handle properties definitions...\r\n        if( properties ){\r\n            Object.defineProperties( this.prototype, transform( {}, <PropertyMap>properties, toPropertyDescriptor ) );\r\n        }\r\n    }\r\n\r\n    /** @internal */ \r\n    _events : HandlersByEvent = void 0;\r\n\r\n    /** @internal */ \r\n    _listeningTo : MessengersByCid = void 0\r\n\r\n    /** Unique client-only id. */\r\n    cid : string\r\n\r\n    /** Prototype-only property to manage automatic local events subscription */ \r\n    protected _localEvents : EventMap\r\n\r\n    constructor(){\r\n        this.cid = uniqueId();\r\n        this.initialize.apply( this, arguments );\r\n\r\n        // TODO: local events subscribe?\r\n    }\r\n\r\n    /** Method is called at the end of the constructor */\r\n    initialize() : void {}\r\n    \r\n    on( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( on, this, events, callback, context );\r\n        else for( let name in events ) strings( on, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    once( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( once, this, events, callback, context );\r\n        else for( let name in events ) strings( once, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    off( events? : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( !events ) off( this, void 0, callback, context );\r\n        else if( typeof events === 'string' ) strings( off, this, events, callback, context );\r\n        else for( let name in events ) strings( off, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\r\n    // passed the same arguments as `trigger` is, apart from the event name\r\n    // (unless you're listening on `\"all\"`, which will cause your callback to\r\n    // receive the true name of the event as the first argument).\r\n    trigger(name : string, a?, b?, c?, d?, e? ) : this {\r\n        if( d !== void 0 || e !== void 0 ) trigger5( this, name, a, b, c, d, e );\r\n        else if( c !== void 0 ) trigger3( this, name, a, b, c );\r\n        else trigger2( this, name, a, b );\r\n        return this;\r\n    }\r\n\r\n    listenTo( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.on( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    listenToOnce( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.once( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    stopListening( a_source? : Messenger, a? : string | EventCallbacks<this>, b? : Function ) : this {\r\n        const { _listeningTo } = this;\r\n        if( _listeningTo ){\r\n            const removeAll = !( a || b ),\r\n                  second = !b && typeof a === 'object' ? this : b;\r\n\r\n            if( a_source ){\r\n                const source = _listeningTo[ a_source.cid ];\r\n                if( source ){\r\n                    if( removeAll ) delete _listeningTo[ a_source.cid ];\r\n                    source.off( a, second, this );\r\n                }\r\n            }\r\n            else if( a_source == null ){\r\n                for( let cid in _listeningTo ) _listeningTo[ cid ].off( a, second, this );\r\n\r\n                if( removeAll ) ( this._listeningTo = void 0 );\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destructor. Stops messenger from listening to all objects,\r\n     * and stop others from listening to the messenger. \r\n     */\r\n    _disposed : boolean\r\n\r\n    dispose() : void {\r\n        if( this._disposed ) return;\r\n\r\n        this.stopListening();\r\n        this.off();\r\n\r\n        this._disposed = true;\r\n    }\r\n}\r\n\r\n/**\r\n * Backbone 1.2 API conformant Events mixin.\r\n */\r\nexport const Events : Messenger = <Messenger> omit( Messenger.prototype, 'constructor', 'initialize' );\r\n\r\n/**\r\n * Messenger Private Helpers \r\n */\r\n\r\nfunction toPropertyDescriptor( x : Property ) : PropertyDescriptor {\r\n    if( x ){\r\n        return typeof x === 'function' ? { get : < () => any >x, configurable : true } : <PropertyDescriptor> x;\r\n    }\r\n}\r\n\r\nfunction addReference( listener : Messenger, source : Messenger ){\r\n      const listeningTo = listener._listeningTo || (listener._listeningTo = Object.create( null ) ),\r\n            cid = source.cid || ( source.cid = uniqueId() );\r\n\r\n      listeningTo[ cid ] = source;\r\n}","import { Messenger } from './events'\r\nimport { define } from './mixins';\r\n\r\nexport type LogLevel = 'error' | 'warn' | 'debug' | 'info' | 'log';\r\nexport type LoggerEventHandler = ( topic : string, msg : string, props : object )  => void;\r\n\r\nexport const isProduction = typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production',\r\n    logEvents : LogLevel[] =  isProduction ?\r\n        [ 'error', 'info' ] :\r\n        [ 'error', 'warn', 'debug', 'info', 'log' ];\r\n\r\n@define\r\nexport class Logger extends Messenger {\r\n    counter : { [ level in LogLevel ]? : number } = {}\r\n\r\n    // Log events of the given log level to the console, optionally filtered by topic\r\n    logToConsole( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                const args = [ `[${topic}] ${msg}` ];\r\n        \r\n                for( let name in props ){\r\n                    args.push( `\\n\\t${name}:`, toString( props[ name ] ) );\r\n                }\r\n        \r\n                console[ level ].apply( console, args );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Fire exception on the events of the given log level, optionally filtered by topic\r\n    throwOn( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                throw new Error( `[${topic}] ${msg}` );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Count log events of the given level, optionally filtered by topic\r\n    count( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                this.counter[ level ] = ( this.counter[ level ] || 0 ) + 1;\r\n            }\r\n        });\r\n    }\r\n\r\n    trigger : ( level : LogLevel, topic : string, message : string, props? : object ) => this;\r\n    \r\n    off : ( event? : LogLevel ) => this;\r\n\r\n\r\n    on( handlers : { [ name in LogLevel ] : LoggerEventHandler } ) : this;\r\n    on( handlers : LogLevel, handler : LoggerEventHandler ) : this;\r\n    on( handlers : 'all', handler : ( level : LogLevel, topic : string, msg : string, props : object )  => void ) : this;\r\n    on( a : any, b? : any ){\r\n        return super.on( a, b );\r\n    }\r\n}\r\n\r\n/**\r\n * Convert objects to the plain text friendly format.\r\n * primitives as in JSON.\r\n */\r\nlet toString = typeof window === 'undefined' ? \r\n    something => {\r\n        if( something && typeof something === 'object' ){\r\n            // Support custom object wrappers...\r\n            const value = something.__inner_state__ || something,\r\n                isArray = Array.isArray( value );\r\n\r\n            const body = isArray ? `[ length = ${ value.length } ]` : `{ ${ Object.keys( value ).join( ', ' )} }`;\r\n\r\n            return something.constructor.name + ' ' + body;\r\n        }\r\n\r\n        return JSON.stringify( something );\r\n    }\r\n    : x => x;\r\n\r\nexport const logger = new Logger();\r\n\r\nif( typeof console !== 'undefined' ) {\r\n    for( let event of logEvents ){\r\n        logger.logToConsole( event );\r\n    }\r\n}\r\n\r\nexport const throwingLogger = new Logger();\r\nthrowingLogger.throwOn( 'error' ).throwOn( 'warn' );\r\n\r\nexport const log : typeof logger.trigger = logger.trigger.bind( logger );"],"names":["defaults","dest","source","name","hasOwnProperty","arguments","length","i","other","getBaseClass","Class","Object","getPrototypeOf","prototype","constructor","some","obj","fun","ArrayProto","arr","result","someArray","key","someObject","every","predicate","x","omit","discard","transform","value","assign","once","func","memo","first","apply","this","Array","DateProto","Date","ObjectProto","notEqual","a","b","protoA","arraysNotEqual","keysA","keys","objectsNotEqual","HashProto","create","hashMap","hash","arrayGroup","acc","push","arrayGroupInit","mutableGroupBy","map","reducer","init","results","arr_2","_i","model","undefined","isValidJSON","proto","definition","names","names_1","_a","name_1","prop","desc","getOwnPropertyDescriptor","o","av","valueOf","bv","attr","a_reducer","arr_1","immutableGroupBy","EventMap","handlers","concat","addEvent","split","eventSplitter","getBubblingHandler","callback","name_2","EventDescriptor","target","event_1","on","event_2","off","slice","addEventsMap","handler","_bubblingHandlers","event","c","d","e","trigger5","trigger3","trigger2","context","next","listOff","_events","filteredHead","prev","head","ev","_callback","listSend3","call","EventHandler","once_1","_once","name_3","strings","api","events","test","self","queue","all","listSend2","listSend4","listSend5","f","listSend6","extendStatics","setPrototypeOf","__proto__","p","__extends","__","__decorate","decorators","r","Reflect","decorate","defineProperty","Mixable","protoProps","staticProps","BaseClass","mixins","defineMixin","s","t","indexOf","getOwnPropertySymbols","propertyIsEnumerable","merge","mergeObject","getStaticDefinitions","onDefine","definitions","mergeInheritedMembers","spec","statics","TheSubclass","__extends_1","predefine","define","Constructor","__super__","MixinsState","get","populate","onExtend","ClassOrDefinition","Ctor","rules","definitionRules","rule","appliedMixins","mixins_1","mixin","isArray","sourceMixins","mergeRules","ctors","ctors_1","unshift","object","ignore","dontMix","getOwnPropertyNames","forEachOwnProp","sourceProp","_this","assignProperty","mixinRules","protoValue","baseProto","resolveRule","function","caller","destProp","configurable","pipe","classFirst","classLast","_idCount","uniqueId","Messenger","localEvents","_localEvents","properties","eventsMap","defineProperties","toPropertyDescriptor","addReference","a_source","_listeningTo","removeAll","second","cid","_disposed","stopListening","initialize","Events","listener","isProduction","process","env","NODE_ENV","logEvents","Logger","level","filter","topic","msg","props","args","toString","console","Error","counter","_super","window","something","__inner_state__","body","join","JSON","stringify","logger","logEvents_1","logToConsole","throwingLogger","throwOn","log","trigger","bind","definitionKey","list","listName"],"mappings":"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"}