## Model class API

### new Model( attrs?, options?)

Create the model. If no `attrs` is supplied, initialize it with defaults taken from the attributes definition.

When no default value is explicitly provided for an attribute, it's initialized as `new AttributeType()` (just `AttributeType()` for primitives). When the default value is provided and it's not compatible with the attribute type, the value is converted to the proper type with `new Type( defaultValue )` call.

If `{parse: true}` option is set the `attrs` is assumed to be the JSON. In this case, `model.parse( attr )` and attribute's `parse` hooks will be called to give you an option to transform the JSON.

```javascript
@define class Book extends Model {
    static attributes = {
        title  : '',
        author : ''
    }
}

const book = new Book({
  title: "One Thousand and One Nights",
  author: "Scheherazade"
});
```

### ModelClass.from(attrs, options?)

Create `RecordClass` from attributes. Similar to direct model creation, but supports additional option for strict data validation.
If `{ strict : true }` option is passed the model validation will be performed immediately and an exception will be thrown in case of an error.

Type-R always perform type checks on assignments, convert types, and reject improper updates reporting it as error. It won't, however, execute custom validation
rules on every updates as validation is evaluated lazily. `strict` option will invoke custom validators and will throw on every error or warning instead of reporting them and continue.

```javascript
// Fetch model with a given id.
const book = await Book.from({ id : 5 }).fetch();

// Validate the body of an incoming HTTP request.
// Throw an exception if validation fails.
const body = MyRequestBody.from( ctx.request.body, { parse : true, strict : true });
```

### model.assignFrom(otherRecord)

Makes an existing `model` to be the full clone of `otherRecord`, recursively assigning all attributes.
In contracts to `model.clone()`, the model is updated in place.

```javascript
// Another way of doing the bestSeller.clone()
const book = new Book();
book.assignFrom(bestSeller);
```

### model.clone()

Create the deep copy of the aggregation tree, recursively cloning all aggregated models and collections. References to shared members will be copied, but not shared members themselves.

### `callback` model.initialize(attrs?, options?)

Called at the end of the `Model` constructor when all attributes are assigned and the model's inner state is properly initialized. Takes the same arguments as
a constructor.

### model.dispose()

Recursively dispose the model and its aggregated members. "Dispose" means that elements of the aggregation tree will unsubscribe from all event sources. It's crucial to prevent memory leaks in SPA.

The whole aggregation tree will be recursively disposed, shared members won't.

### model.cid

Read-only client-side model's identifier. Generated upon creation of the model and is unique for every model's instance. Cloned models will have different `cid`.

### model.id

Predefined model's attribute, the `id` is an arbitrary string (integer id or UUID). `id` is typically generated by the server. It is used in JSON for id-references.

Records can be retrieved by `id` from collections, and there can be just one instance of the model with the same `id` in the particular collection.

### model.isNew()

Has this model been saved to the server yet? If the model does not yet have an `id`, it is considered to be new.

### model.attrName

Model's attributes can be directly accessed with their names as a regular class properties.

If the value is not compatible with attribute's type from the declaration on assignment, it is converted with `Type( value )` call for primitive types, and with `new Type( value )` for other types.

There is an important exception in type convertion logic for models and collections. Instead of applying a contructor, Type-R will try to update existing model and collection instances in place calling their `set()` method instead. This logic keeps the model and collection references stable and safe to pass around.

Model triggers events on changes:
- `change:attrName` *( model, value )*.
- `change` *( model )*.

<aside class="warning">Please note, that you *have to declare all attributes* in `static attributes` declaration.</aside>

```javascript
@define class Book extends Model {
    static attributes = {
        title : String,
        author : String
        price : Number,
        publishedAt : Date,
        available : Boolean
    }
}

const myBook = new Book({ title : "State management with Type-R" });
myBook.author = 'Vlad'; // That works.
myBook.price = 'Too much'; // Converted with Number( 'Too much' ), resulting in NaN.
myBook.price = '123'; // = Number( '123' ).
myBook.publishedAt = new Date(); // Type is compatible, no conversion.
myBook.publishedAt = '1678-10-15 12:00'; // new Date( '1678-10-15 12:00' )
myBook.available = some && weird || condition; // Will always be Boolean. Or null.
```

### model.set({ attrName : value, ... }, options? : `options`)

Bulk assign model's attributes using the same logic as attribute's assignment.

Model will trigger `change:attrName` *( model, value )* event per changed attribute and a single `change` *( model )* event at the end.

### model.transaction(fun)

Execute the all changes made to the model in `fun` as single transaction triggering the single `change` event at the end.

All model updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single `change` event.
Transaction can be opened either manually or implicitly with calling `set()` or assigning an attribute.
Any additional changes made to the model in `change:attr` event handler will be executed in the scope of the original transaction, and won't trigger additional `change` events.

```javascript
some.model.transaction( model => {
    model.a = 1; // `change:a` event is triggered.
    model.b = 2; // `change:b` event is triggered.
}); // `change` event is triggered.
```

Manual transactions with attribute assignments are superior to `model.set()` in terms of both performance and flexibility.

### model.getOwner()

Return the model which is an owner of the current model, or `null` there are no one.

Due to the nature of _aggregation_, an object may have one and only one owner.

### model.collection

Return the collection which aggregates the model, or `null` if there are no one.
