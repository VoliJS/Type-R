{"version":3,"file":"index.js","sources":["../../mixture/src/tools.ts","../../mixture/src/eventsource.ts","../../node_modules/tslib/tslib.es6.js","../../mixture/src/mixins.ts","../../mixture/src/events.ts","../../mixture/src/logging.ts","../src/io-tools.ts","../src/traversable.ts","../src/validation.ts","../../node_modules/@linked/value/src/helpers.ts","../../node_modules/@linked/value/src/index.ts","../src/transactions.ts","../src/model/updates.ts","../src/model/metatypes/any.ts","../src/model/metatypes/basic.ts","../src/model/metatypes/date.ts","../src/model/metatypes/owned.ts","../src/model/metatypes/shared.ts","../src/model/metatypes/index.ts","../src/model/attrDef.ts","../src/model/define.ts","../src/model/linked-attrs.ts","../src/model/mixin.ts","../src/model/io-mixin.ts","../src/model/model.ts","../src/model/index.ts","../src/collection/commons.ts","../src/collection/add.ts","../src/collection/arrayMethods.ts","../src/collection/remove.ts","../src/collection/set.ts","../src/collection/index.ts","../src/relations/commons.ts","../src/relations/from.ts","../src/relations/subsetOf.ts","../src/relations/store.ts","../src/index.ts"],"sourcesContent":[" /** Similar to underscore `_.defaults` */\r\nexport function defaults< T >( dest : T, ...sources : Object[] ) : T\r\nexport function defaults< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) && !dest.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && defaults( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Check if value is raw JSON */\r\nexport function isValidJSON( value : any ) : boolean {\r\n    if( value === null ){\r\n        return true;\r\n    }\r\n\r\n    switch( typeof value ){\r\n    case 'number' :\r\n    case 'string' :\r\n    case 'boolean' :\r\n        return true;\r\n\r\n    case 'object':\r\n        var proto = Object.getPrototypeOf( value );\r\n\r\n        if( proto === Object.prototype || proto === Array.prototype ){\r\n            return every( value, isValidJSON );\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Get the base class constructor function.\r\n * @param Class Subclass constructor function.\r\n * @returns Base class constructor function.\r\n */\r\nexport function getBaseClass( Class : Function ) {\r\n    return Object.getPrototypeOf( Class.prototype ).constructor\r\n}\r\n\r\nexport function assignToClassProto<T, K extends keyof T>( Class, definition : T, ...names : K[] ) : void {\r\n    for( let name of names ){\r\n        const value = definition[ name ];\r\n        value === void 0 || ( Class.prototype[ name ] = value );\r\n    }\r\n}\r\n\r\n/** Checks whenever given object is an empty hash `{}` */\r\nexport function isEmpty( obj : {} ) : boolean {\r\n    if( obj ){\r\n        for( let key in obj ){\r\n            if( obj.hasOwnProperty( key ) ){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport type Iteratee = ( value : any, key? : string | number ) => any;\r\n\r\nfunction someArray( arr : any[], fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let i = 0; i < arr.length; i++ ){\r\n        if( result = fun( arr[ i ], i ) ){\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction someObject( obj : {}, fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let key in obj ){\r\n        if( obj.hasOwnProperty( key ) ){\r\n            if( result = fun( obj[ key ], key ) ){\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.some` */\r\nexport function some( obj, fun : Iteratee ) : any {\r\n    if( Object.getPrototypeOf( obj ) === ArrayProto ){\r\n        return someArray( obj, fun );\r\n    }\r\n    else{\r\n        return someObject( obj, fun );\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.every` */\r\nexport function every( obj : { }, predicate : Iteratee ) : boolean {\r\n    return !some( obj, x => !predicate( x ) );\r\n}\r\n\r\n/** Similar to `getOwnPropertyDescriptor`, but traverse the whole prototype chain. */\r\nexport function getPropertyDescriptor( obj : {}, prop : string ) : PropertyDescriptor {\r\n    let desc : PropertyDescriptor;\r\n\r\n    for( let proto = obj; !desc && proto; proto = Object.getPrototypeOf( proto ) ) {\r\n        desc = Object.getOwnPropertyDescriptor( proto, prop );\r\n    }\r\n\r\n    return desc;\r\n}\r\n\r\n/** Similar to underscore `_.omit` */\r\nexport function omit( source : {}, ...rest : string[] ) : {}\r\nexport function omit( source ) : {} {\r\n    const dest = {}, discard = {};\r\n\r\n    for( let i = 1; i < arguments.length; i ++ ){\r\n        discard[ arguments[ i ] ] = true;\r\n    }\r\n\r\n    for( var name in source ) {\r\n        if( !discard.hasOwnProperty( name ) && source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** map `source` object properties with a given function, and assign the result to the `dest` object.\r\n * When `fun` returns `undefined`, skip this value. \r\n */\r\nexport function transform< A, B >( dest : { [ key : string ] : A }, source : { [ key : string ] : B }, fun : ( value : B, key : string ) => A | void ) : { [ key : string ] : A } {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            var value = fun( source[ name ], name );\r\n            value === void 0 || ( dest[ name ] = < A >value );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastAssign< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        dest[ name ] = source[ name ];\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastDefaults< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        if( dest[ name ] === void 0 ){\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.extend` and `Object.assign` */\r\nexport function assign< T >( dest : T, ...sources : Object[] ) : T\r\nexport function assign< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && assign( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.keys` */\r\nexport function keys( o : any ) : string[]{\r\n    return o ? Object.keys( o ) : [];\r\n}\r\n\r\n/** Similar to underscore `_.once` */\r\nexport function once( func : Function ) : Function {\r\n    var memo, first = true;\r\n    return function() {\r\n        if ( first ) {\r\n            first = false;\r\n            memo = func.apply(this, arguments);\r\n            func = null;\r\n        }\r\n        return memo;\r\n    };\r\n}\r\n\r\nconst ArrayProto = Array.prototype,\r\n      DateProto = Date.prototype,\r\n      ObjectProto = Object.prototype;\r\n\r\n/**\r\n * Determine whenever two values are not equal, deeply traversing \r\n * arrays and plain JS objects (hashes). Dates are compared by enclosed timestamps, all other\r\n * values are compared with strict comparison.\r\n */\r\nexport function notEqual( a : any, b : any) : boolean {\r\n    if( a === b ) return false;\r\n\r\n    if( a && b && typeof a == 'object' && typeof b == 'object' ) {\r\n        const protoA = Object.getPrototypeOf( a );\r\n\r\n        if( protoA !== Object.getPrototypeOf( b ) ) return true;\r\n\r\n        switch( protoA ){\r\n            case DateProto   : return +a !== +b;\r\n            case ArrayProto  : return arraysNotEqual( a, b );\r\n            case ObjectProto :\r\n            case null:\r\n                return objectsNotEqual( a, b );\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction objectsNotEqual( a, b ) {\r\n    const keysA = Object.keys( a );\r\n\r\n    if( keysA.length !== Object.keys( b ).length ) return true;\r\n\r\n    for( let i = 0; i < keysA.length; i++ ) {\r\n        const key = keysA[ i ];\r\n\r\n        if( !b.hasOwnProperty( key ) || notEqual( a[ key ], b[ key ] ) ) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction arraysNotEqual( a, b ) {\r\n    if( a.length !== b.length ) return true;\r\n\r\n    for( let i = 0; i < a.length; i++ ) {\r\n        if( notEqual( a[ i ], b[ i ] ) ) return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Create an object without Object prototype members except hasOwnProperty.\r\n * @param obj - optional parameter to populate the hash map from.\r\n */\r\nconst HashProto = Object.create( null );\r\nHashProto.hasOwnProperty = ObjectProto.hasOwnProperty;\r\n\r\nexport function hashMap( obj? ){\r\n    const hash = Object.create( HashProto );\r\n    return obj ? assign( hash, obj ) : hash;\r\n}\r\n\r\nexport function compare( a : any, b : any ) : -1 | 0 | 1 {\r\n    // Handle strictly equal values.\r\n    if( a == b ) return 0;\r\n\r\n    // Handle nulls.\r\n    if( a == null ) return -1;\r\n    if( b == null ) return 1;\r\n\r\n    // No nulls. Convert values to primitives.\r\n    const av = a.valueOf(),\r\n        bv = b.valueOf();\r\n\r\n    return  av < bv ? -1 :\r\n            av > bv ? 1 :\r\n            0;\r\n}","import { once as _once } from './tools'\r\n\r\n/*******************\r\n * Prebuilt events map, used for optimized bulk event subscriptions.\r\n *\r\n * const events = new EventMap({\r\n *      'change' : true, // Resend this event from self as it is.\r\n *      'change:attr' : 'localTargetFunction',\r\n *      'executedInTargetContext' : function(){ ... }\r\n *      'executedInNativeContext' : '^props.handler'\r\n * })\r\n */\r\nexport interface EventsDefinition {\r\n    [ events : string ] : Function | string | boolean\r\n}\r\n\r\nexport class EventMap {\r\n    handlers : EventDescriptor[] = [];\r\n\r\n    constructor( map? : EventsDefinition | EventMap ){\r\n        if( map ){\r\n            if( map instanceof EventMap ){\r\n                this.handlers = map.handlers.slice();\r\n            }\r\n            else{\r\n                map && this.addEventsMap( map );\r\n            }\r\n        }\r\n    }\r\n\r\n    merge( map : EventMap ){\r\n        this.handlers = this.handlers.concat( map.handlers );\r\n    }\r\n\r\n    addEventsMap( map : EventsDefinition ){\r\n        for( let names in map ){\r\n            this.addEvent( names, map[ names ] )\r\n        }\r\n    }\r\n\r\n    bubbleEvents( names : string ){\r\n        for( let name of names.split( eventSplitter ) ){\r\n            this.addEvent( name, getBubblingHandler( name ) );\r\n        }\r\n    }\r\n\r\n    addEvent( names : string, callback : Function | string | boolean ){\r\n        const { handlers } = this;\r\n\r\n        for( let name of names.split( eventSplitter ) ){\r\n            handlers.push( new EventDescriptor( name, callback ) );\r\n        }\r\n    }\r\n\r\n    subscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            on( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n\r\n    unsubscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            off( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n}\r\n\r\nexport class EventDescriptor {\r\n    callback : Function\r\n\r\n    constructor(\r\n        public name : string,\r\n        callback : Function | string | boolean\r\n    ){\r\n        if( callback === true ){\r\n            this.callback = getBubblingHandler( name );\r\n        }\r\n        else if( typeof callback === 'string' ){\r\n            this.callback =\r\n                function localCallback(){\r\n                    const handler = this[ callback ];\r\n                    handler && handler.apply( this, arguments );\r\n                };\r\n        }\r\n        else{\r\n            this.callback = <Function>callback;\r\n        }\r\n    }\r\n}\r\n\r\nconst _bubblingHandlers = {};\r\n\r\nfunction getBubblingHandler( event : string ){\r\n    return _bubblingHandlers[ event ] || (\r\n        _bubblingHandlers[ event ] = function( a?, b?, c?, d?, e? ){\r\n            if( d !== void 0 || e !== void 0 ) trigger5( this, event, a, b, c, d, e );\r\n            if( c !== void 0 ) trigger3( this, event, a, b, c );\r\n            else trigger2( this, event, a, b );\r\n        }\r\n    );\r\n}\r\n\r\nexport interface HandlersByEvent {\r\n    [ name : string ] : EventHandler\r\n}\r\n\r\nexport class EventHandler {\r\n    constructor( public callback : Callback, public context : any, public next = null ){}\r\n}\r\n\r\nfunction listOff( _events : HandlersByEvent, name : string, callback : Callback, context : any ){\r\n    const head = _events[ name ];\r\n\r\n    let filteredHead, prev;\r\n\r\n    for( let ev = head; ev; ev = ev.next ){\r\n        // Element must be kept\r\n        if( ( callback && callback !== ev.callback && callback !== ev.callback._callback ) ||\r\n            ( context && context !== ev.context ) ){\r\n            \r\n            prev = ev;\r\n            filteredHead || ( filteredHead = ev );\r\n        }\r\n        // Element must be skipped\r\n        else{\r\n            if( prev ) prev.next = ev.next;\r\n        }\r\n    }\r\n\r\n    if( head !== filteredHead ) _events[ name ] = filteredHead;\r\n}\r\n\r\nfunction listSend2( head : EventHandler, a, b ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b );\r\n}\r\n\r\nfunction listSend3( head : EventHandler, a, b, c ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c );\r\n}\r\n\r\nfunction listSend4( head : EventHandler, a, b, c, d ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d );\r\n}\r\n\r\nfunction listSend5( head : EventHandler, a, b, c, d, e ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e );\r\n}\r\n\r\nfunction listSend6( head : EventHandler, a, b, c, d, e, f ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e, f );\r\n}\r\n\r\nexport interface Callback extends Function {\r\n    _callback? : Function\r\n}\r\n\r\nexport function on( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const _events = source._events || ( source._events = Object.create( null ) );\r\n        _events[ name ] = new EventHandler( callback, context, _events[ name ] );\r\n    }\r\n}\r\n\r\nexport function once( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const once : Callback = _once( function(){\r\n            off( source, name, once );\r\n            callback.apply(this, arguments);\r\n        });\r\n\r\n        once._callback = callback;\r\n        on( source, name, once, context );\r\n    }\r\n}\r\n\r\nexport function off( source : EventSource, name? : string, callback? : Callback, context? : any ) : void {\r\n    const { _events } = source;\r\n    if( _events ){\r\n        if( callback || context ) {\r\n            if( name ){\r\n                listOff( _events, name, callback, context );\r\n            }\r\n            else{\r\n                for( let name in _events ){\r\n                    listOff( _events, name, callback, context );\r\n                }\r\n            }\r\n        }\r\n        else if( name ){\r\n            _events[ name ] = void 0;\r\n        }\r\n        else{\r\n            source._events = void 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport interface EventSource {\r\n    /** @internal */\r\n    _events : HandlersByEvent\r\n}\r\n\r\nconst eventSplitter = /\\s+/;\r\n\r\nexport function strings( api : ApiEntry, source : EventSource, events : string, callback : Callback, context ){\r\n    if( eventSplitter.test( events ) ){\r\n        const names = events.split( eventSplitter );\r\n        for( let name of names ) api( source, name, callback, context );\r\n    }\r\n    else api( source, events, callback, context );\r\n}\r\n\r\nexport type ApiEntry = ( source : EventSource, event : string, callback : Callback, context? : any ) => void\r\n\r\n/*********************************\r\n * Event-triggering API\r\n */\r\n\r\n export function trigger2( self : EventSource, name : string, a, b ) : void {\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend2( queue, a, b );\r\n        listSend3( all, name, a, b );\r\n    }\r\n};\r\n\r\nexport function trigger3( self : EventSource, name : string, a, b, c ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend3( queue, a, b, c );\r\n        listSend4( all, name, a, b, c );\r\n    }\r\n};\r\n\r\nexport function trigger5( self : EventSource, name : string, a, b, c, d, e ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend5( queue, a, b, c, d, e );\r\n        listSend6( all, name, a, b, c, d, e );\r\n    }\r\n};","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/*****************************************************************\r\n * Mixins engine and @define metaprogramming class extensions\r\n *\r\n * Vlad Balin & Volicon, (c) 2016-2017\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { assign, defaults, getBaseClass, hashMap, transform } from './tools';\r\n\r\nexport interface Subclass< T > extends MixableConstructor {\r\n    new ( ...args ) : T\r\n    prototype : T\r\n}\r\n\r\nexport interface MixableConstructor extends Function{\r\n    __super__? : object;\r\n    mixins? : MixinsState;\r\n    onExtend? : ( BaseClass : Function ) => void;\r\n    onDefine? : ( definition : object, BaseClass : Function ) => void;\r\n    define? : ( definition? : object, statics? : object ) => MixableConstructor;\r\n    extend? : <T extends object>( definition? : T, statics? : object ) => Subclass<T>;\r\n}\r\n\r\nexport interface MixableDefinition {\r\n    mixins? : Mixin[]\r\n}\r\n\r\n/**\r\n * Base class, holding metaprogramming class extensions.\r\n * Supports mixins and Class.define metaprogramming method.\r\n */\r\nexport class Mixable {\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static onDefine : ( definition : object, BaseClass : Function ) => object;    \r\n    static __super__ : object\r\n    static mixins : MixinsState;\r\n\r\n    /** \r\n     *  Must be called after inheritance and before 'define'.\r\n     */\r\n    static define( protoProps : MixableDefinition = {}, staticProps? : object ) : MixableConstructor {\r\n        const BaseClass : MixableConstructor = getBaseClass( this );\r\n\r\n        // Assign statics.\r\n        staticProps && assign( this, staticProps );\r\n\r\n        // Extract and apply mixins from the definition.\r\n        const { mixins, ...defineMixin } = protoProps;\r\n        mixins && this.mixins.merge( mixins );\r\n\r\n        // Unshift definition to the the prototype.\r\n        this.mixins.mergeObject( this.prototype, defineMixin, true );\r\n\r\n        // Unshift definition from statics to the prototype.\r\n        this.mixins.mergeObject( this.prototype, this.mixins.getStaticDefinitions( BaseClass ), true );\r\n\r\n        // Call onDefine hook, if it's present.\r\n        this.onDefine && this.onDefine( this.mixins.definitions, BaseClass );\r\n        \r\n        // Apply merge rules to inherited members. No mixins can be added after this point.\r\n        this.mixins.mergeInheritedMembers( BaseClass );\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Backbone-compatible extend method to be used in ES5 and for backward compatibility */\r\n    static extend< T extends object>(spec? : T, statics? : {} ) : Subclass< T > {\r\n        let TheSubclass : Subclass< T >;\r\n\r\n        // 1. Create the subclass (ES5 compatibility shim).\r\n        // If constructor function is given...\r\n        if( spec && spec.hasOwnProperty( 'constructor' ) ){\r\n            // ...we need to manually call internal TypeScript __extend function. Hack! Hack!\r\n            TheSubclass = spec.constructor as any;\r\n            __extends( TheSubclass, this );\r\n        }\r\n        // Otherwise, create the subclall in usual way.\r\n        else{\r\n            TheSubclass = class Subclass extends this {} as any;\r\n        }\r\n\r\n        predefine( TheSubclass );\r\n        spec && TheSubclass.define( spec, statics );\r\n\r\n        return TheSubclass;\r\n    }\r\n}\r\n\r\n/** @decorator `@predefine` for forward definitions. Can be used with [[Mixable]] classes only.\r\n * Forwards the call to the [[Mixable.predefine]];\r\n */\r\nexport function predefine( Constructor : MixableConstructor ) : void {\r\n    const BaseClass : MixableConstructor = getBaseClass( Constructor );\r\n\r\n    // Legacy systems support\r\n    Constructor.__super__ = BaseClass.prototype;\r\n    \r\n    // Initialize mixins structures...\r\n    Constructor.define || MixinsState.get( Mixable ).populate( Constructor );\r\n\r\n    // Make sure Ctor.mixins are ready before the callback...\r\n    MixinsState.get( Constructor );\r\n\r\n    // Call extend hook.\r\n    Constructor.onExtend && Constructor.onExtend( BaseClass );\r\n}\r\n\r\n/** @decorator `@define` for metaprogramming magic. Can be used with [[Mixable]] classes only.\r\n *  Forwards the call to [[Mixable.define]].\r\n */\r\nexport function define( ClassOrDefinition : Function ) : void;\r\nexport function define( ClassOrDefinition : object ) : ClassDecorator;\r\nexport function define( ClassOrDefinition : object | MixableConstructor ){\r\n    // @define class\r\n    if( typeof ClassOrDefinition === 'function' ){\r\n        predefine( ClassOrDefinition );\r\n        ( ClassOrDefinition as MixableConstructor ).define();\r\n    }\r\n    // @define({ prop : val, ... }) class\r\n    else{\r\n        return function( Ctor : MixableConstructor ){\r\n            predefine( Ctor );\r\n            Ctor.define( ClassOrDefinition );\r\n        } as any;\r\n    }\r\n}\r\n\r\nexport function definitions( rules : MixinMergeRules ) : ClassDecorator {\r\n    return ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.definitionRules = defaults( hashMap(), rules, mixins.definitionRules );\r\n    }\r\n}\r\n\r\n// Create simple property list decorator\r\nexport function propertyListDecorator( listName: string ) : PropertyDecorator {\r\n    return function propList(proto, name : string) {\r\n        const list = proto.hasOwnProperty( listName ) ?\r\n            proto[ listName ] : (proto[ listName ] = (proto[ listName ] || []).slice());  \r\n\r\n        list.push(name);\r\n    }\r\n}\r\n\r\nexport function definitionDecorator( definitionKey, value ){\r\n    return ( proto : object, name : string ) => {\r\n        MixinsState\r\n            .get( proto.constructor )\r\n            .mergeObject( proto, {\r\n                [ definitionKey ] : {\r\n                    [ name ] : value\r\n                }\r\n            });\r\n    }\r\n}\r\n\r\nexport class MixinsState {\r\n    mergeRules : MixinMergeRules;\r\n    definitionRules : MixinMergeRules;\r\n    definitions : object = {};\r\n    appliedMixins : Mixin[];\r\n\r\n    // Return mixins state for the class. Initialize if it's not exist.\r\n    static get( Class ) : MixinsState {\r\n        const { mixins } = Class;\r\n    \r\n        return mixins && Class === mixins.Class ? mixins :\r\n             Class.mixins = new MixinsState( Class );\r\n    }\r\n\r\n    constructor( public Class : MixableConstructor ){\r\n        const { mixins } = getBaseClass( Class );\r\n\r\n        this.mergeRules = ( mixins && mixins.mergeRules ) || hashMap();\r\n        this.definitionRules = ( mixins && mixins.definitionRules ) || hashMap();\r\n        this.appliedMixins = ( mixins && mixins.appliedMixins ) || [];\r\n    }\r\n\r\n    getStaticDefinitions( BaseClass : Function ){\r\n        const definitions = hashMap(),\r\n            { Class } = this;\r\n\r\n        return transform( definitions, this.definitionRules, ( rule, name ) =>{\r\n            if( BaseClass[ name ] !== Class[ name ]){\r\n                return Class[ name ];\r\n            }\r\n        });\r\n    }\r\n\r\n    merge( mixins : Mixin[] ){\r\n        const proto      = this.Class.prototype,\r\n            { mergeRules } = this;\r\n\r\n        // Copy applied mixins array as it's going to be updated.\r\n        const appliedMixins = this.appliedMixins = this.appliedMixins.slice();\r\n\r\n        // Apply mixins in sequence...\r\n        for( let mixin of mixins ) {\r\n            // Mixins array should be flattened.\r\n            if( Array.isArray( mixin ) ) {\r\n                this.merge( mixin );\r\n            }\r\n            // Don't apply mixins twice.\r\n            else if( appliedMixins.indexOf( mixin ) < 0 ){\r\n                appliedMixins.push( mixin );\r\n\r\n                // For constructors, merge _both_ static and prototype members.\r\n                if( typeof mixin === 'function' ){\r\n                    // Merge static members\r\n                    this.mergeObject( this.Class, mixin );\r\n\r\n                    // merge definitionRules and mergeRules\r\n                    const sourceMixins = ( mixin as any ).mixins;\r\n                    if( sourceMixins ){\r\n                        this.mergeRules = defaults( hashMap(), this.mergeRules, sourceMixins.mergeRules );\r\n                        this.definitionRules = defaults( hashMap(), this.definitionRules, sourceMixins.definitionRules );\r\n                        this.appliedMixins = this.appliedMixins.concat( sourceMixins.appliedMixins );\r\n                    }\r\n\r\n                    // Prototypes are merged according with rules.\r\n                    this.mergeObject( proto, mixin.prototype );\r\n                }\r\n                // Handle plain object mixins.\r\n                else {\r\n                    this.mergeObject( proto, mixin );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    populate( ...ctors : Function[] ){\r\n        for( let Ctor of ctors ) {\r\n            MixinsState.get( Ctor ).merge([ this.Class ]);\r\n        }\r\n    }\r\n\r\n    mergeObject( dest : object, source : object, unshift? : boolean ) {\r\n        forEachOwnProp( source, name => {\r\n            const sourceProp = Object.getOwnPropertyDescriptor( source, name );\r\n            let rule : MixinMergeRule;\r\n\r\n            if( rule = this.definitionRules[ name ] ){\r\n                assignProperty( this.definitions, name, sourceProp, rule, unshift );\r\n            }\r\n\r\n            if( !rule || rule === mixinRules.protoValue  ){\r\n                assignProperty( dest, name, sourceProp, this.mergeRules[ name ], unshift );\r\n            }\r\n        });\r\n    }\r\n\r\n    mergeInheritedMembers( BaseClass : Function ){\r\n        const { mergeRules, Class } = this;\r\n\r\n        if( mergeRules ){\r\n            const proto = Class.prototype,\r\n                baseProto = BaseClass.prototype;\r\n\r\n            for( let name in mergeRules ) {\r\n                const rule = mergeRules[ name ];\r\n\r\n                if( proto.hasOwnProperty( name ) && name in baseProto ){\r\n                    proto[ name ] = resolveRule( proto[ name ], baseProto[ name ], rule );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst dontMix = {\r\n    function : hashMap({\r\n        length : true,\r\n        prototype : true,\r\n        caller : true,\r\n        arguments : true,\r\n        name : true,\r\n        __super__ : true\r\n    }),\r\n    \r\n    object : hashMap({\r\n        constructor : true\r\n    })    \r\n}\r\n\r\nfunction forEachOwnProp( object : object, fun : ( name : string ) => void ){\r\n    const ignore = dontMix[ typeof object ];\r\n\r\n    for( let name of Object.getOwnPropertyNames( object ) ) {\r\n        ignore[ name ] || fun( name );\r\n    }\r\n}\r\n\r\nexport interface MixinMergeRules {\r\n    [ name : string ] : MixinMergeRule\r\n}\r\n\r\nexport type MixinMergeRule = ( a : any, b : any ) => any\r\nexport type Mixin = { [ key : string ] : any } | Function\r\n\r\n// @mixins( A, B, ... ) decorator.\r\nexport interface MixinRulesDecorator {\r\n    ( rules : MixinMergeRules ) : ClassDecorator\r\n    value( a : object, b : object) : object;\r\n    protoValue( a : object, b : object) : object;\r\n    merge( a : object, b : object ) : object;\r\n    pipe( a: Function, b : Function ) : Function;\r\n    defaults( a: Function, b : Function ) : Function;\r\n    classFirst( a: Function, b : Function ) : Function;\r\n    classLast( a: Function, b : Function ) : Function;\r\n    every( a: Function, b : Function ) : Function;\r\n    some( a: Function, b : Function ) : Function;\r\n}\r\n\r\nexport const mixins = ( ...list : Mixin[] ) => (\r\n    ( Class : Function ) => MixinsState.get( Class ).merge( list )\r\n);\r\n\r\n// @mixinRules({ name : rule, ... }) decorator.\r\nexport const mixinRules = ( ( rules : MixinMergeRules ) => (\r\n    ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.mergeRules = defaults( rules, mixins.mergeRules );\r\n    }\r\n) ) as MixinRulesDecorator;\r\n\r\n// Pre-defined mixin merge rules\r\n\r\nmixinRules.value = ( a, b ) => a;\r\n\r\nmixinRules.protoValue = ( a, b ) => a;\r\n\r\n// Recursively merge members\r\nmixinRules.merge = ( a, b ) => defaults( {}, a, b );\r\n\r\n    // Execute methods in pipe, with the class method executed last.\r\nmixinRules.pipe = ( a, b ) => (\r\n    function( x : any ) : any {\r\n        return a.call( this, b.call( this, x ) );\r\n    }\r\n);\r\n\r\n    // Assume methods return an object, and merge results with defaults (class method executed first)\r\nmixinRules.defaults = ( a : Function, b : Function ) => (\r\n    function() : object {\r\n        return defaults( a.apply( this, arguments ), b.apply( this, arguments ) );\r\n    }\r\n);\r\n\r\n// Execute methods in sequence staring with the class method.\r\nmixinRules.classFirst = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        a.apply( this, arguments );\r\n        b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n    // Execute methods in sequence ending with the class method.\r\nmixinRules.classLast = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        b.apply( this, arguments );\r\n        a.apply( this, arguments );\r\n    }\r\n)\r\n\r\n    // Execute methods in sequence returning the first falsy result.\r\nmixinRules.every = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) && b.apply( this, arguments );\r\n    }\r\n);\r\n    // Execute methods in sequence returning the first truthy result.\r\nmixinRules.some = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) || b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nfunction assignProperty( dest : object, name : string, sourceProp : PropertyDescriptor, rule : MixinMergeRule, unshift? : boolean ){\r\n// Destination prop is defined, thus the merge rules must be applied.\r\n    if( dest.hasOwnProperty( name ) ){\r\n        const destProp = Object.getOwnPropertyDescriptor( dest, name );\r\n\r\n        if( destProp.configurable && 'value' in destProp ){\r\n            dest[ name ] = unshift ?\r\n                resolveRule( sourceProp.value, destProp.value, rule ) :\r\n                resolveRule( destProp.value, sourceProp.value, rule ) ;\r\n        }\r\n    }\r\n    // If destination is empty, just copy the prop over.\r\n    else{\r\n        Object.defineProperty( dest, name, sourceProp );\r\n    }\r\n}\r\n\r\nfunction resolveRule( dest, source, rule : MixinMergeRule ){\r\n    // When destination is empty, take the source.\r\n    if( dest === void 0 ) return source;\r\n\r\n    // In these cases we take non-empty destination:\r\n    if( !rule || source === void 0 ) return dest;\r\n\r\n    // In other cases we must merge values.\r\n    return rule( dest, source );\r\n}","import * as _eventsApi from './eventsource';\r\nimport { EventMap, EventsDefinition, EventSource, HandlersByEvent } from './eventsource';\r\nimport { define, definitions, Mixable, MixableConstructor, mixinRules, MixinsState } from './mixins';\r\nimport { omit, transform } from './tools';\r\n\r\nconst { strings, on, off, once, trigger5, trigger2, trigger3 } = _eventsApi;\r\n\r\nlet _idCount = 0;\r\n\r\nfunction uniqueId() : string {\r\n    return 'l' + _idCount++;\r\n}\r\n\r\nexport { EventMap, EventsDefinition };\r\n\r\nexport interface MessengerDefinition {\r\n    _localEvents? : EventMap\r\n    localEvents? : EventsDefinition\r\n    properties? : PropertyMap\r\n    [ name : string ] : any\r\n}\r\n\r\nexport interface PropertyMap {\r\n    [ name : string ] : Property\r\n}\r\n\r\nexport type Property = PropertyDescriptor | ( () => any )\r\n\r\nexport interface MessengersByCid {\r\n    [ cid : string ] : Messenger\r\n}\r\n\r\nexport type EventCallbacks<Context> = { [ events : string ] : EventCallback<Context> }\r\nexport type EventCallback<Context> = ( ...args : any[] ) => void\r\n\r\n/*************************\r\n * Messenger is mixable class with capabilities of sending and receiving synchronous events.\r\n * This class itself can serve as both mixin and base class.\r\n */\r\n\r\n@define\r\n@definitions({\r\n    properties : mixinRules.merge,\r\n    localEvents : mixinRules.merge\r\n})\r\nexport class Messenger implements Mixable, EventSource {\r\n    // Define extendable mixin static properties.\r\n    /** @internal */\r\n    static __super__ : object;\r\n    static mixins : MixinsState;\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static define : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static extend : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static onDefine({ localEvents, _localEvents, properties } : MessengerDefinition, BaseClass? : typeof Mixable ){\r\n        // Handle localEvents definition\r\n        if( localEvents || _localEvents ){\r\n            const eventsMap = new EventMap( this.prototype._localEvents );\r\n\r\n            localEvents && eventsMap.addEventsMap( localEvents );\r\n            _localEvents && eventsMap.merge( _localEvents );\r\n            \r\n            this.prototype._localEvents = eventsMap;\r\n        }\r\n\r\n        // Handle properties definitions...\r\n        if( properties ){\r\n            Object.defineProperties( this.prototype, transform( {}, <PropertyMap>properties, toPropertyDescriptor ) );\r\n        }\r\n    }\r\n\r\n    /** @internal */ \r\n    _events : HandlersByEvent = void 0;\r\n\r\n    /** @internal */ \r\n    _listeningTo : MessengersByCid = void 0\r\n\r\n    /** Unique client-only id. */\r\n    cid : string\r\n\r\n    /** Prototype-only property to manage automatic local events subscription */ \r\n    protected _localEvents : EventMap\r\n\r\n    constructor(){\r\n        this.cid = uniqueId();\r\n        this.initialize.apply( this, arguments );\r\n\r\n        // TODO: local events subscribe?\r\n    }\r\n\r\n    /** Method is called at the end of the constructor */\r\n    initialize() : void {}\r\n    \r\n    on( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( on, this, events, callback, context );\r\n        else for( let name in events ) strings( on, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    once( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( once, this, events, callback, context );\r\n        else for( let name in events ) strings( once, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    off( events? : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( !events ) off( this, void 0, callback, context );\r\n        else if( typeof events === 'string' ) strings( off, this, events, callback, context );\r\n        else for( let name in events ) strings( off, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\r\n    // passed the same arguments as `trigger` is, apart from the event name\r\n    // (unless you're listening on `\"all\"`, which will cause your callback to\r\n    // receive the true name of the event as the first argument).\r\n    trigger(name : string, a?, b?, c?, d?, e? ) : this {\r\n        if( d !== void 0 || e !== void 0 ) trigger5( this, name, a, b, c, d, e );\r\n        else if( c !== void 0 ) trigger3( this, name, a, b, c );\r\n        else trigger2( this, name, a, b );\r\n        return this;\r\n    }\r\n\r\n    listenTo( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.on( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    listenToOnce( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.once( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    stopListening( a_source? : Messenger, a? : string | EventCallbacks<this>, b? : Function ) : this {\r\n        const { _listeningTo } = this;\r\n        if( _listeningTo ){\r\n            const removeAll = !( a || b ),\r\n                  second = !b && typeof a === 'object' ? this : b;\r\n\r\n            if( a_source ){\r\n                const source = _listeningTo[ a_source.cid ];\r\n                if( source ){\r\n                    if( removeAll ) delete _listeningTo[ a_source.cid ];\r\n                    source.off( a, second, this );\r\n                }\r\n            }\r\n            else if( a_source == null ){\r\n                for( let cid in _listeningTo ) _listeningTo[ cid ].off( a, second, this );\r\n\r\n                if( removeAll ) ( this._listeningTo = void 0 );\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destructor. Stops messenger from listening to all objects,\r\n     * and stop others from listening to the messenger. \r\n     */\r\n    _disposed : boolean\r\n\r\n    dispose() : void {\r\n        if( this._disposed ) return;\r\n\r\n        this.stopListening();\r\n        this.off();\r\n\r\n        this._disposed = true;\r\n    }\r\n}\r\n\r\n/**\r\n * Backbone 1.2 API conformant Events mixin.\r\n */\r\nexport const Events : Messenger = <Messenger> omit( Messenger.prototype, 'constructor', 'initialize' );\r\n\r\n/**\r\n * Messenger Private Helpers \r\n */\r\n\r\nfunction toPropertyDescriptor( x : Property ) : PropertyDescriptor {\r\n    if( x ){\r\n        return typeof x === 'function' ? { get : < () => any >x, configurable : true } : <PropertyDescriptor> x;\r\n    }\r\n}\r\n\r\nfunction addReference( listener : Messenger, source : Messenger ){\r\n      const listeningTo = listener._listeningTo || (listener._listeningTo = Object.create( null ) ),\r\n            cid = source.cid || ( source.cid = uniqueId() );\r\n\r\n      listeningTo[ cid ] = source;\r\n}","import { Messenger } from './events'\r\nimport { define } from './mixins';\r\n\r\nexport type LogLevel = 'error' | 'warn' | 'debug' | 'info' | 'log';\r\nexport type LoggerEventHandler = ( topic : string, msg : string, props : object )  => void;\r\n\r\nexport const isProduction = typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production',\r\n    logEvents : LogLevel[] =  isProduction ?\r\n        [ 'error', 'info' ] :\r\n        [ 'error', 'warn', 'debug', 'info', 'log' ];\r\n\r\n@define\r\nexport class Logger extends Messenger {\r\n    counter : { [ level in LogLevel ]? : number } = {}\r\n\r\n    // Log events of the given log level to the console, optionally filtered by topic\r\n    logToConsole( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                const args = [ `[${topic}] ${msg}` ];\r\n        \r\n                for( let name in props ){\r\n                    args.push( `\\n\\t${name}:`, toString( props[ name ] ) );\r\n                }\r\n        \r\n                console[ level ].apply( console, args );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Fire exception on the events of the given log level, optionally filtered by topic\r\n    throwOn( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                throw new Error( `[${topic}] ${msg}` );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Count log events of the given level, optionally filtered by topic\r\n    count( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                this.counter[ level ] = ( this.counter[ level ] || 0 ) + 1;\r\n            }\r\n        });\r\n    }\r\n\r\n    trigger : ( level : LogLevel, topic : string, message : string, props? : object ) => this;\r\n    \r\n    off : ( event? : LogLevel ) => this;\r\n\r\n\r\n    on( handlers : { [ name in LogLevel ] : LoggerEventHandler } ) : this;\r\n    on( handlers : LogLevel, handler : LoggerEventHandler ) : this;\r\n    on( handlers : 'all', handler : ( level : LogLevel, topic : string, msg : string, props : object )  => void ) : this;\r\n    on( a : any, b? : any ){\r\n        return super.on( a, b );\r\n    }\r\n}\r\n\r\n/**\r\n * Convert objects to the plain text friendly format.\r\n * primitives as in JSON.\r\n */\r\nlet toString = typeof window === 'undefined' ? \r\n    something => {\r\n        if( something && typeof something === 'object' ){\r\n            // Support custom object wrappers...\r\n            const value = something.__inner_state__ || something,\r\n                isArray = Array.isArray( value );\r\n\r\n            const body = isArray ? `[ length = ${ value.length } ]` : `{ ${ Object.keys( value ).join( ', ' )} }`;\r\n\r\n            return something.constructor.name + ' ' + body;\r\n        }\r\n\r\n        return JSON.stringify( something );\r\n    }\r\n    : x => x;\r\n\r\nexport const logger = new Logger();\r\n\r\nif( typeof console !== 'undefined' ) {\r\n    for( let event of logEvents ){\r\n        logger.logToConsole( event );\r\n    }\r\n}\r\n\r\nexport const throwingLogger = new Logger();\r\nthrowingLogger.throwOn( 'error' ).throwOn( 'warn' );\r\n\r\nexport const log : typeof logger.trigger = logger.trigger.bind( logger );","export interface IONode {\r\n    /** @internal */\r\n    _endpoint : IOEndpoint\r\n\r\n    /** @internal */\r\n    _ioPromise : IOPromise< this >\r\n}\r\n\r\nexport interface IOPromise<T> extends Promise<T> {\r\n    abort? : () => void\r\n}\r\n\r\nexport interface IOEndpoint {\r\n    list( options : IOOptions, collection? ) : IOPromise<any>\r\n    create( json : any, options : IOOptions, record? ) : IOPromise<any>\r\n    update( id : string | number, json :any, options : IOOptions, record? ) : IOPromise<any>\r\n    read( id : string | number, options : IOOptions, record? ) : IOPromise<any>\r\n    destroy( id : string | number, options : IOOptions, record? ) : IOPromise<any>\r\n    subscribe( events : IOEvents, collection? ) : IOPromise<any>\r\n    unsubscribe( events : IOEvents, collection? ) : void\r\n}\r\n\r\nexport interface IOOptions {\r\n    ioMethod? : 'save' | 'fetch'\r\n}\r\n\r\nexport interface IOEvents {\r\n    updated? : ( json : any ) => void\r\n    removed? : ( json : any ) => void\r\n}\r\n\r\nexport function getOwnerEndpoint( self ) : IOEndpoint {\r\n    // Check if we are the member of the collection...\r\n    const { collection } = self;\r\n    if( collection ){\r\n        return getOwnerEndpoint( collection );\r\n    }\r\n\r\n    // Now, if we're the member of the model...\r\n    if( self._owner ){\r\n        const { _endpoints } = self._owner;\r\n        return _endpoints && _endpoints[ self._ownerKey ];\r\n    }\r\n}\r\n\r\n/**\r\n * Create abortable promise.\r\n * Adds `promise.abort()` function which rejects the promise by default\r\n * initialize() function takes third optional argument `abort : ( resolve, reject ) => void`,\r\n * which can be used to add custom abort handling.\r\n */\r\ndeclare var Promise: PromiseConstructorLike;\r\n\r\nexport function createIOPromise( initialize : InitIOPromise ) : IOPromise<any>{\r\n    let resolve, reject, onAbort;\r\n\r\n    function abort( fn ){\r\n        onAbort = fn;\r\n    }\r\n\r\n    const promise : IOPromise<any> = new Promise( ( a_resolve, a_reject ) =>{\r\n        reject = a_reject;\r\n        resolve = a_resolve;\r\n        initialize( resolve, reject, abort );\r\n    }) as IOPromise<any>;\r\n\r\n    promise.abort = () => {\r\n        onAbort ? onAbort( resolve, reject ) : reject( new Error( \"I/O Aborted\" ) );\r\n    }\r\n\r\n    return promise;\r\n}\r\n\r\nexport type InitIOPromise = ( resolve : ( x? : any ) => void, reject : ( x? : any ) => void, abort? : ( fn : Function ) => void ) => void;\r\n\r\nexport function startIO( self : IONode, promise : IOPromise<any>, options : IOOptions, thenDo : ( json : any ) => any ) : IOPromise<any> {\r\n    // Stop pending I/O first...\r\n    abortIO( self );\r\n\r\n    self._ioPromise = promise\r\n        .then( resp => {\r\n            self._ioPromise = null;\r\n    \r\n            const result = thenDo ? thenDo( resp ) : resp;\r\n                \r\n            triggerAndBubble( self, 'sync', self, resp, options );\r\n                \r\n            return result;\r\n        } )  \r\n        .catch( err => {\r\n            self._ioPromise = null;\r\n            \r\n            // Overlaps with a new `error` event.\r\n            triggerAndBubble( self, 'error', self, err, options );\r\n            \r\n            throw err;\r\n        } ) as IOPromise<any>;\r\n\r\n    self._ioPromise.abort = promise.abort;\r\n\r\n    return self._ioPromise;\r\n}\r\n\r\nexport function abortIO( self : IONode ){\r\n    if( self._ioPromise && self._ioPromise.abort ){\r\n        self._ioPromise.abort();\r\n        self._ioPromise = null;\r\n    }\r\n}\r\n\r\nexport function triggerAndBubble( eventSource, ...args ){\r\n    eventSource.trigger.apply( eventSource, args );\r\n    const { collection } = eventSource;\r\n    collection && collection.trigger.apply( collection, args ); \r\n}","/**\r\n * Traversable objects and symbolic references\r\n */\r\nexport interface Traversable {\r\n    getStore() : Traversable\r\n    getOwner() : Traversable\r\n    get( key : string ) : any \r\n}\r\n\r\nconst referenceMask =  /\\^|(store\\.[^.]+)|([^.]+)/g;\r\n\r\n// Compile reference to function\r\nexport type ResolveReference = ( root : Traversable ) => any;  \r\n\r\nexport class CompiledReference {\r\n    resolve : ResolveReference\r\n    tail : string\r\n    local : boolean\r\n\r\n    constructor( reference : string, splitTail : boolean = false ){\r\n        const path = reference\r\n                        .match( referenceMask )\r\n                        .map( key => {\r\n                            if( key === '^' || key === 'owner' ) return 'getOwner()';\r\n\r\n                            if( key[ 0 ] === '~' ) return `getStore().get(\"${ key.substr( 1 ) }\")`;\r\n\r\n                            if( key.indexOf( 'store.' ) === 0 ) return `getStore().get(\"${ key.substr( 6 ) }\")`;\r\n                            \r\n                            return key;\r\n                        } );\r\n               \r\n        this.tail = splitTail && path.pop();\r\n        this.local = !path.length;\r\n        \r\n        this.resolve = <any> new Function( 'self', `\r\n            var v = self.${ path.shift() };\r\n                           \r\n            ${ path.map( x => `\r\n                v = v && v.${ x };\r\n            `).join('')}\r\n\r\n            return v;\r\n        ` );\r\n    }\r\n}\r\n\r\nexport function resolveReference( root : Traversable, reference : string, action : ( object, key : string ) => any ) : any {\r\n    const path = reference.match( referenceMask ),\r\n          skip = path.length - 1;\r\n    \r\n    let self = root;\r\n\r\n    for( var i = 0; i < skip; i++ ){\r\n        const key = path[ i ];\r\n        switch( key ){\r\n            case '~' : self = self.getStore(); break;\r\n            case '^' : self = self.getOwner(); break;\r\n            default  : self = self.get( key );\r\n        }\r\n\r\n        // Do nothing if object on the path doesn't exist.\r\n        if( !self ) return;\r\n    }\r\n\r\n    return action( self, path[ skip ] );\r\n}","export interface ChildrenErrors {\r\n    [ key : string ] : ValidationError | any\r\n} \r\n\r\nexport interface Validatable {\r\n    /** @internal */\r\n    _validateNested( errors : ChildrenErrors ) : number;\r\n    \r\n    validate( self : any ) : any\r\n    get( key : string ) : any\r\n}\r\n\r\n// Validation error object.\r\nexport class ValidationError {\r\n    // Invalid nested object keys \r\n    nested : ChildrenErrors \r\n    length : number\r\n\r\n    // Local error\r\n    error : any\r\n\r\n    constructor( obj : Validatable ){\r\n        this.length = obj._validateNested( this.nested = {} );\r\n\r\n        if( this.error = obj.validate( obj ) ){\r\n            this.length++;\r\n        }\r\n    }\r\n\r\n    each( iteratee : ( value : any, key : string ) => void ) : void {\r\n        const { error, nested } = this;\r\n\r\n        if( error ) iteratee( error, null );\r\n\r\n        for( const key in nested ){\r\n            iteratee( nested[ key ], key );\r\n        }\r\n    }\r\n\r\n    eachError( iteratee : ( error : any, key : string, object : Validatable ) => void, object : Validatable ) : void {\r\n        this.each( ( value : any, key : string ) => {\r\n            if( value instanceof ValidationError ){\r\n                (<ValidationError>value).eachError( iteratee, object.get( key ) );\r\n            }\r\n            else{\r\n                iteratee( value, key, object );\r\n            }\r\n        });\r\n    }\r\n}","/**\r\n * Select appropriate helpers function for particular value type.\r\n */\r\nexport interface IterableLink {\r\n    value : any\r\n    at( key : number | string ) : any\r\n}\r\n\r\nexport type Iterator = ( link : any, key : string | number ) => any;\r\n\r\nexport interface Helper {\r\n    map( link : IterableLink, iterator : Iterator ) : any[]\r\n    clone( obj : any ) : any,\r\n    remove( obj : any, key : string | number ) : any\r\n}\r\n\r\nconst ArrayProto = Array.prototype,\r\n      ObjectProto = Object.prototype;\r\n\r\nexport function helpers( value ) : Helper {\r\n    if( value && typeof value === 'object' ){\r\n        switch( Object.getPrototypeOf( value ) ){\r\n            case ArrayProto  : return arrayHelpers;\r\n            case ObjectProto : return objectHelpers;\r\n        }\r\n    }\r\n\r\n    return dummyHelpers;\r\n}\r\n\r\n// Do nothing for types other than Array and plain Object.\r\nconst dummyHelpers : Helper = {\r\n    clone( value ){ return value; },\r\n    map( link : IterableLink, fun ){ return []; },\r\n    remove( value ){ return value; }\r\n};\r\n\r\n// `map` and `clone` for plain JS objects\r\nexport const objectHelpers : Helper = {\r\n    // Map through the link to object\r\n    map( link : IterableLink, iterator : Iterator ) : any[] {\r\n        let mapped = [],\r\n            { value } = link\r\n\r\n        for( let key in value ){\r\n            if( value.hasOwnProperty( key ) ){\r\n                const element = iterator( link.at( key ), key );\r\n                element === void 0 || ( mapped.push( element ) );    \r\n            }\r\n        }\r\n\r\n        return mapped;\r\n    },\r\n\r\n    remove( object : {}, key : string ) : {} {\r\n        delete object[ key ];\r\n        return object;\r\n    },\r\n\r\n     // Shallow clone plain JS object\r\n    clone( object : {} ) : {} {\r\n        return { ...object };\r\n    }\r\n};\r\n\r\n// `map` and `clone` helpers for arrays.\r\nexport const arrayHelpers : Helper = {\r\n    // Shallow clone array\r\n    clone( array : any[] ) : any[] {\r\n        return array.slice();\r\n    },\r\n\r\n    remove( array : any[], i : number ) : any[] {\r\n        array.splice( i, 1 );\r\n        return array;\r\n    },\r\n\r\n    // Map through the link to array\r\n    map( link : IterableLink, iterator : Iterator ) : any[] {\r\n        const length = link.value.length,\r\n              mapped = Array( length );\r\n\r\n        for( var i = 0, j = 0; i < length; i++ ){\r\n            const y = iterator( link.at( i ), i );\r\n            y === void 0 || ( mapped[ j++ ] = y );\r\n        }\r\n\r\n        mapped.length === j || ( mapped.length = j );\r\n\r\n        return mapped;\r\n    }\r\n};","/**\r\n * Advanced React links for purely functional two-way data binding\r\n *\r\n * MIT License, (c) 2016 Vlad Balin, Volicon.\r\n */\r\nimport { arrayHelpers, helpers } from './helpers';\r\n\r\nexport * from './helpers'\r\n\r\n/** \r\n * `Linked` class is an abstract linked value - the value, the function to update this value, and its validation error.\r\n * The enclosed value is considered as immutable.\r\n */ \r\nexport abstract class Linked<T>{\r\n    /** Validation error. Usually is a string with error text, but can hold any type. */ \r\n    error : any = void 0\r\n    \r\n    /** Set linked value */ \r\n    abstract set( x : T ) : void\r\n\r\n    constructor( public value : T ){}\r\n\r\n    /** EXPERIMENTAL: Support useRef interface. */ \r\n    get current(){ return this.value; }\r\n    set current( x : T ){ this.set( x ); }\r\n\r\n    // Private accessor for whenChanged. Uniform with Type-R models and collections API.\r\n    protected get _changeToken(){\r\n        return this.value;\r\n    }\r\n\r\n    /** Produce the new link executing the given function before the link value will be updated. */\r\n    onChange( handler : ( x : T ) => void ) : Linked<T> {\r\n        return new ClonedValueLink( this, ( x : T ) => {\r\n            handler( x );\r\n            this.set( x );\r\n        });\r\n    }\r\n\r\n    /** Produce the new link which transform the value before `set` with a given function. */\r\n    pipe( handler : Linked.Transform<T> ) : Linked< T > {\r\n        return new ClonedValueLink( this, x =>{\r\n            const next = handler( x, this.value );\r\n            next === void 0 || this.set( next );\r\n        } );\r\n    }\r\n\r\n    /** \r\n     * Create React component props for the <input> component.\r\n     * \r\n     * <input { ...link.props } />\r\n     */ \r\n    get props() :\r\n        T extends boolean ? { checked : boolean, onChange : ( e : any ) => void } :\r\n            { value : T, onChange : ( e : any ) => void }\r\n    {\r\n        return typeof this.value === 'boolean' ? {\r\n            checked : this.value,\r\n            onChange : e => this.set( Boolean( e.target.checked ) as any )\r\n        }:{\r\n            value : this.value,\r\n            onChange : e => this.set( e.target.value )\r\n        } as any;\r\n    }\r\n\r\n    /** Update the linked value using given transform function. */ \r\n    update( transform : Linked.Transform<T>, e? : Object ) : void {\r\n        const next = transform( this.clone(), e );\r\n        next === void 0 || this.set( next );\r\n    }\r\n\r\n    // Create UI event handler function which will update the link with a given transform function.\r\n    action( transform : Linked.Transform< T > ) : Linked.EventHandler {\r\n        return e => this.update( transform, e );\r\n    }\r\n\r\n    equals( truthyValue : T ) : Linked<boolean> {\r\n        return new EqualsValueLink( this, truthyValue );\r\n    }\r\n\r\n    get true( this : Linked<boolean> ){\r\n        return () => this.set( true );\r\n    }\r\n\r\n    get false( this : Linked<boolean> ){\r\n        return () => this.set( false );\r\n    }\r\n\r\n    get null(){\r\n        return () => this.set( null );\r\n    }\r\n\r\n    get isTruthy(){\r\n        return this.value ? true : undefined;\r\n    }\r\n\r\n    enabled( defaultValue? : T ) : Linked<boolean> {\r\n        return new EnabledValueLink( this, defaultValue || \"\" );\r\n    }\r\n\r\n    // Array-only links methods\r\n    contains<E>( this : Linked<E[]>, element : E ) : Linked<boolean>{\r\n        return new ContainsRef( this, element );\r\n    }\r\n\r\n    push<E>( this : Linked<E[]>, ...args : E[] ) : void;\r\n    push(){\r\n        const array = arrayHelpers.clone( this.value );\r\n        Array.prototype.push.apply( array, arguments );\r\n        this.set( array );\r\n    }\r\n\r\n    unshift<E>( this : Linked<E[]>, ...args : E[] ) : void;\r\n    unshift() : void {\r\n        const array = arrayHelpers.clone( this.value );\r\n        Array.prototype.unshift.apply( array, arguments );\r\n        this.set( array );\r\n    }\r\n\r\n    \r\n    splice( this : Linked<any[]>, start : number, deleteCount? : number ) : void;\r\n    splice() : void {\r\n        const array = arrayHelpers.clone( this.value );\r\n        Array.prototype.splice.apply( array, arguments );\r\n        this.set( array );\r\n    }\r\n\r\n    // Array and objects universal collection methods\r\n    map<E, Z>( this : Linked<E[]>, iterator : ( link : PropValueLink<E, number>, idx : number ) => Z ) : Z[];\r\n    map<E, Z>( this : Linked<{[ key : string ] : E }>, iterator : ( link : PropValueLink<E, string>, idx : string ) => Z ) : Z[];\r\n    map( iterator ) {\r\n        return helpers( this.value ).map( this, iterator );\r\n    }\r\n\r\n    removeAt<E>( this : Linked<E[]>, key : number ) : void;\r\n    removeAt<E>( this : Linked<{ [ key : string ] : E }>, key : string ) : void;\r\n    removeAt( key ){\r\n        const { value } = this,\r\n            _ = helpers( value );\r\n\r\n        this.set( _.remove( _.clone( value ), key ) );\r\n    }\r\n\r\n    at<E>( this : Linked<E[]>, key : number ) : PropValueLink<E, number>;\r\n    at<K extends keyof T, E extends T[K]>( key : K ) : PropValueLink<E, K>;\r\n    at( key ){\r\n        return new PropValueLink( this, key );\r\n    }\r\n\r\n    clone() : T {\r\n        let { value } = this;\r\n        return helpers( value ).clone( value );\r\n    }\r\n\r\n    /**\r\n     * Convert link to object to the object of links. Optionally filter by \r\n     */\r\n    pick< K extends keyof T >( ...keys : K[]) : {[ P in K ]: Linked<T[P]>}\r\n    pick() {\r\n        let links = {}, keys = arguments.length ? arguments : Object.keys( this.value );\r\n\r\n        for( let i = 0; i < keys.length; i++ ){\r\n            const key : string = keys[ i ];\r\n            links[ key ] = new PropValueLink( this, key );\r\n        }\r\n\r\n        return links;\r\n    }\r\n\r\n    /**\r\n     * Convert link to object to the object of links.\r\n     * Memorises the result, subsequent calls are cheap.\r\n     */\r\n    get $() : T extends object ? Linked.Hash<T> : never {\r\n        if( !this._value$ ){\r\n            let links : Linked.Hash<any> = this._value$ = {},\r\n                { value } = this;\r\n\r\n            for( let key in value ){\r\n                if( value.hasOwnProperty( key ) ){\r\n                    links[ key ] = new PropValueLink( this, key );\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._value$ as any;\r\n    }\r\n\r\n    private _value$ : object\r\n\r\n    /**\r\n     * Validate link with validness predicate and optional custom error object. Can be chained.\r\n     */\r\n    check( whenValid : Linked.Validator<T>, error? : any ) : this {\r\n        if( !this.error && !whenValid( this.value ) ){\r\n            this.error = error || whenValid.error || defaultError;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nexport namespace Linked {\r\n    export interface Validator< T >{\r\n        ( value : T ) : boolean\r\n        error? : any\r\n    }    \r\n\r\n    export type Transform< T > = ( value : T, event? : {} ) => T\r\n    export type EventHandler = ( event : {} ) => void\r\n\r\n    export type Hash<T extends object = any> = {\r\n        [K in keyof T] : Linked<T[K]>\r\n    }\r\n\r\n    /** Create linked value out of its value and the set function */ \r\n    export function value<T>( value : T, set : ( x : T ) => void ) : Linked<T>{\r\n        return new CustomValueLink( value, set );\r\n    }\r\n\r\n    export function mutable<T extends object>( state : T ) : Linked<T>{\r\n        return new CustomValueLink( state, x => {\r\n            for( let key in x ){\r\n                if( x.hasOwnProperty( key ) ){\r\n                    state[ key ] = x[ key ];\r\n                }\r\n            }\r\n        } );\r\n    }\r\n\r\n    /**\r\n    * Unwrap object with links, returning an object of a similar shape filled with link values.\r\n    */\r\n    export function getValues<T extends object>( links : Linked.Hash<T> ) : T {\r\n        return unwrap( links, 'value' ) as any;\r\n    }\r\n\r\n    /**\r\n     * Unwrap object with links, returning an object of a similar shape filled with link errors.\r\n     */\r\n    export function getErrors<T extends object>( links : Linked.Hash<T> ) : { [ name in keyof T ] : any } {\r\n        return unwrap( links, 'error' ) as any;\r\n    }\r\n\r\n    /**\r\n     * Return true if an object with links contains any errors.\r\n     */\r\n    export function hasErrors<T extends object>( links : Linked.Hash<T> ) : boolean {\r\n        for( let key in links ){\r\n            if( links.hasOwnProperty( key ) && links[ key ].error ){\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Assing links with values from the source object.\r\n    */\r\n   export function setValues<T extends object>( links : Linked.Hash<T>, source : T ) : void {\r\n        if( source ){\r\n            for( let key in links ){\r\n                const sourceKey = trim( key );\r\n                if( source.hasOwnProperty( sourceKey ) ){\r\n                    const sourceVal = source[ sourceKey ];\r\n                    sourceVal === void 0 || links[ key ].set( sourceVal );\r\n                }\r\n            }    \r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass CustomValueLink< T > extends Linked< T > {\r\n    set( x ){}\r\n\r\n    constructor( value : T, set : ( x : T ) => void ){\r\n        super( value );\r\n        this.set = set;\r\n    }\r\n}\r\n\r\nclass ClonedValueLink< T > extends Linked< T > {\r\n    set( x ){}\r\n\r\n    constructor( parent : Linked< T >, set : ( x : T ) => void ){\r\n        super( parent.value );\r\n        this.set = set;\r\n\r\n        const { error } = parent;\r\n        if( error ) this.error = error;\r\n    }\r\n}\r\n\r\nclass EqualsValueLink extends Linked< boolean > {\r\n    constructor( public parent : Linked< any >, public truthyValue ){\r\n        super( parent.value === truthyValue );\r\n    }\r\n\r\n    set( x : boolean ) : void {\r\n        this.parent.set( x ? this.truthyValue : null );\r\n    }\r\n}\r\n\r\nclass EnabledValueLink extends Linked< boolean > {\r\n    constructor( public parent : Linked< any >, public defaultValue ){\r\n        super( parent.value != null );\r\n    }\r\n\r\n    set( x : boolean ){\r\n        this.parent.set( x ? this.defaultValue : null );\r\n    }\r\n}\r\n\r\nclass ContainsRef extends Linked< boolean > {\r\n    constructor( public parent : Linked< any >, public element : any ){\r\n        super( parent.value.indexOf( element ) >= 0 );\r\n    }\r\n\r\n    set( x : boolean ){\r\n        var next = Boolean( x );\r\n\r\n        if( this.value !== next ){\r\n            var arr : any[] = this.parent.value,\r\n                nextValue = x ? arr.concat( this.element ) : arr.filter( el => el !== this.element );\r\n\r\n            this.parent.set( nextValue );\r\n        }\r\n    }\r\n}\r\n\r\nconst  defaultError = 'Invalid value';\r\n\r\n/**\r\n * Link to array or object element enclosed in parent link.\r\n * Performs purely functional update of the parent, shallow copying its value on `set`.\r\n */\r\nexport class PropValueLink< E, K > extends Linked< E > {\r\n    constructor( private parent : Linked< any >, public key : K ){\r\n        super( parent.value[ key ] );\r\n    }\r\n\r\n    remove(){\r\n        this.parent.removeAt( <any>this.key );\r\n    }\r\n\r\n    update( transform : Linked.Transform<E>, e? : Object ) : void {\r\n        const { key } = this;\r\n\r\n        this.parent.update( obj => {\r\n            const prev = obj[ key ],\r\n                next = transform( helpers( prev ).clone( prev ), e );\r\n\r\n            if( next !== void 0 ){\r\n                obj[ key ] = next;\r\n                return obj;\r\n            }\r\n        } );\r\n    }\r\n\r\n    // Set new element value to parent array or object, performing purely functional update.\r\n    set( next : E ) : void {\r\n        /*\r\n        this.update( prev => {\r\n            if( prev !== next ) return next\r\n        })*/\r\n\r\n        // A bit more efficient implementation.\r\n        const { key } = this;\r\n\r\n        this.parent.update( obj => {\r\n            if( obj[ key ] !== next ){\r\n                obj[ key ] = next;\r\n                return obj;\r\n            }\r\n        });\r\n\r\n        \r\n    };\r\n}\r\n\r\nfunction unwrap( links : Linked.Hash, field : string) : object {\r\n    const values = {};\r\n\r\n    for( let key in links ){\r\n        if( links.hasOwnProperty( key ) ){\r\n            const value = links[ key ][ field ];\r\n            if( value !== void 0 ){\r\n                values[ trim( key ) ] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    return values;\r\n}\r\n\r\nfunction trim( key : string ){\r\n    return key[ 0 ] === '$' ? key.slice( 1 ) : key;\r\n}","import { abortIO, IOEndpoint, IONode, IOPromise } from './io-tools';\r\nimport { EventCallbacks, define, definitions, eventsApi, Logger, LogLevel, Messenger, MessengerDefinition, MessengersByCid, mixinRules, mixins, MixinsState, throwingLogger } from '@type-r/mixture';\r\nimport { resolveReference, Traversable } from './traversable';\r\nimport { ChildrenErrors, Validatable, ValidationError } from './validation';\r\nimport { Linked } from '@linked/value/lib';\r\n\r\nconst { trigger3, on, off } = eventsApi;\r\n/***\r\n * Abstract class implementing ownership tree, tho-phase transactions, and validation. \r\n * 1. createTransaction() - apply changes to an object tree, and if there are some events to send, transaction object is created.\r\n * 2. transaction.commit() - send and process all change events, and close transaction.\r\n */\r\n\r\n/** @private */\r\nexport interface TransactionalDefinition extends MessengerDefinition {\r\n    endpoint? : IOEndpoint\r\n}\r\n\r\nexport enum ItemsBehavior {\r\n    share       = 0b0001,\r\n    listen      = 0b0010,\r\n    persistent  = 0b0100\r\n}\r\n\r\n// Transactional object interface\r\n\r\n/**\r\n * Used to access the version token of the object,\r\n * which changes every time something inside of the object is changed.\r\n * \r\n * useEffect( () => data.fetch(), [ state[versionToken] ])\r\n */\r\nexport const versionToken = '_changeToken';\r\nexport const defaultStore = '_defaultStore';\r\n\r\nexport interface Transactional extends Messenger {}\r\n\r\n@define\r\n@definitions({\r\n    endpoint : mixinRules.value\r\n})\r\n@mixins( Messenger )\r\nexport abstract class Transactional implements Messenger, IONode, Validatable, Traversable {\r\n    // Mixins are hard in TypeScript. We need to copy type signatures over...\r\n    // Here goes 'Mixable' mixin.\r\n    static endpoint : IOEndpoint;\r\n    \r\n    /** @internal */\r\n    static __super__ : object;\r\n    \r\n    static mixins : MixinsState;\r\n    static define : ( definition? : TransactionalDefinition, statics? : object ) => typeof Transactional;\r\n    static extend : <T extends TransactionalDefinition>( definition? : T, statics? : object ) => any;\r\n\r\n    static onDefine( definitions : TransactionalDefinition, BaseClass : typeof Transactional ){\r\n        if( definitions.endpoint ) this.prototype._endpoint = definitions.endpoint;\r\n        Messenger.onDefine.call( this, definitions, BaseClass );\r\n    };\r\n\r\n    static onExtend( BaseClass : typeof Transactional ) : void {\r\n        // Make sure we don't inherit class factories.\r\n        if( BaseClass.create === this.create ) {\r\n            this.create = Transactional.create;\r\n        }\r\n    }\r\n\r\n    // Define extendable mixin static properties.\r\n    static create<M extends new ( ...args ) => any>( this : M, a? : any, b? : any ) : InstanceType<M> {\r\n        return new (this as any)( a, b );\r\n    }\r\n\r\n    // State accessor.\r\n    /** @internal */\r\n    readonly __inner_state__ : any;\r\n\r\n    // Shared modifier (used by collections of shared models)\r\n    /** @internal */\r\n    _shared? : number; \r\n    \r\n    dispose() : void {\r\n        if( this._disposed ) return;\r\n        \r\n        abortIO( this );\r\n        this._owner = void 0;\r\n        this._ownerKey = void 0;\r\n        this.off();\r\n        this.stopListening();\r\n        this._disposed = true;\r\n    }\r\n    \r\n    cidPrefix : string\r\n\r\n    // Unique version token replaced on change\r\n    /** @internal */\r\n    _changeToken : {} = {}\r\n\r\n    // true while inside of the transaction\r\n    /** @internal */\r\n    _transaction : boolean = false;\r\n\r\n    // Holds current transaction's options, when in the middle of transaction and there're changes but is an unsent change event\r\n    /** @internal */\r\n    _isDirty  : TransactionOptions = null;\r\n\r\n    // Backreference set by owner (Model, Collection, or other object)\r\n    /** @internal */\r\n    _owner : Owner = void 0;\r\n\r\n    // Key supplied by owner. Used by record to identify attribute key.\r\n    // Only collections doesn't set the key, which is used to distinguish collections.\r\n    /** @internal */ \r\n    _ownerKey : string = void 0;\r\n\r\n    // Name of the change event\r\n    /** @internal */\r\n    _changeEventName : string\r\n\r\n    /**\r\n     * Subsribe for the changes.\r\n     */\r\n    onChanges( handler : Function, target? : Messenger ){\r\n        on( this, this._changeEventName, handler, target );\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from changes.\r\n     */\r\n    offChanges( handler? : Function, target? : Messenger ){\r\n        off( this, this._changeEventName, handler, target );\r\n    }\r\n\r\n    /**\r\n     * Listen to changes event. \r\n     */\r\n    listenToChanges( target : Transactional, handler ){\r\n        this.listenTo( target, target._changeEventName, handler );\r\n    }\r\n\r\n    constructor( cid : string | number ){\r\n        this.cid = this.cidPrefix + cid;\r\n    }\r\n\r\n    // Deeply clone ownership subtree\r\n    abstract clone( options? : CloneOptions ) : this\r\n    \r\n    // Execute given function in the scope of ad-hoc transaction.\r\n    transaction( fun : ( self : this ) => void, options : TransactionOptions = {} ) : void{\r\n        const isRoot = transactionApi.begin( this );\r\n        const update = fun.call( this, this );\r\n        update && this.set( update );\r\n        isRoot && transactionApi.commit( this );\r\n    }\r\n\r\n    // Assign transactional object \"by value\", copying aggregated items.\r\n    assignFrom( a_source : Transactional | Object | Linked<Transactional> ) : this {\r\n        // Unpack linked value.\r\n        const source = a_source instanceof Linked ? a_source.value : a_source;\r\n\r\n        // Need to delay change events until change token will by synced.\r\n        this.transaction( () =>{\r\n            this.set( ( source as any).__inner_state__ || source, { merge : true } );\r\n\r\n            // Synchronize change tokens\r\n            const { _changeToken } = source as any;\r\n    \r\n            if( _changeToken ){\r\n                this._changeToken = _changeToken;\r\n            }    \r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    // Create object from JSON. Throw if validation fail.\r\n    static from<T extends new ( a?, b? ) => Transactional >( this : T, json : any, { strict, ...options }  : { strict? : boolean } & TransactionOptions = {} ) :  InstanceType<T>{\r\n        const obj : Transactional = ( this as any ).create( json, { ...options, logger : strict ? throwingLogger : void 0 } );\r\n\r\n        if( strict && obj.validationError ){\r\n            obj.eachValidationError( ( error, key, obj ) => {\r\n                throw new Error( `${ obj.getClassName() }.${ key }: ${ error }` );\r\n            });\r\n        }\r\n\r\n        return obj as any;\r\n    }\r\n\r\n    // Apply bulk object update without any notifications, and return open transaction.\r\n    // Used internally to implement two-phase commit.\r\n    // Returns null if there are no any changes.\r\n    /** @internal */\r\n    abstract _createTransaction( values : any, options? : TransactionOptions ) : Transaction | void\r\n\r\n    // Apply bulk in-place object update in scope of ad-hoc transaction \r\n    abstract set( values : any, options? : TransactionOptions ) : this;\r\n\r\n    \r\n    // Parse function applied when 'parse' option is set for transaction.\r\n    parse( data : any, options? : TransactionOptions ) : any { return data }\r\n\r\n    // Convert object to the serializable JSON structure\r\n    abstract toJSON( options? : object ) : {}\r\n\r\n    /*******************\r\n     * Traversals and member access\r\n     */\r\n    \r\n    // Get object member by its key.\r\n    abstract get( key : string ) : any\r\n\r\n    // Get object member by symbolic reference.\r\n    deepGet( reference : string ) : any {\r\n        return resolveReference( this, reference, ( object, key ) => object.get ? object.get( key ) : object[ key ] );\r\n    }\r\n\r\n    //_isCollection : boolean\r\n\r\n    // Return owner skipping collections.\r\n    getOwner() : Owner {\r\n        return this._owner;\r\n    }\r\n\r\n    // Store used when owner chain store lookup failed. Static value in the prototype. \r\n    /** @internal */\r\n    _defaultStore : Transactional\r\n\r\n    // Locate the closest store. Store object stops traversal by overriding this method. \r\n    getStore() : Transactional {\r\n        const { _owner } = this;\r\n        return _owner ? <Transactional> _owner.getStore() : this._defaultStore;\r\n    }\r\n\r\n\r\n    /***************************************************\r\n     * Iteration API\r\n     */\r\n\r\n    // Loop through the members. Must be efficiently implemented in container class.\r\n\r\n    /** @internal */\r\n    _endpoint : IOEndpoint\r\n    \r\n    /** @internal */\r\n    _ioPromise : IOPromise<this>\r\n\r\n    hasPendingIO() : IOPromise<this> { return this._ioPromise; }\r\n\r\n    //fetch( options? : object ) : IOPromise<this> { throw new Error( \"Not implemented\" ); }\r\n\r\n    getEndpoint() : IOEndpoint {\r\n        return getOwnerEndpoint( this ) || this._endpoint;\r\n    }\r\n    \r\n    /*********************************\r\n     * Validation API\r\n     */\r\n\r\n    // Lazily evaluated validation error\r\n    /** @internal */\r\n    _validationError : ValidationError = void 0\r\n\r\n    // Validate ownership tree and return valudation error \r\n    get validationError() : ValidationError {\r\n        const error = this._validationError || ( this._validationError = new ValidationError( this ) );\r\n        return error.length ? error : null; \r\n    }\r\n\r\n    // Validate nested members. Returns errors count.\r\n    /** @internal */\r\n    abstract _validateNested( errors : ChildrenErrors ) : number\r\n\r\n    // Object-level validator. Returns validation error.\r\n    validate( obj? : Transactional ) : any {}\r\n\r\n    // Return validation error (or undefined) for nested object with the given key. \r\n    getValidationError( key? : string ) : any {\r\n        var error = this.validationError;\r\n        return ( key ? error && error.nested[ key ] : error ) || null;\r\n    }\r\n\r\n    // Get validation error for the given symbolic reference.\r\n    deepValidationError( reference : string ) : any {\r\n        return resolveReference( this, reference, ( object, key ) => object.getValidationError( key ) );\r\n    }\r\n\r\n    // Iterate through all validation errors across the ownership tree.\r\n    eachValidationError( iteratee : ( error : any, key : string, object : Transactional ) => void ) : void {\r\n        const { validationError } = this;\r\n        validationError && validationError.eachError( iteratee, this );\r\n    }\r\n\r\n    // Check whenever member with a given key is valid. \r\n    isValid( key? : string ) : boolean {\r\n        return !this.getValidationError( key );\r\n    }\r\n\r\n    valueOf() : Object { return this.cid; }\r\n    toString(){ return this.cid; }\r\n\r\n    // Get class name for an object instance. Works fine with ES6 classes definitions (not in IE).\r\n    getClassName() : string {\r\n        const { name } = <any>this.constructor;\r\n        if( name !== 'Subclass' ) return name;\r\n    }\r\n\r\n    // Logging interface for run time errors and warnings.\r\n    /** @internal */\r\n    abstract _log( level : LogLevel, topic : string, text : string, value : any, logger? : Logger ) : void\r\n}\r\n\r\nexport interface CloneOptions {\r\n    // 'Pin store' shall assign this._defaultStore = this.getStore();\r\n    pinStore? : boolean\r\n}\r\n\r\n// Owner must accept children update events. It's an only way children communicates with an owner.\r\n/** @private */\r\nexport interface Owner extends Traversable, Messenger {\r\n    /** @internal */\r\n    _onChildrenChange( child : Transactional, options : TransactionOptions ) : void;\r\n    \r\n    getOwner() : Owner\r\n    getStore() : Transactional\r\n}\r\n\r\n// Transaction object used for two-phase commit protocol.\r\n// Must be implemented by subclasses.\r\n// Transaction must be created if there are actual changes and when markIsDirty returns true.\r\n/** @private */ \r\nexport interface Transaction {\r\n    // Object transaction is being made on.\r\n    object : Transactional\r\n\r\n    // Send out change events, process update triggers, and close transaction.\r\n    // Nested transactions must be marked with isNested flag (it suppress owner notification).\r\n    commit( initiator? : Transactional )\r\n}\r\n\r\n// Options for distributed transaction  \r\nexport interface TransactionOptions {\r\n    // Invoke parsing \r\n    parse? : boolean\r\n\r\n    // Optional logger\r\n    logger? : Logger\r\n\r\n    // Suppress change notifications and update triggers\r\n    silent? : boolean\r\n\r\n    // Update existing transactional members in place, or skip the update (ignored by models)\r\n    merge? : boolean // =true\r\n\r\n    // Should collections remove elements in set (ignored by models)  \r\n    remove? : boolean // =true\r\n\r\n    // Always replace enclosed objects with new instances\r\n    reset? : boolean // = false\r\n\r\n    // Do not dispose aggregated members\r\n    unset? : boolean\r\n\r\n    validate? : boolean\r\n\r\n    // IO method name if the transaction is initiated as a result of IO operation\r\n    ioMethod? : 'save' | 'fetch'\r\n\r\n    // The hint for IOEndpoint\r\n    // If `true`, `record.save()` will behave as \"upsert\" operation for the records having id.\r\n    upsert? : boolean\r\n}\r\n\r\n/**\r\n * Low-level transactions API. Must be used like this:\r\n * const isRoot = begin( record );\r\n * ...\r\n * isRoot && commit( record, options );\r\n * \r\n * When committing nested transaction, the flag must be set to true. \r\n * commit( object, options, isNested ) \r\n */\r\n\r\nexport const transactionApi = {\r\n    // Start transaction. Return true if it's the root one.\r\n    /** @private */\r\n    begin( object : Transactional ) : boolean {\r\n        return object._transaction ? false : ( object._transaction = true );  \r\n    },\r\n\r\n    // Mark object having changes inside of the current transaction.\r\n    // Returns true whenever there notifications are required.\r\n    /** @private */\r\n    markAsDirty( object : Transactional, options : TransactionOptions ) : boolean {\r\n        // If silent option is in effect, don't set isDirty flag.\r\n        const dirty = !options.silent;\r\n        if( dirty ) object._isDirty = options;\r\n        \r\n        // Reset version token.\r\n        object._changeToken = {};\r\n\r\n        // Object is changed, so validation must happen again. Clear the cache.\r\n        object._validationError = void 0;\r\n\r\n        return dirty;\r\n    },\r\n\r\n    // Commit transaction. Send out change event and notify owner. Returns true if there were changes.\r\n    // Must be executed for the root transaction only.\r\n    /** @private */\r\n    commit( object : Transactional, initiator? : Transactional ){\r\n        let originalOptions = object._isDirty;\r\n\r\n        if( originalOptions ){\r\n            // Send the sequence of change events, handling chained handlers.\r\n            while( object._isDirty ){\r\n                const options = object._isDirty;\r\n                object._isDirty = null; \r\n                trigger3( object, object._changeEventName, object, options, initiator );\r\n            }\r\n            \r\n            // Mark transaction as closed.\r\n            object._transaction = false;\r\n\r\n            // Notify owner on changes out of transaction scope.  \r\n            const { _owner } = object;  \r\n            if( _owner && _owner !== <any> initiator ){ // If it's the nested transaction, owner is already aware there are some changes.\r\n                _owner._onChildrenChange( object, originalOptions );\r\n            }\r\n        }\r\n        else{\r\n            // No changes. Silently close transaction.\r\n            object._isDirty = null;\r\n            object._transaction = false;\r\n        }\r\n    },\r\n\r\n    /************************************\r\n     * Ownership management\r\n     */\r\n\r\n    // Add reference to the record.\r\n    /** @private */\r\n    aquire( owner : Owner, child : Transactional, key? : string ) : void {\r\n        if( child._owner ) throw new ReferenceError( 'Trying to aquire ownership for an object already having an owner' );\r\n\r\n        child._owner = owner;\r\n        child._ownerKey = key;\r\n    },\r\n\r\n    // Remove reference to the record.\r\n    /** @private */\r\n    free( owner : Owner, child : Transactional ) : void {\r\n        if( owner === child._owner ){\r\n            child._owner = void 0;\r\n            child._ownerKey = void 0;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getOwnerEndpoint( self : Transactional ) : IOEndpoint {\r\n    // Check if we are the member of the collection...\r\n    const { collection } = self as any;\r\n    if( collection ){\r\n        return getOwnerEndpoint( collection );\r\n    }\r\n\r\n    // Now, if we're the member of the model...\r\n    if( self._owner ){\r\n        const { _endpoints } = self._owner as any;\r\n        return _endpoints && _endpoints[ self._ownerKey ];\r\n    }\r\n}\r\n","import { eventsApi } from '@type-r/mixture';\r\nimport { Owner, Transaction, Transactional, transactionApi, TransactionOptions } from \"../transactions\";\r\nconst { begin : _begin, markAsDirty : _markAsDirty, commit } = transactionApi;\r\n\r\nconst { trigger3 } = eventsApi;\r\n\r\nexport interface ConstructorsMixin {\r\n    Attributes : AttributesConstructor\r\n    AttributesCopy : AttributesCopyConstructor\r\n}\r\n\r\nexport interface ConstructorOptions extends TransactionOptions{\r\n    clone? : boolean\r\n}\r\n\r\nexport type AttributesConstructor = new ( record : AttributesContainer, values : object, options : TransactionOptions ) => AttributesValues;\r\nexport type AttributesCopyConstructor = new ( values : object ) => AttributesValues;\r\n\r\nexport interface AttributesContainer extends Transactional, Owner, ConstructorsMixin {\r\n    // Attribute descriptors.\r\n    /** @internal */\r\n    _attributes : AttributesDescriptors\r\n\r\n    // Attribute values.\r\n    attributes : AttributesValues\r\n\r\n    // Previous attribute values.\r\n    /** @internal */\r\n    _previousAttributes : AttributesValues\r\n\r\n    // Changed attributes cache. \r\n    /** @internal */\r\n    _changedAttributes : AttributesValues\r\n}\r\n\r\nexport interface AttributesValues {\r\n    [ name : string ] : any\r\n}\r\n\r\nexport interface AttributesDescriptors {\r\n    [ name : string ] : AttributeUpdatePipeline\r\n}\r\n\r\nexport interface AttributeUpdatePipeline{\r\n    doUpdate( value, record : AttributesContainer, options : TransactionOptions, nested? : Transaction[] ) : boolean\r\n}\r\n\r\n // Optimized single attribute transactional update. To be called from attributes setters\r\n // options.silent === false, parse === false. \r\nexport function setAttribute( record : AttributesContainer, name : string, value : any ) : void {\r\n    // Open the transaction.\r\n    const isRoot  = begin( record ),\r\n          options = {};\r\n\r\n    // Update attribute.      \r\n    if( record._attributes[ name ].doUpdate( value, record, options ) ){\r\n        // Notify listeners on changes.\r\n        markAsDirty( record, options );\r\n        trigger3( record, 'change:' + name, record, record.attributes[ name ], options );\r\n    }\r\n\r\n    // Close the transaction.\r\n    isRoot && commit( record );\r\n}\r\n\r\nfunction begin( record : AttributesContainer ){\r\n    if( _begin( record ) ){\r\n        record._previousAttributes = new record.AttributesCopy( record.attributes );\r\n        record._changedAttributes = null;\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nfunction markAsDirty( record : AttributesContainer, options : TransactionOptions ){\r\n    // Need to recalculate changed attributes, when we have nested set in change:attr handler\r\n    if( record._changedAttributes ){\r\n        record._changedAttributes = null;\r\n    }\r\n\r\n    return _markAsDirty( record, options );\r\n}\r\n\r\n/**\r\n * TODO: There's an opportunity to create an optimized pipeline for primitive types and Date, which makes the majority\r\n * of attributes. It might create the major speedup.\r\n * \r\n * Create the dedicated pipeline for owned and shared attributes as well.\r\n * \r\n * Three elements of the pipeline:\r\n * - from constructor\r\n * - from assignment\r\n * - from `set`\r\n */\r\n\r\nexport const UpdateModelMixin = {\r\n// Need to override it here, since begin/end transaction brackets are overriden. \r\n    transaction( this : AttributesContainer, fun : ( self : AttributesContainer ) => void, options : TransactionOptions = {} ) : void{\r\n        const isRoot = begin( this );\r\n        fun.call( this, this );\r\n        isRoot && commit( this );\r\n    },\r\n            \r\n    // Handle nested changes. TODO: propagateChanges == false, same in transaction.\r\n    _onChildrenChange( child : Transactional, options : TransactionOptions ) : void {\r\n        const { _ownerKey } = child,\r\n              attribute = this._attributes[ _ownerKey ];\r\n\r\n        if( !attribute /* TODO: Must be an opposite, likely the bug */ || attribute.propagateChanges ) this.forceAttributeChange( _ownerKey, options );\r\n    },\r\n\r\n    // Simulate attribute change \r\n    forceAttributeChange( key : string, options : TransactionOptions = {} ){\r\n        // Touch an attribute in bounds of transaction\r\n        const isRoot = begin( this );\r\n\r\n        if( markAsDirty( this, options ) ){\r\n            trigger3( this, 'change:' + key, this, this.attributes[ key ], options );\r\n        }\r\n        \r\n        isRoot && commit( this );\r\n    },\r\n\r\n    _createTransaction( this : AttributesContainer, a_values : {}, options : TransactionOptions = {} ) : Transaction {\r\n        const isRoot = begin( this ),\r\n                changes : string[] = [],\r\n                nested : ModelTransaction[]= [],\r\n                { _attributes } = this,\r\n                values = options.parse ? this.parse( a_values, options ) : a_values;\r\n\r\n        let unknown;\r\n\r\n        if( shouldBeAnObject( this, values, options ) ){\r\n            for( let name in values ){\r\n                const spec = _attributes[ name ];\r\n\r\n                if( spec ){\r\n                    if( spec.doUpdate( values[ name ], this, options, nested ) ){\r\n                        changes.push( name );\r\n                    }\r\n                }\r\n                else{\r\n                    unknown || ( unknown = [] );\r\n                    unknown.push( `'${ name }'` );\r\n                }\r\n            }\r\n\r\n            if( unknown ){\r\n                unknownAttrsWarning( this, unknown, { values }, options );\r\n            }\r\n        }\r\n        \r\n        if( changes.length && markAsDirty( this, options ) ){\r\n            return new ModelTransaction( this, isRoot, nested, changes );\r\n        }\r\n        \r\n        // No changes, but there might be silent attributes with open transactions.\r\n        for( let pendingTransaction of nested ){\r\n            pendingTransaction.commit( this );\r\n        }\r\n\r\n        isRoot && commit( this );\r\n    }\r\n};\r\n\r\nexport function unknownAttrsWarning( record : AttributesContainer, unknown : string[], props, options ){\r\n    record._log( 'warn', 'Type-R:UnknownAttrs', `undefined attributes ${ unknown.join(', ')} are ignored.`, props, options.logger );\r\n}\r\n\r\n// One of the main performance tricks of Type-R.\r\n// Create loop unrolled constructors for internal attribute hash,\r\n// so the hidden class JIT optimization will be engaged and they will become static structs.\r\n// It dramatically improves record performance.\r\nexport function constructorsMixin( attrDefs : AttributesDescriptors ) : ConstructorsMixin {\r\n    const attrs = Object.keys( attrDefs );\r\n\r\n    const AttributesCopy : AttributesCopyConstructor = new Function( 'values', `\r\n        ${ attrs.map( attr =>`\r\n            this.${ attr } = values.${ attr };\r\n        `).join( '' ) }\r\n    `) as any;\r\n\r\n    AttributesCopy.prototype = Object.prototype;\r\n\r\n    const Attributes : AttributesConstructor = new Function( 'record', 'values', 'options', `\r\n        var _attrs = record._attributes;\r\n\r\n        ${ attrs.map( attr =>`\r\n            this.${ attr } = _attrs.${ attr }.doInit( values.${ attr }, record, options );\r\n        `).join( '' ) }\r\n    `) as any;\r\n\r\n    Attributes.prototype = Object.prototype;\r\n\r\n    return { Attributes, AttributesCopy };\r\n}\r\n\r\nexport function shouldBeAnObject( record : AttributesContainer, values : object, options ){\r\n    if( values && values.constructor === Object ) return true;\r\n\r\n    record._log( 'error', 'Type-R:InvalidObject', 'update with non-object is ignored!', { values }, options.logger );\r\n    return false;\r\n}\r\n\r\n// Transaction class. Implements two-phase transactions on object's tree. \r\n// Transaction must be created if there are actual changes and when markIsDirty returns true. \r\nexport class ModelTransaction implements Transaction {\r\n    // open transaction\r\n    constructor( public object : AttributesContainer,\r\n                 public isRoot : boolean,\r\n                 public nested : Transaction[],\r\n                 public changes : string[] ){}\r\n\r\n    // commit transaction\r\n    commit( initiator? : AttributesContainer ) : void {\r\n        const { nested, object, changes } = this;\r\n\r\n        // Commit all pending nested transactions...\r\n        for( let transaction of nested ){ \r\n            transaction.commit( object );\r\n        }\r\n\r\n        // Notify listeners on attribute changes...\r\n        // Transaction is never created when silent option is set, so just send events out.\r\n        const { attributes, _isDirty } = object;\r\n        for( let key of changes ){\r\n            trigger3( object, 'change:' + key, object, attributes[ key ], _isDirty );\r\n        }\r\n\r\n        this.isRoot && commit( object, initiator );\r\n    }\r\n}","import { IOEndpoint } from '../../io-tools';\r\nimport { LogLevel, tools, Logger } from '@type-r/mixture';\r\nimport { TransactionOptions, Transactional } from '../../transactions';\r\nimport { AttributesContainer, AttributeUpdatePipeline, ModelTransaction, setAttribute } from '../updates';\r\n\r\nconst { notEqual, assign} = tools;\r\n\r\nexport type Transform = ( this : AnyType, next : any, prev : any, record : AttributesContainer, options : TransactionOptions ) => any;\r\nexport type ChangeHandler = ( this : AnyType, next : any, prev : any, record : AttributesContainer, options : TransactionOptions ) => void;\r\n\r\nexport interface AttributeOptions {\r\n    _metatype? : typeof AnyType\r\n    validate? : ( record : AttributesContainer, value : any, key : string ) => any\r\n    isRequired? : boolean\r\n    changeEvents? : boolean\r\n\r\n    endpoint? : IOEndpoint\r\n\r\n    type? : Function\r\n    value? : any\r\n    hasCustomDefault? : boolean\r\n\r\n    parse? : Parse\r\n    toJSON? : AttributeToJSON\r\n   \r\n    getHooks? : GetHook[]\r\n    transforms? : Transform[]\r\n    changeHandlers? : ChangeHandler[]\r\n\r\n    _onChange? : ChangeAttrHandler\r\n}\r\n\r\nexport type Parse = ( value : any, key? : string ) => any;\r\nexport type GetHook = ( value : any, key? : string ) => any;\r\nexport type AttributeToJSON = ( value : any, key? : string ) => any\r\nexport type AttributeParse = ( value : any, key? : string ) => any\r\nexport type ChangeAttrHandler = ( ( value : any, attr? : string ) => void ) | string;\r\n\r\n// TODO: interface differs from options, do something obout it\r\nconst emptyOptions : TransactionOptions = {};\r\n\r\n/**\r\n * Typeless attribute. Is the base class for all other attributes.\r\n */\r\nexport class AnyType implements AttributeUpdatePipeline {\r\n    // Factory method to create attribute from options \r\n    static create : ( options : AttributeOptions, name : string ) => AnyType;\r\n    \r\n    /**\r\n     * Update pipeline functions\r\n     * =========================\r\n     *\r\n     * Stage 0. canBeUpdated( value )\r\n     * - presence of this function implies attribute's ability to update in place.\r\n     */\r\n    canBeUpdated( prev, next, options : TransactionOptions ) : any {}\r\n\r\n    /**\r\n     * Stage 1. Transform stage\r\n     */\r\n    transform( next : any, prev : any, model : AttributesContainer, options : TransactionOptions ) : any { return next; }\r\n\r\n    // convert attribute type to `this.type`.\r\n    convert( next : any, prev : any, model : AttributesContainer, options : TransactionOptions ) : any { return next; }\r\n\r\n    /**\r\n     * Stage 2. Check if attr value is changed\r\n     */\r\n    isChanged( a : any, b : any ) : boolean {\r\n        return notEqual( a, b );\r\n    }\r\n\r\n    /**\r\n     * Stage 3. Handle attribute change\r\n     */\r\n    handleChange( next : any, prev : any, model : AttributesContainer, options : TransactionOptions ) {}\r\n\r\n    /**\r\n     * End update pipeline definitions.\r\n     */\r\n\r\n    // create empty object passing backbone options to constructor...\r\n    create() { return void 0; }\r\n\r\n    // generic clone function for typeless attributes\r\n    // Must be overriden in sublass\r\n    clone( value : any, record : AttributesContainer ) {\r\n        return value;\r\n    }\r\n\r\n    dispose( record : AttributesContainer, value : any ) : void {\r\n        this.handleChange( void 0, value, record, emptyOptions );\r\n    }\r\n\r\n    validate( record : AttributesContainer, value : any, key : string ) : any {}\r\n\r\n    toJSON( value, key, options? : object ) {\r\n        return value && value.toJSON ? value.toJSON( options ) : value;\r\n    }\r\n\r\n    isMutableType(){\r\n        return this.type && this.type.prototype instanceof Transactional;\r\n    }\r\n\r\n    createPropertyDescriptor() : PropertyDescriptor | void {\r\n        const { name, getHook } = this;\r\n\r\n        if( name !== 'id' ){\r\n            return {\r\n                // call to optimized set function for single argument.\r\n                set( value ){\r\n                    setAttribute( this, name, value );\r\n                },\r\n\r\n                // attach get hook to the getter function, if it present\r\n                get : (\r\n                    getHook ?\r\n                        function() {\r\n                            return getHook.call( this, this.attributes[ name ], name );\r\n                        } :\r\n                        function() { return this.attributes[ name ]; }\r\n                ),\r\n\r\n                configurable : true\r\n            }\r\n        }\r\n    }\r\n\r\n    value : any\r\n\r\n    // Used as global default value for the given metatype\r\n    static defaultValue : any;\r\n\r\n    type : Function\r\n\r\n    initialize( name : string, options : TransactionOptions ){}\r\n\r\n    options : AttributeOptions\r\n\r\n    doInit( value, record : AttributesContainer, options : TransactionOptions ){\r\n        const v = value === void 0 ? this.defaultValue() : value,\r\n            x = this.transform( v, void 0, record, options );\r\n            \r\n        this.handleChange( x, void 0, record, options );\r\n        return x;\r\n    }\r\n\r\n    doUpdate( value, record : AttributesContainer, options : TransactionOptions, nested? : ModelTransaction[] ){\r\n        const { name } = this,\r\n            { attributes } = record,\r\n              prev = attributes[ name ];\r\n\r\n        const next = this.transform( value, prev, record, options );\r\n        attributes[ name ] = next;\r\n\r\n        if( this.isChanged( next, prev ) ) {\r\n            // Do the rest of the job after assignment\r\n            this.handleChange( next, prev, record, options );\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    propagateChanges : boolean\r\n\r\n    protected _log( level : LogLevel, code : string, text : string, value, record : AttributesContainer, logger : Logger ){\r\n        record._log( level, code, `${record.getClassName()}.${ this.name } ${ text }`, {\r\n            'New value' : value,\r\n            'Prev. value' : record.attributes[ this.name ]\r\n        }, logger );\r\n    }\r\n\r\n    defaultValue(){\r\n        return this.value;\r\n    }\r\n\r\n    constructor( public name : string, a_options : AttributeOptions ) {        \r\n        // Save original options...\r\n        this.options = a_options;\r\n\r\n        // Clone options.\r\n        const options : AttributeOptions = { getHooks : [], transforms : [], changeHandlers : [], ...a_options };\r\n        options.getHooks = options.getHooks.slice();\r\n        options.transforms = options.transforms.slice();\r\n        options.changeHandlers = options.changeHandlers.slice();\r\n\r\n        const {\r\n                  value, type, parse, toJSON, changeEvents,\r\n                  validate, getHooks, transforms, changeHandlers\r\n              } = options;\r\n\r\n        // Initialize default value...\r\n        this.value = value;\r\n        this.type  = type;\r\n\r\n        // TODO: An opportunity to optimize for attribute subtype.\r\n        if( !options.hasCustomDefault && type ){\r\n            this.defaultValue = this.create;\r\n        }\r\n        else if( tools.isValidJSON( value ) ){ \r\n            // JSON literals must be deep copied.\r\n            this.defaultValue = new Function( `return ${ JSON.stringify( value ) };` ) as any;\r\n        }\r\n        else{\r\n            this.defaultValue = this.defaultValue;\r\n        }\r\n\r\n        // Changes must be bubbled when they are not disabled for an attribute and transactional object.\r\n        this.propagateChanges = changeEvents !== false;\r\n\r\n        this.toJSON = toJSON === void 0 ? this.toJSON : toJSON;\r\n\r\n        this.validate = validate || this.validate;\r\n        \r\n        if( options.isRequired ){\r\n            this.validate = wrapIsRequired( this.validate );\r\n        }\r\n\r\n        /**\r\n         * Assemble pipelines...\r\n         */\r\n\r\n        // `convert` is default transform, which is always present...\r\n        transforms.unshift( this.convert );\r\n\r\n        // Get hook from the attribute will be used first...\r\n        if( this.get ) getHooks.unshift( this.get );\r\n\r\n        // let subclasses configure the pipeline...\r\n        this.initialize.call( this, options );\r\n\r\n        // let attribute spec configure the pipeline...\r\n        if( getHooks.length ){\r\n            const getHook = this.getHook = getHooks.reduce( chainGetHooks );\r\n\r\n            const { validate } = this;\r\n            this.validate = function( record : AttributesContainer, value : any, key : string ){\r\n                return validate.call( this, record, getHook.call( record, value, key ), key );\r\n            }\r\n        }\r\n        \r\n        this.transform = transforms.length ? transforms.reduce( chainTransforms ) : this.transform;\r\n        \r\n        this.handleChange = changeHandlers.length ? changeHandlers.reduce( chainChangeHandlers ) : this.handleChange;\r\n\r\n        // Attribute-level parse transform are attached as update hooks modifiers...\r\n        const { doInit, doUpdate } = this;\r\n        this.doInit = parse ? function( value, record : AttributesContainer, options : TransactionOptions ){\r\n            return doInit.call( this, options.parse && value !== void 0 ? parse.call( record, value, this.name ) : value, record, options );\r\n        } : doInit;\r\n\r\n        this.doUpdate = parse ? function( value, record : AttributesContainer, options : TransactionOptions, nested? : ModelTransaction[] ){\r\n            return doUpdate.call( this, options.parse && value !== void 0 ? parse.call( record, value, this.name ) : value, record, options, nested );\r\n        } : doUpdate;\r\n    }\r\n\r\n    getHook : ( value, key : string ) => any = null\r\n    get : ( value, key : string ) => any\r\n}\r\n\r\n\r\nfunction chainGetHooks( prevHook : GetHook, nextHook : GetHook ) : GetHook {\r\n    return function( value, name ) {\r\n        return nextHook.call( this, prevHook.call( this, value, name ), name );\r\n    }\r\n}\r\n\r\nfunction chainTransforms( prevTransform : Transform, nextTransform : Transform ) : Transform {\r\n    return function( next, prev, record, options ) {\r\n        return nextTransform.call( this, prevTransform.call( this, next, prev, record, options ), prev, record, options );\r\n    }\r\n}\r\n\r\nfunction chainChangeHandlers( prevHandler : ChangeHandler, nextHandler : ChangeHandler ) : ChangeHandler {\r\n    return function( next, prev, record, options ) {\r\n        prevHandler.call( this, next, prev, record, options );\r\n        nextHandler.call( this, next, prev, record, options );\r\n    }\r\n}\r\n\r\nfunction wrapIsRequired( validate ){\r\n    return function( record : AttributesContainer, value : any, key : string ){\r\n        return value ? validate.call( this, record, value, key ) : 'Required';\r\n    }\r\n}","/**\r\n * Built-in JSON types attributes: Object, Array, Number, String, Boolean, and immutable class.\r\n * \r\n * Adds type assertions, default validation, and optimized update pipeline.\r\n */\r\n\r\nimport { TransactionOptions } from '../../transactions';\r\nimport { AnyType } from './any';\r\nimport { AttributesContainer } from '../updates';\r\n\r\n/**\r\n * Custom class must be immutable class which implements toJSON() method\r\n * with a constructor taking json.\r\n */\r\nexport class ImmutableClassType extends AnyType {\r\n    type : new ( value? : any ) => {}\r\n\r\n    create(){\r\n        return new this.type();\r\n    }\r\n\r\n    convert( next : any ) : any {\r\n        return next == null || next instanceof this.type ? next : new this.type( next );\r\n    }\r\n\r\n    toJSON( value, key? : string, options? : object ){\r\n        return value && value.toJSON ? value.toJSON( options ) : value;\r\n    }\r\n\r\n    clone( value ) {\r\n        return new this.type( this.toJSON( value ) );\r\n    }\r\n\r\n    isChanged( a, b ){\r\n        return a !== b;\r\n    }\r\n}\r\n\r\n/**\r\n * Optimized attribute of primitive type.\r\n * \r\n * Primitives has specialized simplified pipeline.\r\n */\r\nexport class PrimitiveType extends AnyType {\r\n    type : NumberConstructor | StringConstructor | BooleanConstructor\r\n\r\n    dispose(){}\r\n    create() { return this.type(); }\r\n\r\n    toJSON( value ) { return value; }\r\n\r\n    convert( next ) { return next == null ? next : this.type( next ); }\r\n\r\n    isChanged( a, b ) { return a !== b; }\r\n\r\n    clone( value ) { return value; }\r\n\r\n    doInit( value, record : AttributesContainer, options : TransactionOptions ){\r\n        return this.transform( value === void 0 ? this.value : value, void 0, record, options );\r\n    }\r\n\r\n    doUpdate( value, record, options, nested ){\r\n        const   { name } = this,\r\n                { attributes } = record,\r\n                prev = attributes[ name ];\r\n        \r\n        return prev !== ( attributes[ name ] = this.transform( value, prev, record, options ) );\r\n    }\r\n\r\n    initialize(){\r\n        if( !this.options.hasCustomDefault ){\r\n            this.value = this.type();\r\n        }\r\n    }\r\n}\r\n\r\n// Number type with special validation algothim.\r\n/** @private */ \r\nexport class NumericType extends PrimitiveType {\r\n    type : NumberConstructor\r\n\r\n    create(){\r\n        return 0;\r\n    }\r\n\r\n    convert( next, prev?, record?, options? ) {\r\n        const num = next == null ? next : this.type( next );\r\n\r\n        if( num !== num ){\r\n            this._log( 'error', 'Type-R:InvalidNumber', 'Number attribute is assigned with an invalid number', next, record, options.logger );\r\n        }\r\n        \r\n        return num;\r\n    }\r\n\r\n    validate( model, value, name ) {\r\n        // Whatever is not symmetrically serializable to JSON, is not valid by default.\r\n        if( value != null && !isFinite( value ) ) {\r\n            return name + ' is not valid number';\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Compatibility wrapper for Array type.\r\n * @private\r\n */ \r\nexport class ArrayType extends AnyType {\r\n    toJSON( value ) { return value; }\r\n    dispose(){}\r\n    create(){ return []; }\r\n\r\n    convert( next, prev, record, options ) {\r\n        // Fix incompatible constructor behaviour of Array...\r\n        if( next == null || Array.isArray( next ) ) return next;\r\n\r\n        this._log( 'error', 'Type-R:InvalidArray', 'Array attribute assigned with non-array value', next, record, options.logger );\r\n\r\n        return [];\r\n    }\r\n\r\n    clone( value ){\r\n        return value && value.slice();\r\n    }\r\n}\r\n\r\nexport class ObjectType extends AnyType {\r\n    create(){ return {}; }\r\n\r\n    convert( next, prev, record, options ) {\r\n        if( next == null || typeof next === 'object' ) return next;\r\n                \r\n        this._log( 'error', 'Type-R:InvalidObject', 'Object attribute is assigned with non-object value', next, record, options.logger );\r\n        return {};\r\n    }\r\n}\r\n\r\nexport function doNothing(){}\r\n\r\nexport class FunctionType extends AnyType {\r\n    // Functions are not serialized.\r\n    toJSON( value ) { return void 0; }\r\n    create(){ return doNothing; }\r\n    dispose(){}\r\n\r\n    convert( next, prev, record, options ) {\r\n        // Fix incompatible constructor behaviour of Function...\r\n        if( next == null || typeof next === 'function' ) return next;\r\n\r\n        this._log( 'error', 'Type-R:InvalidFunction', 'Function attribute assigned with non-function value', next, record, options.logger );\r\n\r\n        return doNothing;\r\n    }\r\n\r\n    // Functions are not cloned.\r\n    clone( value ){ return value; }\r\n}\r\n","/**\r\n * Date attribute type.\r\n * \r\n * Implements validation, cross-browser compatibility fixes, variety of Date serialization formats,\r\n * and optimized update pipeline.\r\n */\r\nimport { TransactionOptions } from '../../transactions';\r\nimport { AnyType } from './any';\r\nimport { AttributesContainer } from '../updates';\r\n\r\n// Date Attribute\r\n/** @private */\r\nexport class DateType extends AnyType {\r\n    create(){\r\n        return new Date();\r\n    }\r\n    \r\n    convert( next : any, a, record, options ){\r\n        if( next == null || next instanceof Date ) return next;\r\n\r\n        const date = new Date( next ),\r\n              timestamp = date.getTime();\r\n\r\n        if( timestamp !== timestamp ){\r\n            this._log( 'error', 'Type-R:InvalidDate', 'Date attribute assigned with invalid date', next, record, options.logger );\r\n        }\r\n\r\n        return date;\r\n    }\r\n\r\n    validate( model, value, name ) {\r\n        if( value != null ){\r\n            const timestamp = value.getTime(); \r\n            if( timestamp !== timestamp ) return name + ' is Invalid Date';\r\n        }\r\n    }\r\n\r\n    toJSON( value ) { return value && value.toISOString(); }\r\n\r\n    isChanged( a, b ) { return ( a && a.getTime() ) !== ( b && b.getTime() ); }\r\n\r\n    doInit( value, record : AttributesContainer, options : TransactionOptions ){\r\n        // Date don't have handleChanges step.\r\n        return this.transform( value === void 0 ? this.defaultValue() : value, void 0, record, options );\r\n    }\r\n\r\n    doUpdate( value, record, options, nested ){\r\n        const   { name } = this,\r\n                { attributes } = record,\r\n                prev = attributes[ name ];\r\n        \r\n        // Date don't have handleChanges step.\r\n        return this.isChanged( prev , attributes[ name ] = this.transform( value, prev, record, options ) );\r\n    }\r\n\r\n    clone( value ) { return value && new Date( value.getTime() ); }\r\n    dispose(){}\r\n}\r\n\r\n// If ISO date is not supported by date constructor (such as in Safari), polyfill it.\r\nfunction supportsDate( date ){\r\n    return !isNaN( ( new Date( date ) ).getTime() );\r\n}\r\n\r\nif( !supportsDate('2011-11-29T15:52:30.5') ||\r\n    !supportsDate('2011-11-29T15:52:30.52') ||\r\n    !supportsDate('2011-11-29T15:52:18.867') ||\r\n    !supportsDate('2011-11-29T15:52:18.867Z') ||\r\n    !supportsDate('2011-11-29T15:52:18.867-03:30') ){\r\n\r\n    DateType.prototype.convert = function( value ){\r\n        return value == null || value instanceof Date ? value : new Date( safeParseDate( value ) );\r\n    }\r\n}\r\n\r\nconst numericKeys    = [ 1, 4, 5, 6, 7, 10, 11 ],\r\n      isoDatePattern = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\r\n\r\nfunction safeParseDate( date : string ) : number {\r\n    var timestamp, struct : any[], minutesOffset = 0;\r\n\r\n    if( ( struct = isoDatePattern.exec( date )) ) {\r\n        // avoid NaN timestamps caused by undefined values being passed to Date.UTC\r\n        for( var i = 0, k; ( k = numericKeys[ i ] ); ++i ) {\r\n            struct[ k ] = +struct[ k ] || 0;\r\n        }\r\n\r\n        // allow undefined days and months\r\n        struct[ 2 ] = (+struct[ 2 ] || 1) - 1;\r\n        struct[ 3 ] = +struct[ 3 ] || 1;\r\n\r\n        if( struct[ 8 ] !== 'Z' && struct[ 9 ] !== undefined ) {\r\n            minutesOffset = struct[ 10 ] * 60 + struct[ 11 ];\r\n\r\n            if( struct[ 9 ] === '+' ) {\r\n                minutesOffset = 0 - minutesOffset;\r\n            }\r\n        }\r\n\r\n        timestamp =\r\n            Date.UTC( struct[ 1 ], struct[ 2 ], struct[ 3 ], struct[ 4 ], struct[ 5 ] + minutesOffset, struct[ 6 ],\r\n                    struct[ 7 ] );\r\n    }\r\n    else {\r\n        timestamp = Date.parse( date );\r\n    }\r\n\r\n    return timestamp;\r\n}","import { ItemsBehavior, Transactional, transactionApi, TransactionOptions } from '../../transactions';\r\nimport { ValidationError } from '../../validation';\r\nimport { AnyType } from './any';\r\nimport { AttributesContainer, ConstructorOptions } from '../updates';\r\n\r\nconst { free, aquire } = transactionApi;\r\n\r\nexport class AggregatedType extends AnyType {\r\n    type : typeof Transactional\r\n\r\n    clone( value : Transactional ) : Transactional {\r\n        return value ? value.clone() : value;\r\n    }\r\n\r\n    toJSON( x, key : string, options : object ){ return x && x.toJSON( options ); }\r\n\r\n    doInit( value, record : AttributesContainer, options : ConstructorOptions ){\r\n        const v = options.clone ? this.clone( value ) : (\r\n            value === void 0 ? this.defaultValue() : value\r\n        );\r\n\r\n        const x = this.transform( v, void 0, record, options );\r\n        this.handleChange( x, void 0, record, options );\r\n        return x;\r\n    }\r\n\r\n    doUpdate( value, record, options, nested : any[] ){ // Last to things can be wrapped to an object, either transaction or ad-hoc\r\n        const key = this.name, { attributes } = record; \r\n        const prev = attributes[ key ];\r\n        let update;\r\n\r\n        // This can be moved to transactional attribute. And chained with the rest.\r\n        if( update = this.canBeUpdated( prev, value, options ) ) { // todo - skip empty updates.\r\n            const nestedTransaction = prev._createTransaction( update, options );\r\n            // TODO: sync update tokens\r\n            if( nestedTransaction ){\r\n                if( nested ){\r\n                    nested.push( nestedTransaction );\r\n                }\r\n                else{\r\n                    nestedTransaction.commit( record );\r\n                }\r\n\r\n                if( this.propagateChanges ) return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        const next = this.transform( value, prev, record, options );\r\n        attributes[ key ] = next;\r\n\r\n        if( this.isChanged( next, prev ) ) { // Primitives and nested comparison can be inlined.\r\n            // Do the rest of the job after assignment\r\n            this.handleChange( next, prev, record, options );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    canBeUpdated( prev : Transactional, next : any, options : TransactionOptions ) : any {\r\n        // If an object already exists, and new value is of incompatible type, let object handle the update.\r\n        if( prev && next != null ){\r\n            if( next instanceof this.type ){\r\n                // In case if merge option explicitly specified, force merge.\r\n                if( options.merge ) return next.__inner_state__;\r\n            }\r\n            else{\r\n                return next;\r\n            }\r\n        }\r\n    }\r\n\r\n    convert( next : any, prev : any, record : AttributesContainer, options : TransactionOptions ) : Transactional {\r\n        // Invoke class factory to handle abstract classes\r\n        if( next == null ) return next;\r\n        \r\n        if( next instanceof this.type ){\r\n            if( next._shared && !( next._shared & ItemsBehavior.persistent ) ) { // TODO: think more about shared types assignment compatibility. \r\n                this._log( 'error', 'Type-R:InvalidCollection', 'aggregated collection attribute is assigned with shared collection type', next, record, options.logger );\r\n            }\r\n\r\n            // With explicit 'merge' option we need to clone an object if its previous value was 'null'.\r\n            // This is an only case we could be here when merge === true.\r\n            if( options.merge ) return next.clone();\r\n\r\n            if( next._owner ){\r\n                this._log( 'warn', 'Type-R:InvalidOwner', 'object alreay has an owner and was cloned. Use explicit object.clone() to dismiss this warning.', next, record, options.logger );\r\n                return next.clone();\r\n            }\r\n\r\n            return next;\r\n        }\r\n\r\n        return ( this.type as any).create( next, options );\r\n    }\r\n\r\n    dispose ( record : AttributesContainer, value : Transactional ){\r\n        if( value ){\r\n            this.handleChange( void 0, value, record, {} );\r\n        }\r\n    }\r\n\r\n    validate( record : AttributesContainer, value : Transactional ) : ValidationError {\r\n        var error = value && value.validationError;\r\n        if( error ) return error;\r\n    }\r\n\r\n    create() : Transactional {\r\n        return (<any>this.type).create(); // this the subclass of Transactional here.\r\n    }\r\n\r\n    initialize( options ){\r\n        options.changeHandlers.unshift( this._handleChange );\r\n    }\r\n\r\n    _handleChange( next : Transactional, prev : Transactional, record : AttributesContainer, options : TransactionOptions ){\r\n        if( prev ){\r\n            free( record, prev );\r\n            options.unset || prev.dispose();\r\n        } \r\n        \r\n        if( next ) aquire( record, next, this.name );\r\n    }\r\n}","import { eventsApi } from '@type-r/mixture';\r\nimport { ItemsBehavior, Transactional, transactionApi, TransactionOptions } from '../../transactions';\r\nimport { AnyType } from './any';\r\nimport { AttributesContainer, ConstructorOptions } from '../updates';\r\nimport { ChainableAttributeSpec } from '../attrDef';\r\n\r\nconst { on, off } = eventsApi,\r\n    { free, aquire } = transactionApi;\r\n\r\n/************************\r\n * Shared attribute definition.\r\n * - Not serialized.\r\n * - Listening to the changes.\r\n * - Doesn't take ownership when assigned with object of proper type.\r\n * - Takes ownership on objects which are converted.\r\n */\r\n\r\nconst shareAndListen = ItemsBehavior.listen | ItemsBehavior.share;\r\n\r\n/** @private */\r\nexport class SharedType extends AnyType {\r\n    type : typeof Transactional\r\n\r\n     doInit( value, record : AttributesContainer, options : ConstructorOptions ){\r\n        const v = options.clone ? this.clone( value, record ) : (\r\n            value === void 0 ? this.defaultValue() : value\r\n        );\r\n\r\n        const x = this.transform( v, void 0, record, options );\r\n        this.handleChange( x, void 0, record, options );\r\n        return x;\r\n    }\r\n\r\n    doUpdate( value, record, options, nested : any[] ){ // Last to things can be wrapped to an object, either transaction or ad-hoc\r\n        const key = this.name, { attributes } = record; \r\n        const prev = attributes[ key ];\r\n        let update;\r\n\r\n        // This can be moved to transactional attribute. And chained with the rest.\r\n        if( update = this.canBeUpdated( prev, value, options ) ) { // todo - skip empty updates.\r\n            const nestedTransaction = prev._createTransaction( update, options );\r\n            if( nestedTransaction ){\r\n                if( nested ){\r\n                    nested.push( nestedTransaction );\r\n                }\r\n                else{\r\n                    nestedTransaction.commit( record );\r\n                }\r\n\r\n                if( this.propagateChanges ) return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        const next = this.transform( value, prev, record, options );\r\n        attributes[ key ] = next;\r\n\r\n        if( this.isChanged( next, prev ) ) { // Primitives and nested comparison can be inlined.\r\n            // Do the rest of the job after assignment\r\n            this.handleChange( next, prev, record, options );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    clone( value : Transactional, record : AttributesContainer ) : Transactional {\r\n        // References are not cloned.\r\n        if( !value || value._owner !== record ) return value;\r\n\r\n        // Implicitly created objects are cloned.\r\n        const clone = value.clone();\r\n        aquire( record, clone, this.name );\r\n        return clone;\r\n    }\r\n\r\n    // Do not serialize by default.\r\n    toJSON(){}\r\n\r\n    canBeUpdated( prev : Transactional, next : any, options : TransactionOptions ) : any {\r\n        // If an object already exists, and new value is of incompatible type, let object handle the update.\r\n        if( prev && next != null && !( next instanceof this.type ) ){\r\n            return next;\r\n        }\r\n    }\r\n\r\n    convert( next : any, prev : any, record : AttributesContainer, options : TransactionOptions ) : Transactional {\r\n        if( next == null || next instanceof this.type ) return next;\r\n\r\n        // Convert type using implicitly created transactional object.\r\n        const implicitObject = new ( this.type as any )( next, options, shareAndListen );\r\n\r\n        // To prevent a leak, we need to take an ownership on it.\r\n        aquire( record, implicitObject, this.name );\r\n\r\n        return implicitObject;\r\n    }\r\n\r\n    // Refs are always valid.\r\n    validate( model, value, name ){}\r\n\r\n    // They are always created as null.\r\n    create() : Transactional {\r\n        return null;\r\n    }\r\n\r\n    // Listening to the change events\r\n    _handleChange( next : Transactional, prev : Transactional, record : AttributesContainer, options ){\r\n        if( prev ){\r\n            // If there was an implicitly created object, remove an ownership.\r\n            if( prev._owner === record ){\r\n                free( record, prev );\r\n                options.unset || prev.dispose();\r\n            }\r\n            else{\r\n                off( prev, prev._changeEventName, this._onChange, record );\r\n            }\r\n        }  \r\n \r\n        if( next ){\r\n            // No need to take an ownership for an implicit object - already done in convert or clone.\r\n            if( next._owner !== record ){\r\n                on( next, next._changeEventName, this._onChange, record );\r\n            }\r\n        } \r\n    }\r\n\r\n    dispose( record : AttributesContainer, value : Transactional ){\r\n        if( value ){\r\n            this.handleChange( void 0, value, record, {} );\r\n        }\r\n    }\r\n\r\n    _onChange : ( child : Transactional, options : TransactionOptions, initiator : Transactional ) => void \r\n\r\n    initialize( options ){\r\n        // Create change event handler which knows current attribute name. \r\n        const attribute = this;\r\n        this._onChange = this.propagateChanges ? function( child, options, initiator ){\r\n            this === initiator || this.forceAttributeChange( attribute.name, options );\r\n        } : ignore;\r\n\r\n        options.changeHandlers.unshift( this._handleChange );\r\n    }\r\n}\r\n\r\nfunction ignore(){}","import { PrimitiveType, NumericType, ObjectType, ImmutableClassType, FunctionType, ArrayType } from './basic';\r\nimport { DateType } from './date';\r\nimport { AnyType, AttributeOptions } from './any';\r\n\r\nexport * from './any';\r\nexport * from './basic';\r\nexport * from './date';\r\nexport * from './owned';\r\nexport * from './shared';\r\n\r\n/**\r\n * Every record attribute type has the corresponding metatype controlling its behavior.\r\n * For built-in types, Type-R uses the predefined list to resolve metatype in order to avoid global objects modifications.\r\n * For user-defined types, static `_metatype` constructor member is used.\r\n */\r\n\r\nconst builtins : Function[] = [ String, Number, Boolean, Date, Object, Array, Function ],\r\n      metatypes = [ PrimitiveType, NumericType, PrimitiveType, DateType, ObjectType, ArrayType, FunctionType ];\r\n\r\nexport function getMetatype( Ctor : Function ){\r\n    return ( Ctor as any )._metatype || resolveBuiltins( Ctor );\r\n}\r\n\r\nAnyType.create = ( options : AttributeOptions, name : string ) => {\r\n    const type = options.type,\r\n          AttributeCtor = options._metatype || ( type ? getMetatype( type ): AnyType );\r\n\r\n    return new AttributeCtor( name, options );\r\n}\r\n\r\nfunction resolveBuiltins( Ctor : Function ){\r\n    const idx = builtins.indexOf( Ctor );\r\n    return idx < 0 ? ImmutableClassType : metatypes[ idx ];\r\n}","/**\r\n * Type spec engine. Declare attributes using chainable syntax,\r\n * and returns object with spec.\r\n */\r\nimport { Linked } from '@linked/value';\r\nimport { definitionDecorator, EventMap, EventsDefinition, tools } from '@type-r/mixture';\r\nimport { Collection } from '../collection';\r\nimport { IOEndpoint } from '../io-tools';\r\nimport { Transactional } from '../transactions';\r\nimport { AttributeOptions, AttributeToJSON, getMetatype, Parse, SharedType } from './metatypes';\r\nimport { Model } from './model';\r\nimport { ModelAttributes } from './define'\r\nimport { AttributesContainer } from './updates';\r\n\r\nconst { assign } = tools;\r\n\r\nexport interface AttributeCheck {\r\n    ( value : any, key : string ) : boolean\r\n    error? : any\r\n}\r\n\r\n// Infer the proper TS type from a Type-R attribute spec.\r\nexport type Infer<A> =\r\n    A extends Function ? TrueReturnType<A> :\r\n    A extends ChainableAttributeSpec<infer F> ? TrueReturnType<F> :\r\n    A extends Array<infer T> ? (\r\n        T extends new (...args : any[]) => infer M ? (\r\n                M extends Model ? Collection<M> : never\r\n        ) :\r\n        T extends object ? Collection<Model & ModelAttributes<T>> :\r\n        T[]\r\n    ) :\r\n    A extends object ? Model & ModelAttributes<A> :\r\n    A;\r\n\r\n// Extract the proper TS return type for a function or constructor.\r\ntype TrueReturnType<F extends Function> =\r\n    F extends DateConstructor ? MaybeNull<F,Date> :\r\n    F extends typeof Linked ? Linked<any> :\r\n    F extends ( ...args : any[] ) => infer R ? MaybeNull<F,R> :\r\n    F extends new ( ...args : any[] ) => infer R ? MaybeNull<F,R>:\r\n    void;\r\n\r\ntype MaybeNull<F,R> = F extends { isNullable : true } ? R | null : R\r\nexport type Nullable<F> = F & { isNullable : true }\r\n\r\nexport class ChainableAttributeSpec<F extends Function>{\r\n    options : AttributeOptions & { type? : F };\r\n\r\n    constructor( options : AttributeOptions ) {\r\n        // Shallow copy options, fill it with defaults.\r\n        this.options = { getHooks : [], transforms : [], changeHandlers : []};\r\n        if( options ) assign( this.options, options );\r\n    }\r\n\r\n    check( check : AttributeCheck, error? : any ) : this {\r\n        function validate( model, value, name ){\r\n            if( !check.call( model, value, name ) ){\r\n                const msg = error || check.error || name + ' is not valid';\r\n                return typeof msg === 'function' ? msg.call( model, name ) : msg;\r\n            }\r\n        }\r\n\r\n        const prev = this.options.validate;\r\n\r\n        return this.metadata({\r\n            validate : prev ? (\r\n                            function( model, value, name ){\r\n                                return prev( model, value, name ) || validate( model, value, name );\r\n                            }\r\n                       ) : validate\r\n        });\r\n    }\r\n\r\n    get as() : PropertyDecorator {\r\n        return definitionDecorator( 'attributes', this );\r\n    }\r\n\r\n    /** @deprecated */\r\n    get isRequired() : this {\r\n        return this.required;\r\n    }\r\n\r\n    get required() : this {\r\n        return this.metadata({ isRequired : true }); \r\n    }\r\n\r\n    endpoint( endpoint : IOEndpoint ) : this {\r\n        return this.metadata({ endpoint });\r\n    }\r\n\r\n    /** @deprecated */\r\n    watcher( ref : string | ( ( value : any, key : string ) => void ) ) : this {\r\n        return this.metadata({ _onChange : ref });\r\n    }\r\n\r\n    /**\r\n     * Called when the attribute has changed its value.\r\n     */\r\n    onChange( handler : ( model : Model, value : Infer<F>, key : string ) => void ) : this {\r\n        return this.metadata({\r\n            _onChange( a_value : any, a_key : string ){\r\n                handler( this, a_value, a_key );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Attribute-specific parse transform\r\n    parse( fun : Parse ) : this {\r\n        return this.metadata({ parse : fun });\r\n    }\r\n\r\n    toJSON( fun : AttributeToJSON | false ) : this {\r\n        return this.metadata({\r\n            toJSON : typeof fun === 'function' ? fun : ( fun ? ( x, k, o ) => x && x.toJSON( o ) : emptyFunction ) \r\n        });\r\n    }\r\n\r\n    get dontSave(){\r\n        return this.toJSON( false );\r\n    }\r\n\r\n    get null() : ChainableAttributeSpec<Nullable<F>>{\r\n        return this.value( null ) as any;\r\n    }\r\n\r\n    // Attribute get hook.\r\n    get( fun ) : this {\r\n        return this.metadata({\r\n            getHooks : this.options.getHooks.concat( fun )\r\n        });\r\n    }\r\n\r\n    // Attribute set hook.\r\n    set( fun ) : this {\r\n        function handleSetHook( next, prev, record : AttributesContainer, options ) {\r\n            if( this.isChanged( next, prev ) ) {\r\n                const changed = fun.call( record, next, this.name );\r\n                return changed === void 0 ? prev : this.convert( changed, prev, record, options );\r\n            }\r\n\r\n            return prev;\r\n        }\r\n\r\n        return this.metadata({\r\n            transforms : this.options.transforms.concat( handleSetHook )\r\n        });\r\n    }\r\n\r\n    changeEvents( events : boolean ) : this {\r\n        return this.metadata({ changeEvents : events });\r\n    }\r\n\r\n    // Subsribe to events from an attribute.\r\n    events( map : EventsDefinition ) : this {\r\n        const eventMap = new EventMap( map );\r\n\r\n        function handleEventsSubscribtion( next, prev, record : AttributesContainer ){\r\n            prev && prev.trigger && eventMap.unsubscribe( record, prev );\r\n\r\n            next && next.trigger && eventMap.subscribe( record, next );\r\n        }\r\n\r\n        return this.metadata({\r\n            changeHandlers : this.options.changeHandlers.concat( handleEventsSubscribtion )\r\n        });\r\n    }\r\n\r\n    // Creates a copy of the spec.\r\n    get has() : this {\r\n        return this;\r\n    }\r\n\r\n    metadata( options : object ) : this {\r\n        const cloned = new ChainableAttributeSpec( this.options );\r\n        assign( cloned.options, options );\r\n        return cloned as any;\r\n    }\r\n\r\n    value( x ) : this {\r\n        return this.metadata({ value : x, hasCustomDefault : true });\r\n    }\r\n\r\n    static from( spec : any ) : ChainableAttributeSpec<any> {\r\n        return null; // dependency injection, see the top level index.ts\r\n    }\r\n}\r\n\r\nfunction emptyFunction(){}\r\n\r\nexport function type<F extends Function>( this : void, Type : ChainableAttributeSpec<F> | F, value? : any ) : ChainableAttributeSpec<F> {\r\n    if( Type instanceof ChainableAttributeSpec ) return Type;\r\n\r\n    const attrDef = new ChainableAttributeSpec<F>({ type : Type }),\r\n          defaultValue = Type && value === void 0 ? getMetatype( Type ).defaultValue : value;\r\n\r\n    return defaultValue === void 0 ? attrDef : attrDef.value( defaultValue );\r\n}\r\n\r\nexport function shared<C extends Function>( this : void, Constructor : C ) : ChainableAttributeSpec<C> {\r\n    return new ChainableAttributeSpec<C>({\r\n        value : null,\r\n        type : Constructor,\r\n        _metatype : SharedType\r\n    });\r\n}\r\n\r\nexport { shared as refTo };\r\n\r\n// Create attribute metatype inferring the type from the value.\r\nexport function value<T>( this : void, x : T ) : ChainableAttributeSpec<new ( ...args : any[] ) => T> {\r\n    const Type = inferType( x ),\r\n        // Transactional types inferred from values must have shared type. \r\n        AttrDef = Type && Type.prototype instanceof Transactional ? shared( Type ) :\r\n                  type( Type );\r\n\r\n    return AttrDef.value( x ) as any;\r\n}\r\n\r\n/*\r\nexport declare type InferConstructor<T> = \r\n    T extends number ? NumberConstructor :\r\n    T extends string ? StringConstructor :\r\n    T extends boolean ? BooleanConstructor :\r\n    T extends Date ? DateConstructor :\r\n    T extends Transactional ? new ( ...args : any[] ) => */\r\n\r\nfunction inferType( value : any ) : Function {\r\n    switch( typeof value ) {\r\n        case 'number' :\r\n            return Number;\r\n        case 'string' :\r\n            return String;\r\n        case 'boolean' :\r\n            return Boolean;\r\n        case 'function' :\r\n            return Function;\r\n        case 'undefined' :\r\n            return void 0;\r\n        case 'object' :\r\n            return value ? <any> value.constructor : void 0;\r\n    }\r\n}","import { GenericComparator } from '../collection';\r\nimport { IOEndpoint } from '../io-tools';\r\nimport { Infer } from './attrDef';\r\nimport { LinkedModelHash } from './linked-attrs';\r\nimport { MakeModelConstructor, Model } from './model';\r\n\r\nexport const collection = Symbol(\"Methods definitions\");\r\nexport const metadata = Symbol(\"Methods definitions\");\r\n\r\n// TODO: getters and setters can go to the attributes object.\r\n// Methods can be added though the class.\r\n\r\nexport interface AnonimousModelDefinition {\r\n    [metadata]? : {\r\n        idAttribute? : string\r\n        endpoint? : IOEndpoint\r\n    }\r\n\r\n    [collection]? : {\r\n        itemEvents? : { [ event : string ] : true | string | (( ...args : any[] ) => void ) }\r\n        comparator? : GenericComparator\r\n        \r\n        initialize?( models? : any[], options? : object ) : void\r\n        parse?( json : any ) : object[]\r\n        toJSON?( options? : any ) : any\r\n        validate?() : any\r\n    }\r\n\r\n    [attribute : string] : any\r\n}\r\n\r\nexport function parseAnonimousModelDefinition({ [metadata] : md, [collection] : coll, ...attributes } : AnonimousModelDefinition){\r\n    return {\r\n        attributes,\r\n        collection : coll,\r\n        ...md\r\n    }\r\n}\r\n\r\nexport type AnonymousAttributes<D extends object> =\r\n    AnonymousModelConstructor<D>\r\n\r\nexport type AnonymousModelConstructor<A extends object> =\r\n    MakeModelConstructor<\r\n        Model & ModelAttributes<A>,\r\n        A\r\n    >\r\n\r\nexport type ModelAttributes<A extends object> =\r\n    InferAttrs<A> & {\r\n        readonly $ : LinkedModelHash<InferAttrs<A>>\r\n    }\r\n\r\nexport type MergeModelConstructors<First extends typeof Model, Second extends typeof Model> =\r\n    MakeModelConstructor<\r\n        InstanceType<First> & InstanceType<Second>,\r\n        First['attributes'] & Second['attributes']\r\n    >\r\n\r\nexport type InferAttrs<A extends object> = {\r\n    [K in Exclude<keyof A, typeof metadata|typeof collection>]: Infer<A[K]>\r\n};","import { Model } from './model'\r\nimport { Linked } from '@linked/value'\r\nimport { Transactional } from '../transactions';\r\n\r\nexport function addAttributeLinks( Class : typeof Model ){\r\n    const { prototype } = Class;\r\n    const { _attributesArray } = prototype;\r\n\r\n    const AttributeRefs = new Function('model', `\r\n        this._model = model;\r\n        ${ _attributesArray.map( ({ name }) => `this.$${name} = void 0; `).join( '\\n' )}\r\n    `)\r\n\r\n    AttributeRefs.prototype.__ModelAttrRef = LinkedAttr;\r\n\r\n    for( let attr of _attributesArray ){\r\n        const { name } = attr;\r\n        \r\n        Object.defineProperty( AttributeRefs.prototype, name, {\r\n            get : new Function( attr.isMutableType() ? `\r\n                var cached = this.$${name},\r\n                    value = this._model.${name},\r\n                    token = value && value._changeToken;\r\n\r\n                return cached && cached._token === token ? cached :\r\n                    ( this.$${name} = new this.__ModelAttrRef( this._model, '${name}', value, token ) );\r\n            ` : `\r\n                var cached = this.$${name};\r\n\r\n                return cached && cached.value === this._model.${name} ? cached :\r\n                    ( this.$${name} = new this.__ModelAttrRef( this._model, '${name}', this._model.${name} ) );\r\n            `) as any\r\n        });\r\n    }\r\n\r\n    prototype.__Attributes$ = AttributeRefs as any;\r\n}\r\n\r\nexport type LinkedModelHash<T extends object>= {\r\n    readonly [ K in keyof T ] : LinkedAttr<T[K]>\r\n}\r\n\r\nexport class LinkedAttr<T> extends Linked<T> {\r\n    constructor( protected model : Model, protected attr : string, value, protected _token ){\r\n        super( value );\r\n    }\r\n\r\n    set( x : T ){\r\n        this.model[ this.attr ] = x;\r\n    }\r\n\r\n    _error : any\r\n\r\n    get error(){\r\n        return this._error || ( this._error = this.model.getValidationError( this.attr ) );\r\n    }\r\n\r\n    set error( x : any ){\r\n        this._error = x;\r\n    }\r\n\r\n    // Attribute's descriptor.\r\n    get descriptor(){\r\n        return this.model._attributes[ this.attr ];\r\n    }\r\n}\r\n\r\nObject.defineProperty( LinkedAttr.prototype, '_changeToken', { value : null } );","import { IOEndpoint } from '../io-tools';\r\nimport { eventsApi, tools as _ } from '@type-r/mixture';\r\nimport { CompiledReference } from '../traversable';\r\nimport { ChainableAttributeSpec } from './attrDef';\r\nimport { AnyType } from './metatypes';\r\nimport { ConstructorsMixin, constructorsMixin } from './updates';\r\n\r\nexport interface ModelAttributesMixin extends ConstructorsMixin {\r\n    // Attributes descriptors\r\n    _attributes : AttributeDescriptors\r\n    _attributesArray : AnyType[]\r\n    \r\n    // Attribute's property descriptors\r\n    properties : PropertyDescriptorMap\r\n\r\n    // Event map for record's local events.\r\n    _localEvents? : eventsApi.EventMap,\r\n\r\n    _endpoints : { [ name : string ] : IOEndpoint }\r\n}\r\n\r\nexport interface AttributeDescriptors {\r\n    [ name : string ] : AnyType\r\n}\r\n\r\n// Create attribute from the type spec.\r\nexport function createAttribute( spec : any, name : string ) : AnyType {\r\n    return AnyType.create( ChainableAttributeSpec.from( spec ).options, name );\r\n}\r\n\r\n// Create record mixin from the given record's attributes definition\r\nexport function createAttributesMixin( attributesDefinition : object, baseClassAttributes : AttributeDescriptors ) : ModelAttributesMixin {\r\n    const myAttributes = _.transform( {} as AttributeDescriptors, attributesDefinition, createAttribute ),\r\n          allAttributes = _.defaults( {} as AttributeDescriptors, myAttributes, baseClassAttributes );\r\n\r\n    const ConstructorsMixin = constructorsMixin( allAttributes );\r\n\r\n    return {\r\n        ...ConstructorsMixin,\r\n        _attributes : new ConstructorsMixin.AttributesCopy( allAttributes ),\r\n        _attributesArray : Object.keys( allAttributes ).map( key => allAttributes[ key ] ),\r\n        properties : _.transform( <PropertyDescriptorMap>{}, myAttributes, x => x.createPropertyDescriptor() ),\r\n        ...localEventsMixin( myAttributes ),\r\n        _endpoints : _.transform( {}, allAttributes, attrDef => attrDef.options.endpoint )\r\n    }            \r\n}\r\n\r\ninterface LocalEventsMixin {\r\n    _localEvents? : eventsApi.EventMap\r\n}\r\n\r\nfunction localEventsMixin( attrSpecs : AttributeDescriptors ) : LocalEventsMixin {\r\n    let _localEvents : eventsApi.EventMap;\r\n\r\n    for( var key in attrSpecs ){\r\n        const attribute = attrSpecs[ key ],\r\n            { _onChange } = attribute.options; \r\n\r\n        if( _onChange ){\r\n            _localEvents || ( _localEvents = new eventsApi.EventMap() );\r\n\r\n            _localEvents.addEvent( 'change:' + key,\r\n                typeof _onChange === 'string' ?\r\n                    createWatcherFromRef( _onChange, key ) : \r\n                    wrapWatcher( _onChange, key ) );\r\n        }\r\n    }\r\n\r\n    return _localEvents ? { _localEvents } : {};\r\n}\r\n\r\nfunction wrapWatcher( watcher, key ){\r\n    return function( record, value ){\r\n        watcher.call( record, value, key );\r\n    } \r\n}\r\n\r\nfunction createWatcherFromRef( ref : string, key : string ){\r\n    const { local, resolve, tail } = new CompiledReference( ref, true );\r\n    return local ?\r\n        function( record, value ){\r\n            record[ tail ]( value, key );\r\n        } :\r\n        function( record, value ){\r\n            resolve( record )[ tail ]( value, key );\r\n        }\r\n}","import { IOEndpoint, IONode, IOOptions, IOPromise, startIO } from '../io-tools';\r\nimport { TransactionOptions } from '../transactions';\r\n\r\nexport interface IOModel extends IONode {\r\n    getEndpoint() : IOEndpoint\r\n    save( options? : object ) : IOPromise<this>\r\n    fetch( options? : object ) : IOPromise<this>\r\n    destroy( options? : object ) : IOPromise<this>\r\n    toJSON( options? : object ) : any\r\n    parse( data : any, options? : object ) : any\r\n    isNew() : boolean\r\n    id : string | number\r\n    set( json : object, options : TransactionOptions ) : this\r\n}\r\n\r\nexport const IOModelMixin = {\r\n    save( this : IOModel, options : IOOptions = {} ){\r\n        const endpoint = this.getEndpoint(),\r\n              json = this.toJSON({ ioMethod : 'save', ...options });\r\n\r\n        return startIO(\r\n            this,\r\n            this.isNew() ?\r\n                endpoint.create( json, options, this ) :\r\n                endpoint.update( this.id, json, options, this ),\r\n            options,\r\n\r\n            update => {\r\n                this.set( update, {\r\n                    parse : true,\r\n                    ioMethod : 'save',\r\n                    ...options\r\n                } );\r\n            }\r\n        );\r\n    },\r\n\r\n    fetch( options : IOOptions = {} ){\r\n        return startIO(\r\n            this,\r\n            this.getEndpoint().read( this.id, options, this ),\r\n            options,\r\n\r\n            json => this.set( json, { parse : true, ioMethod : 'fetch', ...options } )\r\n        );\r\n    },\r\n\r\n    destroy( options : IOOptions = {} ){  \r\n        return startIO(\r\n            this,\r\n            this.getEndpoint().destroy( this.id, options, this ),\r\n            options,\r\n\r\n            () => {\r\n                const { collection } = this;\r\n                if( collection ){\r\n                    collection.remove( this, options );\r\n                }\r\n                else{\r\n                    this.dispose();\r\n                }\r\n\r\n                return this;\r\n            }\r\n        )\r\n    }\r\n}","/**\r\n * Model core implementing transactional updates.\r\n * The root of all definitions. \r\n */\r\n\r\nimport { define, definitions, isProduction, Logger, TheType, logger, LogLevel, mixinRules, tools } from '@type-r/mixture';\r\nimport { CollectionConstructor } from '../collection';\r\nimport { IOEndpoint } from '../io-tools';\r\nimport { CloneOptions, Owner, Transaction, Transactional, TransactionalDefinition, TransactionOptions } from '../transactions';\r\nimport { ChildrenErrors } from '../validation';\r\nimport { type } from './attrDef';\r\nimport { InferAttrs, ModelAttributes, AnonymousModelConstructor } from './define';\r\nimport { IOModel, IOModelMixin } from './io-mixin';\r\nimport { LinkedModelHash } from './linked-attrs';\r\nimport { AggregatedType, AnyType } from './metatypes';\r\nimport { AttributesConstructor, AttributesContainer, AttributesCopyConstructor, AttributesValues, setAttribute, shouldBeAnObject, unknownAttrsWarning, UpdateModelMixin } from './updates';\r\n\r\nexport interface MakeModelConstructor<T extends Model, A extends object> extends TheType<typeof Model>\r\n{\r\n    new ( attrs? : Partial<InferAttrs<A>>, options? : object ) : T\r\n    prototype : T\r\n    attributes : A\r\n    Collection : CollectionConstructor<Model&T>\r\n}\r\n\r\nconst { assign, isEmpty } = tools;\r\n\r\n/*******************************************************\r\n * Model core implementation\r\n */\r\n\r\nexport interface ConstructorOptions extends TransactionOptions{\r\n    clone? : boolean\r\n}\r\n\r\n// Client unique id counter\r\nlet _cidCounter : number = 0;\r\n\r\n/***************************************************************\r\n * Model Definition as accepted by Model.define( definition )\r\n */\r\nexport interface ModelDefinition extends TransactionalDefinition {\r\n    idAttribute? : string\r\n    attributes? : AttributesValues\r\n    collection? : object\r\n    Collection? : typeof Transactional\r\n}\r\n\r\nexport type LinkedAttributes<M extends { attributes : object }> = LinkedModelHash<InferAttrs<M['attributes']>>\r\nexport type AttributesMixin<M extends { attributes : object }> = ModelAttributes<M['attributes']>\r\n\r\n@define({\r\n    // Default client id prefix \r\n    cidPrefix : 'm',\r\n\r\n    // Name of the change event\r\n    _changeEventName : 'change',\r\n\r\n    // Default id attribute name\r\n    idAttribute : 'id'\r\n})\r\n@definitions({\r\n    defaults : mixinRules.merge,\r\n    attributes : mixinRules.merge,\r\n    collection : mixinRules.merge,\r\n    Collection : mixinRules.value,\r\n    idAttribute : mixinRules.protoValue\r\n})\r\nexport class Model extends Transactional implements IOModel, AttributesContainer, Iterable<any> {\r\n    /** @internal */\r\n    static _metatype = AggregatedType;\r\n\r\n    // Hack\r\n    static onDefine( definition, BaseClass ){}\r\n\r\n    static comparator<T extends typeof Model>( this : T, attr : keyof InstanceType<T>, asc = true ) : ( a : InstanceType<T>, b : InstanceType<T> ) => -1 | 0 | 1 {\r\n        const { compare } = tools;\r\n        return asc ? \r\n            ( a, b ) => compare( a[ attr ], b[ attr ] ) :\r\n            ( a, b ) => -compare( a[ attr ], b[ attr ] ) as any;\r\n    }\r\n\r\n    static Collection : CollectionConstructor;\r\n    static DefaultCollection : CollectionConstructor;\r\n    \r\n    // Attribute type for the record id.\r\n    static id = type( String ).value( null );\r\n    \r\n    // Lazy object reference, serializable as id.\r\n    static get ref(){\r\n        return type( this )\r\n            .toJSON( x => x ? x.id : null )\r\n            .parse( x => {\r\n                return { [ this.prototype.idAttribute ] : x };\r\n            });\r\n    }\r\n\r\n    static extendAttrs<T extends typeof Model, A extends object>( this : T, attrs : A ) : AnonymousModelConstructor<T['attributes'] & A> {\r\n        return this.defaults( attrs ) as any;\r\n    }\r\n\r\n    static defaults( attrs : AttributesValues ) : typeof Model {\r\n        return this.extend({ attributes : attrs }) as any;\r\n    }\r\n    \r\n    static attributes : AttributesValues\r\n\r\n    /** @internal */\r\n    _attributes$ : object = void 0\r\n\r\n    /** @internal */\r\n    __Attributes$ : new ( model : Model ) => object\r\n\r\n    /** @internal */\r\n    get $() : object {\r\n        return this._attributes$ || ( this._attributes$ = new this.__Attributes$( this ) )\r\n    }\r\n\r\n    /********************\r\n     * IO Methods\r\n     */\r\n    /** @internal */\r\n     _endpoints : { [ name : string ] : IOEndpoint }\r\n\r\n    /***********************************\r\n     * Core Members\r\n     */\r\n    previousAttributes(){ return new this.AttributesCopy( this._previousAttributes ); } \r\n\r\n    // Polymorphic accessor for aggregated attribute's canBeUpdated().\r\n    /** @internal */\r\n    get __inner_state__(){ return this.attributes; }\r\n\r\n    get changed(){\r\n        let changed = this._changedAttributes;\r\n\r\n        if( !changed ){\r\n            const prev = this._previousAttributes;\r\n            changed = {};\r\n\r\n            const { attributes } = this;\r\n\r\n            for( let attr of this._attributesArray ){\r\n                const key = attr.name,\r\n                    value = attributes[ key ];\r\n\r\n                if( attr.isChanged( value, prev[ key ] ) ){\r\n                    changed[ key ] = value;\r\n                }\r\n            }\r\n\r\n            this._changedAttributes = changed;\r\n        }\r\n\r\n        return changed;    \r\n    }\r\n\r\n    changedAttributes( diff? : {} ) : boolean | {} {\r\n        if( !diff ) return this.hasChanged() ? { ...this.changed } : false;\r\n\r\n        var val, changed : {} | boolean = false,\r\n            old          = this._transaction ? this._previousAttributes : this.attributes,\r\n            attrSpecs    = this._attributes;\r\n\r\n        for( var attr in diff ){\r\n            if( !attrSpecs[ attr ].isChanged( old[ attr ], ( val = diff[ attr ] ) ) ) continue;\r\n            (changed || (changed = {}))[ attr ] = val;\r\n        }\r\n\r\n        return changed;        \r\n    }\r\n\r\n    hasChanged( key? : string ) : boolean {\r\n        const { _previousAttributes } = this;\r\n        if( !_previousAttributes ) return false;\r\n\r\n        return key ?\r\n                this._attributes[ key ].isChanged( this.attributes[ key ], _previousAttributes[ key ] ) :\r\n                !isEmpty( this.changed );\r\n    }\r\n\r\n    previous( key : string ) : any {\r\n        if( key ){\r\n            const { _previousAttributes } = this;\r\n            if( _previousAttributes ) return _previousAttributes[ key ];\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    isNew() : boolean {\r\n        return this.id == null;\r\n    }\r\n\r\n    has( key : string ) : boolean {\r\n        return this[ key ] != void 0;\r\n    }\r\n\r\n    // Return attribute value, setting an attribute to undefined.\r\n    // TODO: If attribute was aggregated, don't dispose it.\r\n    unset( key : string, options? ) : any {\r\n        const value = this[ key ];\r\n        this.set({ [ key ] : void 0 }, { unset : true, ...options });\r\n        return value;\r\n    }\r\n\r\n    // Undocumented. Move to NestedTypes?\r\n    clear( options? ) : this {\r\n        const nullify = options && options.nullify;\r\n\r\n        this.transaction( () =>{\r\n            this.forEach( ( value, key ) => this[ key ] = nullify ? null : void 0 );\r\n        }, options );\r\n\r\n        return this;\r\n    }\r\n\r\n    // Returns Model owner skipping collections. TODO: Move out\r\n    getOwner() : Owner {\r\n        const owner : any = this._owner;\r\n\r\n        // If there are no key, owner must be transactional object, and it's the collection.\r\n        // We don't expect that collection can be the member of collection, so we're skipping just one level up. An optimization.\r\n        return this._ownerKey ? owner : owner && owner._owner;\r\n    }\r\n\r\n    /***********************************\r\n     * Identity managements\r\n     */\r\n\r\n    // Id attribute name ('id' by default)\r\n    idAttribute : string;\r\n\r\n    // Fixed 'id' property pointing to id attribute\r\n    get id() : string { return this.attributes[ this.idAttribute ]; }\r\n    set id( x : string ){ setAttribute( this, this.idAttribute, x ); }\r\n\r\n    /***********************************\r\n     * Dynamically compiled stuff\r\n     */\r\n\r\n    // Attributes specifications\r\n    /** @internal */\r\n    _attributes : { [ key : string ] : AnyType }\r\n\r\n    /** @internal */\r\n    _attributesArray : AnyType[]\r\n\r\n    // Attributes object copy constructor\r\n    Attributes : AttributesConstructor\r\n    AttributesCopy : AttributesCopyConstructor\r\n\r\n    // Create record default values, optionally augmenting given values.\r\n    defaults( values = {} ){\r\n        const defaults = {},\r\n            { _attributesArray } = this;\r\n\r\n        for( let attr of _attributesArray ){\r\n            const key = attr.name,\r\n            value = values[ key ];\r\n\r\n            defaults[ key ] = value === void 0 ? attr.defaultValue() : value;\r\n        }\r\n\r\n        return defaults;\r\n    }\r\n\r\n    /***************************************************\r\n     * Model construction\r\n     */\r\n    // Create record, optionally setting an owner\r\n    constructor( a_values? : any, a_options? : ConstructorOptions ){\r\n        super( _cidCounter++ );\r\n        this.attributes = {};\r\n        \r\n        const options = a_options || {},\r\n              values = ( options.parse ? this.parse( a_values, options ) :  a_values ) || {};\r\n\r\n        isProduction || typeCheck( this, values, options );\r\n\r\n        this._previousAttributes = this.attributes = new this.Attributes( this, values, options );\r\n\r\n        this.initialize( a_values, a_options );\r\n\r\n        if( this._localEvents ) this._localEvents.subscribe( this, this );\r\n    }\r\n\r\n    // Initialization callback, to be overriden by the subclasses \r\n    initialize( values? : Partial<this>, options? ){}\r\n\r\n    // Deeply clone record, optionally setting new owner.\r\n    clone( options : CloneOptions = {} ) : this {\r\n        const copy : this = new (<any>this.constructor)( this.attributes, { clone : true } );\r\n        \r\n        if( options.pinStore ) copy._defaultStore = this.getStore();\r\n\r\n        return copy;\r\n    }\r\n\r\n    /** @internal */\r\n    _validateNested( errors : ChildrenErrors ) : number {\r\n        var length    = 0;\r\n\r\n        const { attributes } = this;\r\n\r\n        for( let attribute of this._attributesArray ){\r\n            const { name } = attribute,\r\n                error = attribute.validate( this, attributes[ name ], name );\r\n\r\n            if( error ){\r\n                errors[ name ] = error;\r\n                length++;\r\n            }\r\n        }\r\n\r\n        return length;\r\n    }\r\n\r\n    // Get attribute by key\r\n    get( key : string ) : any {\r\n        return this[ key ];\r\n    }\r\n\r\n    // Apply bulk in-place object update in scope of ad-hoc transaction \r\n    set( values : any, options? : TransactionOptions ) : this {\r\n        if( values ){ \r\n            const transaction = this._createTransaction( values, options );\r\n            transaction && transaction.commit();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serialization control\r\n     */\r\n\r\n    // Default record-level serializer, to be overriden by subclasses \r\n    toJSON( options? : TransactionOptions ) : any {\r\n        const json = {},\r\n            { attributes } = this;\r\n\r\n        for( let attribute of this._attributesArray ){\r\n            const { name } = attribute,\r\n                value = attributes[ name ];\r\n\r\n            if( value !== void 0 ){\r\n                // ...serialize it according to its spec.\r\n                const asJson = attribute.toJSON.call( this, value, name, options );\r\n\r\n                // ...skipping undefined values. Such an attributes are excluded.\r\n                if( asJson !== void 0 ) json[ name ] = asJson; \r\n            }\r\n        }\r\n\r\n        return json;\r\n    }\r\n    \r\n    // Default record-level parser, to be overriden by the subclasses.\r\n    parse( data, options? : TransactionOptions ){\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Transactional control\r\n     */\r\n    deepSet( name : string, value : any, options? : any ){\r\n        // Operation might involve series of nested object updates, thus it's wrapped in transaction.\r\n        this.transaction( () => {\r\n            const path  = name.split( '.' ),\r\n                l     = path.length - 1,\r\n                attr  = path[ l ];\r\n\r\n            let model = this;\r\n\r\n            // Locate the model, traversing the path.\r\n            for( let i = 0; i < l; i++ ){\r\n                const key = path[ i ];\r\n\r\n                // There might be collections in path, so use `get`.\r\n                let next    = model.get ? model.get( key ) : model[ key ];\r\n\r\n                // Create models, if they are not exist.\r\n                if( !next ){\r\n                    const attrSpecs = model._attributes;\r\n                    if( attrSpecs ){\r\n                        // If current object is model, create default attribute\r\n                        var newModel = attrSpecs[ key ].create();\r\n\r\n                        // If created object is model, nullify attributes when requested\r\n                        if( options && options.nullify && newModel._attributes ){\r\n                            newModel.clear( options );\r\n                        }\r\n\r\n                        model[ key ] = next = newModel;\r\n                    }\r\n                    // Silently fail in other case.\r\n                    else return;\r\n                }\r\n                \r\n                model = next;\r\n            }\r\n\r\n            // Set model attribute.\r\n            if( model.set ){\r\n                model.set({ [ attr ] : value }, options );\r\n            }\r\n            else{\r\n                model[ attr ] = value;\r\n            }\r\n        });\r\n\r\n        return this\r\n    }\r\n            \r\n    // Returns owner without the key (usually it's collection)\r\n    get collection() : any {\r\n        return this._ownerKey ? null : this._owner;\r\n    }\r\n\r\n    // Dispose object and all childrens\r\n    dispose(){\r\n        if( this._disposed ) return;\r\n\r\n        const { attributes } = this;\r\n\r\n        for( let attr of this._attributesArray ){\r\n            attr.dispose( this, attributes[ attr.name ] );\r\n        }\r\n        \r\n        super.dispose();\r\n    }\r\n\r\n    /** @internal */\r\n    _log( level : LogLevel, topic: string, text : string, props : object, a_logger? : Logger ) : void {\r\n        ( a_logger || logger ).trigger( level, topic, this.getClassName() + ' ' + text, {\r\n            ...props,\r\n            'Model' : this,\r\n            'Attributes definition' : this._attributes\r\n        });\r\n    }\r\n\r\n    getClassName() : string {\r\n        return super.getClassName() || 'Model';\r\n    }\r\n\r\n    /** @internal */\r\n    _createTransaction( values : object, options : TransactionOptions ) : Transaction { return void 0; }\r\n    // Simulate attribute change \r\n    forceAttributeChange : ( key : string, options : TransactionOptions ) => void\r\n\r\n    /** @internal */\r\n    _onChildrenChange : ( child : Transactional, options : TransactionOptions ) => void\r\n\r\n\r\n    /**\r\n     * Map methods\r\n     */\r\n\r\n    forEach( iteratee : ( value? : any, key? : string ) => void, context? : any ){\r\n        const fun = context !== void 0 ? ( v, k ) => iteratee.call( context, v, k ) : iteratee,\r\n            { attributes } = this;\r\n\r\n        for( const key in this.attributes ){\r\n            const value = attributes[ key ];\r\n            if( value !== void 0 ) fun( value, key );\r\n        }\r\n    }\r\n\r\n    mapObject( a_fun : ( value, key ) => any, context? : any ) : object {\r\n        const fun = context === void 0 ? a_fun : a_fun.bind( context );\r\n        return tools.transform( {}, this.attributes, fun );\r\n    }\r\n\r\n    [ Symbol.iterator ](){\r\n        return new ModelEntriesIterator( this );\r\n    }\r\n\r\n    entries(){\r\n        return new ModelEntriesIterator( this );\r\n    }\r\n\r\n    // Get array of attribute keys (Model) or record ids (Collection) \r\n    keys() : string[] {\r\n        const keys : string[] = [];\r\n\r\n        this.forEach( ( value, key ) => keys.push( key ) );\r\n\r\n        return keys;\r\n    }\r\n};\r\n\r\nexport interface Model extends IOModel {}\r\nexport interface Model extends AttributesContainer {}\r\n\r\n\r\nassign( Model.prototype, UpdateModelMixin, IOModelMixin );\r\n\r\n/***********************************************\r\n * Helper functions\r\n */\r\n\r\nclass BaseModelAttributes {\r\n    id : string\r\n\r\n    constructor( record : Model, x : AttributesValues, options : TransactionOptions ) {\r\n        this.id = x.id;\r\n    }\r\n}\r\n\r\nModel.prototype.Attributes = BaseModelAttributes;\r\n\r\nclass BaseModelAttributesCopy {\r\n    id : string\r\n\r\n    constructor( x : AttributesValues ) {\r\n        this.id = x.id;\r\n    }\r\n}\r\n\r\nModel.prototype.AttributesCopy = BaseModelAttributesCopy;\r\n\r\nconst IdAttribute = AnyType.create({ value : void 0 }, 'id' );\r\nModel.prototype._attributes = { id : IdAttribute };\r\nModel.prototype._attributesArray = [ IdAttribute ];\r\n\r\nfunction typeCheck( record : Model, values : object, options ){\r\n    if( shouldBeAnObject( record, values, options ) ){\r\n        const { _attributes } = record;\r\n        let unknown : string[];\r\n\r\n        for( let name in values ){\r\n            if( !_attributes[ name ] ){\r\n                unknown || ( unknown = [] );\r\n                unknown.push( `'${ name }'` );\r\n            }\r\n        }\r\n\r\n        if( unknown ){\r\n            unknownAttrsWarning( record, unknown, { values }, options );\r\n        }\r\n    }\r\n}\r\n\r\nexport class ModelEntriesIterator implements Iterator<[string, any]> {\r\n    private idx = 0;\r\n    \r\n    constructor( private readonly record : Model){}\r\n\r\n    next() : IteratorResult<[string, any]> {\r\n        const { record } = this,\r\n            metatype = record._attributesArray[ this.idx++ ];\r\n\r\n        return {\r\n            done : !metatype,\r\n            value : metatype ? [ metatype.name, record[ metatype.name ] ] : void 0\r\n        };\r\n    }\r\n}","import { define, mixins, predefine, tools } from '@type-r/mixture';\r\nimport { Transactional } from '../transactions';\r\nimport { type } from './attrDef';\r\nimport { AnonimousModelDefinition, AnonymousAttributes, MergeModelConstructors, parseAnonimousModelDefinition } from './define';\r\nimport { addAttributeLinks } from './linked-attrs';\r\nimport { createAttributesMixin } from './mixin';\r\nimport { Model, ModelDefinition } from './model';\r\nexport { collection, metadata, AnonymousModelConstructor, InferAttrs } from './define'\r\nexport * from './attrDef';\r\nexport * from './metatypes';\r\nexport { AttributesMixin, LinkedAttributes } from './model';\r\nexport { Model };\r\n\r\nconst { assign, defaults } = tools;\r\n\r\nexport function attributes<D extends AnonimousModelDefinition, B1 extends typeof Model, B2 extends typeof Model, B3 extends typeof Model>( b1 : B1, b2 : B2, b3 : B3, attrDefs : D ) : MergeModelConstructors<MergeModelConstructors<MergeModelConstructors<B1,B2>,B3>,AnonymousAttributes<D>>\r\nexport function attributes<D extends AnonimousModelDefinition, B1 extends typeof Model, B2 extends typeof Model>( b1 : B1, b2 : B2, attrDefs : D ) : MergeModelConstructors<MergeModelConstructors<B1,B2>,AnonymousAttributes<D>>\r\nexport function attributes<D extends AnonimousModelDefinition, B1 extends typeof Model>( b1 : B1, attrDefs : D ) : MergeModelConstructors<B1,AnonymousAttributes<D>>;\r\nexport function attributes<D extends AnonimousModelDefinition>( attrDefs : D ) : AnonymousAttributes<D>;\r\nexport function attributes( ...models : any[] ){\r\n    const last = parseAnonimousModelDefinition( models[ models.length - 1 ] ),\r\n        First = models.length > 1 ? models[ 0 ] : null,\r\n        toMix = models.length > 2 ? models.slice( 1, models.length - 1 ) : null;\r\n\r\n        class AnonimousModel extends ( First || Model ){\r\n        }\r\n\r\n        toMix && mixins( toMix )(AnonimousModel);\r\n        define( last )( AnonimousModel );\r\n\r\n    return AnonimousModel as any;\r\n}\r\n\r\nModel.onExtend = function( this : typeof Model, BaseClass : typeof Model ){\r\n    Transactional.onExtend.call( this, BaseClass );\r\n\r\n    // Create the default collection\r\n    const Class = this;\r\n\r\n    @predefine class DefaultCollection extends BaseClass.Collection {\r\n        static model = Class;\r\n    }\r\n\r\n    this.DefaultCollection = DefaultCollection;\r\n\r\n    // If there are no collection defined in statics, use the default collection.\r\n    // It will appear in onDefine's definition, overriding all other settings.\r\n    if( Class.Collection === BaseClass.Collection ){\r\n        this.Collection = DefaultCollection;\r\n    }\r\n}\r\n\r\nModel.onDefine = function( definition : ModelDefinition, BaseClass : typeof Model ){\r\n    const baseProto : Model = BaseClass.prototype;\r\n\r\n    // Compile attributes spec, creating definition mixin.\r\n    const { properties, _localEvents, ...dynamicMixin } = createAttributesMixin( this.attributes = getAttributes( definition ), baseProto._attributes );\r\n    assign( this.prototype, dynamicMixin );\r\n    \r\n    definition.properties = defaults( definition.properties || {}, properties );\r\n    definition._localEvents = _localEvents;\r\n    \r\n    Transactional.onDefine.call( this, definition, BaseClass );\r\n\r\n    // Finalize the definition of the default collection.\r\n    this.DefaultCollection.define( definition.collection || {} );\r\n\r\n    // assign collection from the definition.\r\n    this.Collection = definition.Collection;\r\n    this.Collection.prototype.model = this;\r\n\r\n    if( definition.endpoint ) this.Collection.prototype._endpoint = definition.endpoint;\r\n\r\n    addAttributeLinks( this );\r\n}\r\n\r\nfunction getAttributes({ defaults, attributes, idAttribute } : ModelDefinition ) {\r\n    const definition = attributes || defaults || {};\r\n    \r\n    // If there is an undeclared idAttribute, add its definition as untyped generic attribute.\r\n    if( idAttribute && !( idAttribute in definition ) ){\r\n        definition[ idAttribute ] = void 0;\r\n    }\r\n\r\n    return definition;\r\n}\r\n\r\ndeclare var Reflect;\r\n\r\nexport function auto( value : any ) : PropertyDecorator;\r\nexport function auto( proto : object, attrName : string ) : void;\r\nexport function auto( proto, attrName? : string ) : any {\r\n    if( typeof Reflect !== 'undefined' && Reflect.getMetadata ){\r\n        if( attrName ){\r\n            type( Reflect.getMetadata( \"design:type\", proto, attrName ) ).as( proto, attrName );\r\n        }\r\n        else{\r\n            const value = proto;\r\n            return ( proto : object, attrName : string ) : void => {\r\n                type( Reflect.getMetadata( \"design:type\", proto, attrName ) ).value( value ).as( proto, attrName );\r\n            }\r\n        }        \r\n    }\r\n    else{\r\n        proto._log( 'error', 'Type-R:MissingImport', 'Add import \"reflect-metadata\"; as the first line of your app.' );\r\n    }    \r\n}","import { eventsApi, Logger } from '@type-r/mixture';\r\nimport { Model } from '../model';\r\nimport { ItemsBehavior, Owner, Transaction, Transactional, transactionApi, TransactionOptions } from '../transactions';\r\n\r\n\r\nconst { trigger2, trigger3, on, off } = eventsApi,\r\n      { commit } = transactionApi,\r\n      _aquire = transactionApi.aquire, _free = transactionApi.free;\r\n\r\n/** @private */\r\nexport interface CollectionCore extends Transactional, Owner {\r\n    /** @internal */\r\n    _byId : IdIndex\r\n\r\n    models : Model[]\r\n    model : typeof Model\r\n    idAttribute : string // TODO: Refactor inconsistent idAttribute usage\r\n    \r\n    /** @internal */\r\n    _comparator : Comparator\r\n    \r\n    get( objOrId : string | Model | Object ) : Model    \r\n    \r\n    /** @internal */\r\n    _itemEvents? : eventsApi.EventMap\r\n    /** @internal */\r\n    _shared : number\r\n    /** @internal */\r\n    _aggregationError : Model[]\r\n    /** @internal */\r\n    _log( level : string, topic : string, text : string, value : any, logger : Logger ) : void\r\n}\r\n\r\n// Collection's manipulation methods elements\r\nexport type Elements = ( Object | Model )[];\r\n\r\nexport interface CollectionOptions extends TransactionOptions {\r\n    sort? : boolean\r\n}\r\n\r\nexport type Comparator = ( a : Model, b : Model ) => number;  \r\n\r\n/** @private */\r\nexport function dispose( collection : CollectionCore ) : Model[]{\r\n    const { models } = collection;\r\n\r\n    collection.models = [];\r\n    collection._byId  = {};\r\n\r\n    freeAll( collection, models );\r\n    return models;\r\n}\r\n\r\n/** @private */\r\nexport function convertAndAquire( collection : CollectionCore, attrs : {} | Model, options : CollectionOptions ){\r\n    const { model } = collection;\r\n    \r\n    let record : Model;\r\n\r\n    if( collection._shared ){\r\n        record = attrs instanceof model ? attrs : <Model>model.create( attrs, options );\r\n\r\n        if( collection._shared & ItemsBehavior.listen ){\r\n            on( record, record._changeEventName, collection._onChildrenChange, collection );\r\n        }\r\n    }\r\n    else{\r\n        record = attrs instanceof model ? ( options.merge ? attrs.clone() : attrs ) : <Model>model.create( attrs, options );\r\n\r\n        if( record._owner ){\r\n            if( record._owner !== collection ){\r\n                _aquire( collection, record.clone() );\r\n                const errors = collection._aggregationError || ( collection._aggregationError = [] );\r\n                errors.push( record );\r\n            }\r\n        }\r\n        else{\r\n            _aquire( collection, record );   \r\n        }\r\n    }    \r\n\r\n    // Subscribe for events...\r\n    const { _itemEvents } = collection;\r\n    _itemEvents && _itemEvents.subscribe( collection, record );\r\n\r\n    return record;\r\n}\r\n\r\n/** @private */\r\nexport function free( owner : CollectionCore, child : Model, unset? : boolean ) : void {\r\n    if( owner._shared ){\r\n        if( owner._shared & ItemsBehavior.listen ){\r\n            off( child, child._changeEventName, owner._onChildrenChange, owner );\r\n        }\r\n    }\r\n    else{\r\n        _free( owner, child );\r\n        unset || child.dispose();\r\n    }\r\n\r\n    const { _itemEvents } = owner;\r\n    _itemEvents && _itemEvents.unsubscribe( owner, child );\r\n}\r\n\r\n/** @private */\r\nexport function freeAll( collection : CollectionCore, children : Model[] ) : Model[] {\r\n    for( let child of children ){\r\n        free( collection, child );\r\n    }\r\n\r\n    return children;\r\n}\r\n\r\n/**\r\n * Silently sort collection, if its required. Returns true if sort happened.\r\n * @private\r\n */   \r\nexport function sortElements( collection : CollectionCore, options : CollectionOptions ) : boolean {\r\n    let { _comparator } = collection;\r\n    if( _comparator && options.sort !== false ){\r\n        collection.models.sort( _comparator );\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**********************************\r\n * Collection Index\r\n * @private \r\n */\r\nexport interface IdIndex {\r\n    [ id : string ] : Model\r\n}\r\n\r\n/** @private Add record */ \r\nexport function addIndex( index : IdIndex, model : Model ) : void {\r\n    index[ model.cid ] = model;\r\n    var id             = model.id;\r\n    \r\n    if( id || ( id as any ) === 0 ){\r\n        index[ id ] = model;\r\n    }\r\n}\r\n\r\n/** @private Remove record */ \r\nexport function removeIndex( index : IdIndex, model : Model ) : void {\r\n    delete index[ model.cid ];\r\n    var id = model.id;\r\n    if( id || ( id as any ) === 0 ){\r\n        delete index[ id ];\r\n    }\r\n}\r\n\r\nexport function updateIndex( index : IdIndex, model : Model ){\r\n    delete index[ model.previous( model.idAttribute ) ];\r\n\r\n    const { id } = model;\r\n    id == null || ( index[ id ] = model );\r\n}\r\n\r\n/***\r\n * In Collections, transactions appears only when\r\n * add remove or change events might be emitted.\r\n * reset doesn't require transaction.\r\n * \r\n * Transaction holds information regarding events, and knows how to emit them.\r\n * \r\n * Two major optimization cases.\r\n * 1) Population of an empty collection\r\n * 2) Update of the collection (no or little changes) - it's crucial to reject empty transactions.\r\n */\r\n\r\n\r\n// Transaction class. Implements two-phase transactions on object's tree.\r\n/** @private */ \r\nexport class CollectionTransaction implements Transaction {\r\n    // open transaction\r\n    constructor(    public object : CollectionCore,\r\n                    public isRoot : boolean,\r\n                    public added : Model[],\r\n                    public removed : Model[],\r\n                    public nested : Transaction[],\r\n                    public sorted : boolean ){}\r\n\r\n    // commit transaction\r\n    commit( initiator? : Transactional ){\r\n        const { nested, object } = this,\r\n              { _isDirty } = object;\r\n\r\n        // Commit all nested transactions...\r\n        for( let transaction of nested ){\r\n            transaction.commit( object );\r\n        }\r\n\r\n        if( object._aggregationError ){\r\n            logAggregationError( object, _isDirty );\r\n        }\r\n\r\n        // Just trigger 'change' on collection, it must be already triggered for models during nested commits.\r\n        // ??? TODO: do it in nested transactions loop? This way appears to be more correct. \r\n        for( let transaction of nested ){\r\n            trigger2( object, 'change', transaction.object, _isDirty );\r\n        }\r\n\r\n        // Notify listeners on attribute changes...\r\n        const { added, removed } = this;\r\n\r\n        // Trigger `add` events for both model and collection.\r\n        for( let record of added ){\r\n            trigger3( record, 'add', record, object, _isDirty );\r\n            trigger3( object, 'add', record, object, _isDirty );\r\n        }\r\n\r\n        // Trigger `remove` events for both model and collection.\r\n        for( let record of removed ){\r\n            trigger3( record, 'remove', record, object, _isDirty );\r\n            trigger3( object, 'remove', record, object, _isDirty );\r\n        }\r\n\r\n        if( this.sorted ){\r\n            trigger2( object, 'sort', object, _isDirty );\r\n        }\r\n\r\n        if( added.length || removed.length ){\r\n            trigger2( object, 'update', object, _isDirty );\r\n        }\r\n\r\n        this.isRoot && commit( object, initiator );\r\n    }\r\n}\r\n\r\nexport function logAggregationError( collection : CollectionCore, options : TransactionOptions ){\r\n    collection._log( 'warn', 'Type-R:InvalidOwner', 'added records already have an owner and were cloned. Use explicit record.clone() to dismiss this warning.', collection._aggregationError, options.logger );\r\n    collection._aggregationError = void 0;\r\n}","import { Model } from '../model';\r\nimport { Transaction, transactionApi } from '../transactions';\r\nimport { addIndex, CollectionCore, CollectionOptions, CollectionTransaction, convertAndAquire, logAggregationError, sortElements, updateIndex } from './commons';\r\n\r\nconst { begin, commit, markAsDirty } = transactionApi;\r\n\r\nexport interface AddOptions extends CollectionOptions {\r\n    at? : number \r\n}\r\n\r\n/** @private */\r\nexport function addTransaction( collection : CollectionCore, items : any[], options : AddOptions, merge? : boolean ){\r\n    const isRoot = begin( collection ),\r\n          nested : Transaction[]= [];\r\n\r\n    var added = appendElements( collection, items, nested, options, merge );\r\n\r\n    if( added.length || nested.length ){\r\n        let needSort = sortOrMoveElements( collection, added, options );\r\n        if( markAsDirty( collection, options ) ){\r\n            return new CollectionTransaction( collection, isRoot, added, [], nested, needSort );\r\n        }\r\n\r\n        if( collection._aggregationError ) logAggregationError( collection, options );\r\n    }\r\n\r\n    // No changes...\r\n    isRoot && commit( collection );\r\n};\r\n\r\n// Handle sort or insert at options for add operation. Reurns true if sort happened.\r\n/** @private */ \r\nfunction sortOrMoveElements( collection : CollectionCore, added : Model[], options : AddOptions ) : boolean {\r\n    let at = options.at;\r\n\r\n    // if `at` option is given, it overrides sorting option...\r\n    if( at != null ){\r\n        // Take an original collection's length. \r\n        const length = collection.models.length - added.length;\r\n\r\n        // Crazy Backbone rules about `at` index. I don't know what that guys smoke.\r\n        at = Number( at );\r\n        if( at < 0 ) at += length + 1;\r\n        if( at < 0 ) at = 0;\r\n        if( at > length ) at = length;\r\n\r\n        // Move added elements to desired position. In place.\r\n        moveElements( collection.models, at, added );\r\n        return false;\r\n    }\r\n\r\n    return sortElements( collection, options );\r\n}\r\n\r\n/** @private */\r\nfunction moveElements( source : any[], at : number, added : any[] ) : void {\r\n    for( var j = source.length - 1, i = j - added.length; i >= at; i--, j-- ){\r\n        source[ j ] = source[ i ];\r\n    }\r\n\r\n    for( i = 0, j = at; i < added.length; i++, j++ ){\r\n        source[ j ] = added[ i ];\r\n    }\r\n}\r\n\r\n// append data to model and index\r\n/** @private */\r\nfunction appendElements( collection : CollectionCore, a_items : any[], nested : Transaction[], a_options : AddOptions, forceMerge : boolean ){\r\n    var { _byId, models } = collection,\r\n        merge       = ( forceMerge || a_options.merge ) && !collection._shared,\r\n        parse       = a_options.parse,\r\n        idAttribute = collection.model.prototype.idAttribute,\r\n        prevLength = models.length;\r\n\r\n    for( const item of a_items ){\r\n        let model = item ? _byId[ item[ idAttribute ] ] || _byId[ item.cid ] : null;\r\n\r\n        if( model ){\r\n            if( merge && item !== model ){\r\n                var attrs = item.attributes || item;\r\n                const transaction = model._createTransaction( attrs, a_options );\r\n                transaction && nested.push( transaction );\r\n\r\n                if( model.hasChanged( idAttribute ) ){\r\n                    updateIndex( _byId, model );\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            model = convertAndAquire( collection, item, a_options );\r\n            models.push( model );\r\n            addIndex( _byId, model );\r\n        }\r\n    }\r\n\r\n    return models.slice( prevLength );\r\n}\r\n","import { Model } from '../model'\r\n\r\nexport type Predicate<R extends Model> = ( ( val : R, key? : number ) => boolean ) | Partial<Omit<R,'$'>>;\r\n\r\n/**\r\n * Optimized array methods.\r\n */\r\nexport abstract class ArrayMixin<R extends Model> {\r\n    models : R[]\r\n    abstract get( modelOrId : string | Partial<R> ) : R;\r\n\r\n    /**\r\n     * Map and optionally filter the collection.\r\n     * @param mapFilter filter an element out if `undefined` is returned \r\n     * @param context optional `this` for `mapFilter`\r\n     */\r\n    map<T>( mapFilter : ( val : R, key? : number ) => T, context? : any ) : T[]{\r\n        const { models } = this,\r\n            { length } = models,\r\n            res = Array( length ),\r\n            fun = context ? mapFilter.bind( context ) : mapFilter;\r\n\r\n        for( var i = 0, j = 0; i < length; i++ ){\r\n            const val = fun( models[ i ], i );\r\n            val === void 0 || ( res[ j++ ] = val );\r\n        }\r\n\r\n        if( i !== j ){\r\n            res.length = j;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Iterate through the collection.\r\n     * @param context optional `this` for `iteratee`.\r\n     */\r\n    each<T>( fun : ( val : R, key? : number ) => any, context? : any ) : void {\r\n        const { models } = this,\r\n            { length } = models,\r\n            iteratee = context ? fun.bind( context ) : fun;\r\n\r\n        for( let i = 0; i < length; i++ ){\r\n            iteratee( models[ i ], i );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate through collection optionally returning the value.\r\n     * @param doWhile break the loop if anything but `undefined` is returned, and return this value.\r\n     * @param context optional `this` for `doWhile`.\r\n     */\r\n    firstMatch<T>( doWhile : ( val : R, key? : number ) => T ) : T\r\n    firstMatch<T, C>( doWhile : ( this : C, val : R, key? : number ) => T, context : C ) : T\r\n    firstMatch<T>( doWhile : ( val : R, key? : number ) => T, context? : any ) : T {\r\n        const { models } = this,\r\n            { length } = models,\r\n            iteratee = context ? doWhile.bind( context ) : doWhile;\r\n\r\n        for( let i = 0; i < length; i++ ){\r\n            const res = iteratee( models[ i ], i );\r\n            if( res !== void 0 ) return res;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Proxy for the `array.reduce()`\r\n     * @param iteratee \r\n     */\r\n    reduce<T>( iteratee : (previousValue: R, currentValue: R, currentIndex?: number ) => R ) : R\r\n    reduce<T>( iteratee : (previousValue: T, currentValue: R, currentIndex?: number ) => T, init? : any ) : T\r\n    reduce<T>( iteratee : (previousValue: any, currentValue: any, currentIndex?: number ) => any, init? : any ) : T | R {\r\n        return init === void 0 ? this.models.reduce( iteratee ) : this.models.reduce( iteratee, init );\r\n    }\r\n\r\n    // Slice out a sub-array of models from the collection.\r\n    slice( begin? : number, end? : number ) : R[] {\r\n        return this.models.slice( begin, end );\r\n    }\r\n  \r\n    indexOf( modelOrId : string | Partial<R> ) : number {\r\n        return this.models.indexOf( this.get( modelOrId ) );\r\n    }\r\n\r\n    includes( idOrObj : string | Partial<R> ) : boolean {\r\n        return Boolean( this.get( idOrObj ) );\r\n    }\r\n\r\n    filter( iteratee : Predicate<R>, context? : any ) : R[] {\r\n        const fun = toPredicateFunction( iteratee );\r\n        return this.map( m => fun( m ) ? m : void 0, context );\r\n    }\r\n\r\n    find( iteratee : Predicate<R>, context? : any ) : R {\r\n        const fun = toPredicateFunction( iteratee );\r\n        return this.firstMatch( m => fun( m ) ? m : void 0, context );\r\n    }\r\n\r\n    some( iteratee : Predicate<R>, context? : any ) : boolean {\r\n        return Boolean( this.find( iteratee, context ) );\r\n    }\r\n\r\n    forEach( iteratee : ( val : R, key? : number ) => void, context? : any ) : void {\r\n        this.each( iteratee, context );\r\n    }\r\n\r\n    values() : IterableIterator<R> {\r\n        return this.models.values();\r\n    }\r\n\r\n    entries() : IterableIterator<[ number, R ]>{\r\n        return this.models.entries();\r\n    }\r\n\r\n    every( iteratee : Predicate<R>, context? : any ) : boolean {\r\n        const fun = toPredicateFunction( iteratee );\r\n        return this.firstMatch( m => fun( m ) ? void 0 : false, context ) === void 0;\r\n    }\r\n\r\n    pluck<K extends keyof R>( key : K ) : R[K][] {\r\n        return this.map( model => model[ key ] );\r\n    }\r\n\r\n    first() : R { return this.models[ 0 ]; }\r\n\r\n    last() : R { return this.models[ this.models.length - 1 ]; }\r\n\r\n    at( a_index : number ) : R {\r\n        const index = a_index < 0 ? a_index + this.models.length : a_index;    \r\n        return this.models[ index ];\r\n    }\r\n\r\n    groupBy<A>( attr : keyof R | (( m : R ) => string )) : { [ key : string ] : R[] };\r\n    groupBy<A>(\r\n        attr : keyof R | (( m : R ) => string ),\r\n        a_reducer : ( acc : A, model? : R, key? : string ) => A\r\n    ) : { [ key : string ] : A };\r\n    groupBy<A>(\r\n        attr : keyof R | (( m : R ) => string ),\r\n        a_reducer? : ( acc : A, model? : R, key? : string ) => A\r\n    ){\r\n        const map : any = typeof attr === 'string' ?\r\n            x => x[ attr ] :\r\n            attr;\r\n\r\n        const reducer = a_reducer || defaultGrouping;\r\n\r\n        const results = {};\r\n\r\n        for( let model of this.models ){\r\n            const key = map( model );\r\n            if( key != null ){\r\n                results[ key ] = reducer( results[ key ], model, key );\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n}\r\n\r\nconst defaultGrouping = ( acc = [], x ) => ( acc.push( x ), acc );\r\n\r\nconst noOp = x => x;\r\n\r\nfunction toPredicateFunction<R extends Model>( iteratee : Predicate<R> ){\r\n    if( iteratee == null ) return noOp;\r\n\r\n    switch( typeof iteratee ){\r\n        case 'function' : return iteratee;\r\n        case 'object' :\r\n            const keys = Object.keys( iteratee );\r\n            \r\n            return x => {\r\n                for( let key of keys ){\r\n                    if( iteratee[ key ] !== x[ key ] )\r\n                        return false;\r\n                }\r\n\r\n                return true;\r\n            }\r\n        default : throw new Error( 'Invalid iteratee' );\r\n    }\r\n}","/*************\r\n * Remove items from collections.\r\n * \r\n * Cannot be a part of two-phase transaction on object tree.\r\n * Can be executed in the scope of ad-hoc transaction or from the trigger, though.\r\n *\r\n * Implemented with low-level API. \r\n * Most frequent operation - single element remove. Thus, it have the fast-path.\r\n */\r\n\r\nimport { eventsApi } from '@type-r/mixture';\r\nimport { Model } from '../model';\r\nimport { transactionApi, TransactionOptions } from '../transactions';\r\nimport { CollectionCore, CollectionTransaction, free, removeIndex } from './commons';\r\n\r\nconst { trigger2, trigger3 } = eventsApi,\r\n    { markAsDirty, begin, commit } = transactionApi;\r\n\r\n/** @private */\r\nexport function removeOne( collection : CollectionCore, el : Model | {} | string, options : TransactionOptions ) : Model {\r\n    var model : Model = collection.get( el );\r\n\r\n    if( model ){\r\n        const isRoot = begin( collection ),\r\n              models = collection.models;\r\n\r\n        // Remove model form the collection. \r\n        models.splice( models.indexOf( model ), 1 );\r\n        removeIndex( collection._byId, model );\r\n        \r\n        // Mark transaction as dirty. \r\n        const notify = markAsDirty( collection, options );\r\n\r\n        // Send out events.\r\n        if( notify ){\r\n            trigger3( model, 'remove', model, collection, options );\r\n            trigger3( collection, 'remove', model, collection, options );\r\n        } \r\n\r\n        free( collection, model, options.unset );\r\n\r\n        notify && trigger2( collection, 'update', collection, options );\r\n\r\n        // Commit transaction.\r\n        isRoot && commit( collection );\r\n\r\n        return model;\r\n    }\r\n};\r\n\r\n/** Optimized for removing many elements\r\n * 1. Remove elements from the index, checking for duplicates\r\n * 2. Create new models array matching index\r\n * 3. Send notifications and remove references\r\n */\r\n\r\n/** @private */\r\nexport function removeMany( collection : CollectionCore, toRemove : any[], options ){\r\n    const removed = _removeFromIndex( collection, toRemove, options.unset );\r\n    if( removed.length ){\r\n        const isRoot = begin( collection );\r\n\r\n        _reallocate( collection, removed.length );\r\n\r\n        if( markAsDirty( collection, options ) ){\r\n            const transaction = new CollectionTransaction( collection, isRoot, [], removed, [], false );\r\n            transaction.commit();\r\n        }\r\n        else{\r\n            // Commit transaction.\r\n            isRoot && commit( collection );\r\n        }\r\n    }\r\n\r\n    return removed;\r\n};\r\n\r\n// remove models from the index...\r\n/** @private */\r\nfunction _removeFromIndex( collection, toRemove, unset : boolean ){\r\n    var removed = Array( toRemove.length ),\r\n        _byId   = collection._byId;\r\n\r\n    for( var i = 0, j = 0; i < toRemove.length; i++ ){\r\n        var model = collection.get( toRemove[ i ] );\r\n        if( model ){\r\n            removed[ j++ ] = model;\r\n            removeIndex( _byId, model );\r\n            free( collection, model, unset );\r\n        }\r\n    }\r\n\r\n    removed.length = j;\r\n\r\n    return removed;\r\n}\r\n\r\n// Allocate new models array removing models not present in the index.\r\n/** @private */\r\nfunction _reallocate( collection, removed ){\r\n    var prev   = collection.models,\r\n        models = collection.models = Array( prev.length - removed ),\r\n        _byId = collection._byId;\r\n\r\n    for( var i = 0, j = 0; i < prev.length; i++ ){\r\n        var model = prev[ i ];\r\n\r\n        if( _byId[ model.cid ] ){\r\n            models[ j++ ] = model;\r\n        }\r\n    }\r\n\r\n    models.length = j;\r\n}","import { Model } from '../model';\r\nimport { Transaction, transactionApi } from '../transactions';\r\nimport { addIndex, CollectionCore, CollectionOptions, CollectionTransaction, convertAndAquire, Elements, free, freeAll, IdIndex, logAggregationError, sortElements } from './commons';\r\n\r\nconst { begin, commit, markAsDirty } = transactionApi;\r\n\r\n/** @private */\r\nconst silentOptions = { silent : true };\r\n\r\n/** @private */\r\nexport function emptySetTransaction( collection : CollectionCore, items : Elements, options : CollectionOptions, silent? : boolean ){\r\n    const isRoot = begin( collection );\r\n\r\n    const added = _reallocateEmpty( collection, items, options );\r\n\r\n    if( added.length ){\r\n        const needSort = sortElements( collection, options );\r\n\r\n        if( markAsDirty( collection, silent ? silentOptions : options ) ){\r\n            // 'added' is the reference to this.models. Need to copy it.\r\n            return new CollectionTransaction( collection, isRoot, added.slice(), [], [], needSort );\r\n        }\r\n\r\n        if( collection._aggregationError ) logAggregationError( collection, options );\r\n    }\r\n\r\n    // No changes...\r\n    isRoot && commit( collection );\r\n};\r\n\r\n/** @private */\r\nexport function setTransaction( collection, items, options ){\r\n    const isRoot = begin( collection ),\r\n          nested = [];\r\n\r\n    var previous = collection.models,\r\n        added    = _reallocate( collection, items, nested, options );\r\n\r\n    const reusedCount = collection.models.length - added.length,\r\n          removed = reusedCount < previous.length ? (\r\n                        reusedCount ? _garbageCollect( collection, previous ) :\r\n                                        freeAll( collection, previous )\r\n                    ) : [];                    \r\n    \r\n    const addedOrChanged = nested.length || added.length,\r\n          // As we are reallocating models array, it needs to be sorted even if there are no changes.\r\n          sorted = ( sortElements( collection, options ) && addedOrChanged ) || added.length || options.sorted;\r\n\r\n    if( addedOrChanged || removed.length || sorted ){\r\n        if( markAsDirty( collection, options ) ){ \r\n            return new CollectionTransaction( collection, isRoot, added, removed, nested, sorted );\r\n        }\r\n\r\n        if( collection._aggregationError ) logAggregationError( collection, options );\r\n    }\r\n\r\n    isRoot && commit( collection );\r\n};\r\n\r\n// Remove references to all previous elements, which are not present in collection.\r\n// Returns an array with removed elements.\r\n/** @private */\r\nfunction _garbageCollect( collection : CollectionCore, previous : Model[] ) : Model[]{\r\n    const { _byId }  = collection,\r\n          removed = [];\r\n\r\n    // Filter out removed models and remove them from the index...\r\n    for( let record of previous ){\r\n        if( !_byId[ record.cid ] ){\r\n            removed.push( record );\r\n            free( collection, record );\r\n        }\r\n    }\r\n\r\n    return removed;\r\n}\r\n\r\n// reallocate model and index\r\n/** @private */\r\nfunction _reallocate( collection : CollectionCore, source : any[], nested : Transaction[], options ){\r\n    var models      = Array( source.length ),\r\n        _byId : IdIndex = {},\r\n        merge       = ( options.merge == null ? true : options.merge ) && !collection._shared,\r\n        _prevById   = collection._byId,\r\n        prevModels  = collection.models, \r\n        idAttribute = collection.model.prototype.idAttribute,\r\n        toAdd       = [],\r\n        orderKept   = true;\r\n\r\n    // for each item in source set...\r\n    for( var i = 0, j = 0; i < source.length; i++ ){\r\n        var item  = source[ i ],\r\n            model : Model = null;\r\n\r\n        if( item ){\r\n            var id  = item[ idAttribute ],\r\n                cid = item.cid;\r\n\r\n            if( _byId[ id ] || _byId[ cid ] ) continue;\r\n\r\n            model = _prevById[ id ] || _prevById[ cid ];\r\n        }\r\n\r\n        if( model ){\r\n            if( merge && item !== model ){\r\n                if( orderKept && prevModels[ j ] !== model ) orderKept = false;\r\n\r\n                var attrs = item.attributes || item;\r\n                const transaction = model._createTransaction( attrs, options );\r\n                transaction && nested.push( transaction );\r\n            }\r\n        }\r\n        else{\r\n            model = convertAndAquire( collection, item, options );\r\n            toAdd.push( model );\r\n        }\r\n\r\n        models[ j++ ] = model;\r\n        addIndex( _byId, model );\r\n    }\r\n\r\n    models.length = j;\r\n    collection.models   = models;\r\n    collection._byId    = _byId;\r\n\r\n    if( !orderKept ) options.sorted = true;\r\n\r\n    return toAdd;\r\n}\r\n\r\n/** @private */\r\nfunction _reallocateEmpty( self, source, options ){\r\n    var len         = source ? source.length : 0,\r\n        models      = Array( len ),\r\n        _byId : IdIndex = {},\r\n        idAttribute = self.model.prototype.idAttribute;\r\n\r\n    for( var i = 0, j = 0; i < len; i++ ){\r\n        var src = source[ i ];\r\n\r\n        if( src && ( _byId[ src[ idAttribute ] ] || _byId[ src.cid ] ) ){\r\n            continue;\r\n        }\r\n\r\n        var model = convertAndAquire( self, src, options );\r\n        models[ j++ ] = model;\r\n        addIndex( _byId, model );\r\n    }\r\n\r\n    models.length = j;\r\n    self._byId    = _byId;\r\n\r\n    return self.models = models;\r\n}","import { Linked } from '@linked/value';\r\nimport { define, definitions, EventMap, eventsApi, EventsDefinition, Logger, logger, LogLevel, Mixable, mixinRules, mixins, TheType } from '@type-r/mixture';\r\nimport { IOPromise, startIO } from '../io-tools';\r\nimport { AggregatedType, Model, SharedType, shared, AnonymousModelConstructor, attributes } from '../model';\r\nimport { CloneOptions, ItemsBehavior, Transactional, TransactionalDefinition, transactionApi, TransactionOptions } from '../transactions';\r\nimport { AddOptions, addTransaction } from './add';\r\nimport { ArrayMixin } from './arrayMethods';\r\nimport { CollectionCore, CollectionTransaction, Elements, free, sortElements, updateIndex } from './commons';\r\nimport { removeMany, removeOne } from './remove';\r\nimport { emptySetTransaction, setTransaction } from './set';\r\n\r\nconst { trigger2 } = eventsApi,\r\n    { begin, commit, markAsDirty } = transactionApi;\r\n\r\nlet _count = 0;\r\n\r\nexport type GenericComparator = string | ( ( x : Model ) => number ) | ( ( a : Model, b : Model ) => number ); \r\n\r\nexport interface CollectionOptions extends TransactionOptions {\r\n    comparator? : GenericComparator\r\n    model? : typeof Model\r\n}\r\n\r\nexport interface CollectionDefinition extends TransactionalDefinition {\r\n    model? : typeof Model,\r\n    itemEvents? : EventsDefinition\r\n    _itemEvents? : EventMap\r\n}\r\n\r\nclass CollectionRefsType extends SharedType {\r\n    static defaultValue = [];\r\n}\r\n\r\nexport interface CollectionConstructor<R extends Model = Model > extends TheType<typeof Collection> {\r\n    new ( records? : ElementsArg<R>, options?: CollectionOptions ) : Collection<R>\r\n    prototype : Collection<R>\r\n    Refs : CollectionConstructor<R>\r\n};\r\n\r\ntype CollectionOf<M extends typeof Model> = M['Collection'] extends CollectionConstructor<InstanceType<M>> ? M['Collection'] : CollectionConstructor<InstanceType<M>>;\r\n\r\n@define({\r\n    // Default client id prefix \r\n    cidPrefix : 'c',\r\n    model : Model,\r\n    _changeEventName : 'changes',\r\n    _aggregationError : null\r\n})\r\n@mixins( ArrayMixin )\r\n@definitions({\r\n    comparator : mixinRules.value,\r\n    model : mixinRules.protoValue,\r\n    itemEvents : mixinRules.merge\r\n})\r\nexport class Collection< R extends Model = Model> extends Transactional implements CollectionCore, Iterable<R> {\r\n    /** @internal */\r\n    _shared : number\r\n    /** @internal */\r\n    _aggregationError : R[]\r\n\r\n    /**\r\n     * EXPERIMENTAL notation to extract proper collection type from the model in TypeScript.\r\n     * \r\n     * attrName : Collection.of( User );\r\n     * \r\n     * const users = new ( Collection.of( User ) )\r\n     */\r\n    static of<M extends typeof Model>( Ctor : M ) : CollectionOf<M>;\r\n    static of<M extends object>( spec : M ) : CollectionOf<AnonymousModelConstructor<M>>;\r\n    static of<M extends typeof Model>( Ctor : M ) : CollectionOf<M> {\r\n        return typeof Ctor === 'function' ?\r\n            Ctor.Collection as any :\r\n            attributes( Ctor ).Collection;\r\n    }\r\n\r\n    /**\r\n     * EXPERIMENTAL notation to extract proper collection type from the model in TypeScript.\r\n     * \r\n     * attrName : Collection.ofRefs( User );\r\n     * \r\n     * const users = new ( Collection.ofRefs( User ) )\r\n     */\r\n    static ofRefs<M extends typeof Model>( Ctor : M ) : CollectionOf<M> {\r\n        return Ctor.Collection.Refs as any;\r\n    }\r\n\r\n\r\n    static Subset : typeof Collection\r\n    static Refs : any\r\n    static refsTo = shared;\r\n\r\n    /** @internal */\r\n    static _SubsetOf : typeof Collection\r\n    \r\n    createSubset( models : ElementsArg<R>, options? : CollectionOptions) : Collection<R>{\r\n        throw new ReferenceError( 'Failed dependency injection' )\r\n    }\r\n\r\n    static onExtend( BaseClass : typeof Transactional ){\r\n        // Cached subset collection must not be inherited.\r\n        const Ctor = this;\r\n        this._SubsetOf = null;\r\n\r\n        function RefsCollection( a, b, listen? ){\r\n            Ctor.call( this, a, b, ItemsBehavior.share | ( listen ? ItemsBehavior.listen : 0 ) );\r\n        }\r\n\r\n        Mixable.mixins.populate( RefsCollection );\r\n        RefsCollection.create = Collection.create;\r\n        \r\n        RefsCollection.prototype = this.prototype;\r\n        RefsCollection._metatype = CollectionRefsType;\r\n\r\n        this.Refs = this.Subset = <any>RefsCollection;\r\n\r\n        Transactional.onExtend.call( this, BaseClass );\r\n    }\r\n    \r\n    static onDefine( definition : CollectionDefinition, BaseClass : any ){\r\n        if( definition.itemEvents ){\r\n            const eventsMap = new EventMap( BaseClass.prototype._itemEvents );\r\n            eventsMap.addEventsMap( definition.itemEvents );\r\n            this.prototype._itemEvents = eventsMap;\r\n        }\r\n\r\n        if( definition.comparator !== void 0 ) this.prototype.comparator = definition.comparator;\r\n\r\n        Transactional.onDefine.call( this, definition );\r\n    }\r\n    \r\n    /** @internal */\r\n    _itemEvents : EventMap\r\n\r\n    /***********************************\r\n     * Core Members\r\n     */\r\n    // Array of the records\r\n    models : R[]\r\n\r\n    // Polymorphic accessor for aggregated attribute's canBeUpdated().\r\n    /** @internal */\r\n    get __inner_state__(){ return this.models; }\r\n\r\n    // Index by id and cid\r\n    /** @internal */\r\n    _byId : { [ id : string ] : R }\r\n\r\n    set comparator( x : GenericComparator ){\r\n\r\n        switch( typeof x ){\r\n            case 'string' :\r\n                this._comparator = ( a, b ) => {\r\n                    const aa = a[ <string>x ], bb = b[ <string>x ];\r\n                    if( aa === bb ) return 0;\r\n                    return aa < bb ? -1 : + 1;\r\n                } \r\n                break;\r\n            case 'function' :\r\n                if( x.length === 1 ){\r\n                    this._comparator = ( a, b ) => {\r\n                        const aa = (<any>x).call( this, a ), bb = (<any>x).call( this, b );\r\n                        if( aa === bb ) return 0;\r\n                        return aa < bb ? -1 : + 1;\r\n                    }\r\n                }\r\n                else{\r\n                    this._comparator = ( a, b ) => (<any>x).call( this, a, b );\r\n                }\r\n                break;\r\n                \r\n            default :\r\n                this._comparator = null;\r\n        }\r\n    }\r\n    \r\n    // TODO: Improve typing\r\n    getStore() : Transactional {\r\n        return this._store || ( this._store = this._owner ? this._owner.getStore() : this._defaultStore );\r\n    }\r\n\r\n    /** @internal */\r\n    _store : Transactional\r\n\r\n    get comparator(){ return this._comparator; }\r\n\r\n    /** @internal */\r\n    _comparator : ( a : R, b : R ) => number\r\n\r\n    /** @internal */\r\n    _onChildrenChange( record : R, options : TransactionOptions = {}, initiator? : Transactional ){\r\n        // Ignore updates from nested transactions.\r\n        if( initiator === this ) return;\r\n\r\n        const { idAttribute } = this;\r\n\r\n        if( record.hasChanged( idAttribute ) ){\r\n            updateIndex( this._byId, record );\r\n        }\r\n\r\n        const isRoot = begin( this );\r\n\r\n        if( markAsDirty( this, options ) ){\r\n            // Forward change event from the record.\r\n            trigger2( this, 'change', record, options )\r\n        }\r\n\r\n        isRoot && commit( this );\r\n    }\r\n\r\n    get( objOrId : string | { id? : string, cid? : string } ) : R {\r\n        if( objOrId == null ) return;\r\n\r\n        if( typeof objOrId === 'object' ){\r\n            const id = objOrId[ this.idAttribute ];\r\n            return ( id !== void 0 && this._byId[ id ] ) || this._byId[ objOrId.cid ];\r\n        }\r\n        else{\r\n            return this._byId[ objOrId ];\r\n        }        \r\n    }\r\n\r\n    [ Symbol.iterator ]() : IterableIterator<R> {\r\n        return this.models[ Symbol.iterator ]();\r\n    }\r\n\r\n    // Loop through the members in the scope of transaction.\r\n    // Transactional version of each()\r\n    updateEach( iteratee : ( val : R, key? : number ) => void ){\r\n        const isRoot = transactionApi.begin( this );\r\n        this.each( iteratee );\r\n        isRoot && transactionApi.commit( this );\r\n    }\r\n\r\n    /** @internal */\r\n    _validateNested( errors : {} ) : number {\r\n        // Don't validate if not aggregated.\r\n        if( this._shared ) return 0;\r\n\r\n        let count = 0;\r\n\r\n        this.each( record => {\r\n            const error = record.validationError;\r\n            if( error ){\r\n                errors[ record.cid ] = error;\r\n                count++;\r\n            }\r\n        });\r\n\r\n        return count;\r\n    }\r\n\r\n    model : typeof Model\r\n\r\n    // idAttribute extracted from the model type.\r\n    idAttribute : string\r\n\r\n    constructor( records? : ElementsArg<R>, options : CollectionOptions = {}, shared? : number ){\r\n        super( _count++ );\r\n        this.models = [];\r\n        this._byId = {};\r\n        \r\n        this.comparator  = this.comparator;\r\n\r\n        if( options.comparator !== void 0 ){\r\n            this.comparator = options.comparator;\r\n            options.comparator = void 0;\r\n        }\r\n        \r\n        this.model       = this.model;\r\n        \r\n        if( options.model ){\r\n            this.model = options.model;\r\n            options.model = void 0;\r\n        }\r\n\r\n        this.idAttribute = this.model.prototype.idAttribute; //TODO: Remove?\r\n\r\n        this._shared = shared || 0;\r\n\r\n        if( records ){\r\n            const elements = toElements( this, records, options );\r\n            emptySetTransaction( this, elements, options, true );\r\n        }\r\n\r\n        this.initialize.apply( this, arguments );\r\n\r\n        if( this._localEvents ) this._localEvents.subscribe( this, this );\r\n    }\r\n\r\n    initialize(){}\r\n\r\n    // Deeply clone collection, optionally setting new owner.\r\n    clone( options : CloneOptions = {} ) : this {\r\n        const models = this._shared & ItemsBehavior.share ? this.models : this.map( model => model.clone() ),\r\n              copy : this = new (<any>this.constructor)( models, { model : this.model, comparator : this.comparator }, this._shared );\r\n        \r\n        if( options.pinStore ) copy._defaultStore = this.getStore();\r\n        \r\n        return copy;\r\n    }\r\n\r\n    toJSON( options? : object ) : any {\r\n        return this.map( model => model.toJSON( options ) );\r\n    }\r\n\r\n    // Apply bulk in-place object update in scope of ad-hoc transaction \r\n    set( elements : ElementsArg<R> = [], options : TransactionOptions = {} ) : this {\r\n        if( (<any>options).add !== void 0 ){\r\n            this._log( 'warn', \"Type-R:InvalidOption\", \"Collection.set doesn't support 'add' option, behaving as if options.add === true.\", options );\r\n        }\r\n\r\n        // Handle reset option here - no way it will be populated from the top as nested transaction.\r\n        if( options.reset ){\r\n            this.reset( elements, options )\r\n        }\r\n        else{\r\n            const transaction = this._createTransaction( elements, options );\r\n            transaction && transaction.commit();\r\n        } \r\n\r\n        return this;    \r\n    }\r\n\r\n        /**\r\n     * Enable or disable live updates.\r\n     * \r\n     * `true` enables full collection synchronization.\r\n     * `false` cancel live updates.\r\n     * `json => true | false` - filter updates\r\n     */\r\n    liveUpdates( enabled : LiveUpdatesOption ) : IOPromise<this> {\r\n        if( enabled ){\r\n            this.liveUpdates( false );\r\n\r\n            const filter = typeof enabled === 'function' ? enabled : () => true;\r\n\r\n            this._liveUpdates = {\r\n                updated : json => {\r\n                    filter( json ) && this.add( json, { parse : true, merge : true } );\r\n                },\r\n\r\n                removed : id => this.remove( id )\r\n            };\r\n\r\n            return this.getEndpoint().subscribe( this._liveUpdates, this ).then( () => this );\r\n        }\r\n        else{\r\n            if( this._liveUpdates ){\r\n                this.getEndpoint().unsubscribe( this._liveUpdates, this );\r\n                this._liveUpdates = null;\r\n            }\r\n\r\n            // TODO: Return the resolved promise.\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    _liveUpdates : object\r\n\r\n    fetch( a_options : { liveUpdates? : LiveUpdatesOption } & TransactionOptions & { [ key : string ] : any } = {} ) : IOPromise<this> {\r\n        const options = { parse : true, ...a_options },\r\n            endpoint = this.getEndpoint();\r\n\r\n        return startIO(\r\n            this,\r\n            endpoint.list( options, this ),\r\n            options,\r\n\r\n            json => {\r\n                let result : any = this.set( json, { parse : true, ioMethod : 'fetch', ...options } as TransactionOptions );\r\n                \r\n                if( options.liveUpdates ){\r\n                    result = this.liveUpdates( options.liveUpdates );\r\n                }\r\n\r\n                return result;\r\n            }\r\n        );\r\n    }\r\n\r\n    dispose() : void {\r\n        if( this._disposed ) return;\r\n\r\n        const aggregated = !this._shared;\r\n\r\n        for( let record of this.models ){\r\n            free( this, record );\r\n\r\n            if( aggregated ) record.dispose();\r\n        }\r\n\r\n        this.liveUpdates( false );\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    reset( a_elements? : ElementsArg<R>, options : TransactionOptions = {} ) : R[] {\r\n        const isRoot = begin( this ),\r\n              previousModels = this.models;\r\n\r\n        // Make all changes required, but be silent.\r\n        if( a_elements ){            \r\n            emptySetTransaction( this, toElements( this, a_elements, options ), options, true );\r\n        }\r\n        else{\r\n            this._byId = {};\r\n            this.models = [];\r\n        }\r\n\r\n        markAsDirty( this, options );\r\n\r\n        options.silent || trigger2( this, 'reset', this, { previousModels, ...options } );\r\n\r\n        // Dispose models which are not in the updated collection.\r\n        const { _byId } = this;\r\n        \r\n        for( let toDispose of previousModels ){\r\n            _byId[ toDispose.cid ] || free( this, toDispose );\r\n        }\r\n\r\n        isRoot && commit( this );\r\n        return this.models;\r\n    }\r\n\r\n    // Add elements to collection.\r\n    add( a_elements : ElementsArg<R> , options : AddOptions = {} ){\r\n        const elements = toElements( this, a_elements, options ),\r\n              transaction = this.models.length ?\r\n                    addTransaction( this, elements, options ) :\r\n                    emptySetTransaction( this, elements, options );\r\n\r\n        if( transaction ){\r\n            transaction.commit();\r\n            return transaction.added;\r\n        }\r\n    }\r\n\r\n    // Remove elements. \r\n    remove( recordsOrIds : any, options : CollectionOptions = {} ) : R[] | R {\r\n        if( recordsOrIds ){\r\n            return Array.isArray( recordsOrIds ) ?\r\n                        removeMany( this, recordsOrIds, options ) as R[]:\r\n                        removeOne( this, recordsOrIds, options ) as R;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    $includes( idOrObj : R ) : Linked<boolean> {\r\n        return new LinkedIncludes( this, idOrObj );\r\n    }\r\n\r\n    // Apply bulk object update without any notifications, and return open transaction.\r\n    // Used internally to implement two-phase commit.   \r\n    /** @internal */\r\n    _createTransaction( a_elements : ElementsArg<R>, options : TransactionOptions = {} ) : CollectionTransaction | void {\r\n        const elements = toElements( this, a_elements, options );\r\n\r\n        if( this.models.length ){\r\n            return options.remove === false ?\r\n                        addTransaction( this, elements, options, true ) :\r\n                        setTransaction( this, elements, options );\r\n        }\r\n        else{\r\n            return emptySetTransaction( this, elements, options );\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    static _metatype = AggregatedType;\r\n\r\n    /***********************************\r\n     * Collection manipulation methods\r\n     */\r\n\r\n    sort( options : TransactionOptions = {} ) : this {\r\n        if( sortElements( this, options ) ){\r\n            const isRoot = begin( this );\r\n            \r\n            if( markAsDirty( this, options ) ){\r\n                trigger2( this, 'sort', this, options );\r\n            }\r\n\r\n            isRoot && commit( this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Remove and return given model.\r\n    unset( modelOrId : R | string, options? ) : R {\r\n        const value = this.get( modelOrId );\r\n        this.remove( modelOrId, { unset : true, ...options } );\r\n        return value;\r\n    }\r\n\r\n    modelId( attrs : {} ) : any {\r\n        return attrs[ this.model.prototype.idAttribute ];\r\n    }\r\n\r\n    // Toggle model in collection.\r\n    toggle( model : R, a_next? : boolean ) : boolean {\r\n        var prev = Boolean( this.get( model ) ),\r\n            next = a_next === void 0 ? !prev : Boolean( a_next );\r\n\r\n        if( prev !== next ){\r\n            if( prev ){\r\n                this.remove( model );\r\n            }\r\n            else{\r\n                this.add( model );\r\n            }\r\n        }\r\n\r\n        return next;\r\n    }\r\n\r\n    /** @internal */\r\n    _log( level : LogLevel, topic : string, text : string, value : object, a_logger? : Logger ) : void {\r\n        ( a_logger || logger ).trigger( level, topic, `${ this.model.prototype.getClassName() }.${ this.getClassName() }: ` + text, {\r\n            Argument : value,\r\n            'Attributes spec' : this.model.prototype._attributes\r\n        });\r\n    }\r\n\r\n    getClassName() : string {\r\n        return super.getClassName() || 'Collection';\r\n    }\r\n\r\n    /***********************************\r\n     * Proxied Array methods\r\n     */\r\n\r\n    get length() : number { return this.models.length; }\r\n\r\n    // Add a model to the end of the collection.\r\n    push(model : ElementsArg<R>, options? : CollectionOptions ) {\r\n        return this.add(model, { at: this.length, ...options });\r\n    }\r\n\r\n    // Remove a model from the end of the collection.\r\n    pop( options? : CollectionOptions ) : R {\r\n        var model = this.at(this.length - 1);\r\n        this.remove(model, { unset : true, ...options });\r\n        return model;\r\n    }\r\n\r\n    // Add a model to the beginning of the collection.\r\n    unshift(model : ElementsArg<R>, options? : CollectionOptions ) {\r\n        return this.add(model, { at: 0, ...options });\r\n    }\r\n  \r\n    // Remove a model from the beginning of the collection.\r\n    shift( options? : CollectionOptions ) : R {\r\n        const model = this.at(0);\r\n        this.remove( model, { unset : true, ...options } );\r\n        return model;\r\n    }\r\n}\r\n\r\n\r\nexport interface Collection<R extends Model> extends ArrayMixin<R>{}\r\n\r\nexport type LiveUpdatesOption = boolean | ( ( x : any ) => boolean );\r\n\r\nexport type ElementsArg<R = Model> = Partial<R> | Partial<R>[]\r\n\r\n// TODO: make is safe for parse to return null (?)\r\nfunction toElements<R extends Model>( collection : Collection<R>, elements : ElementsArg<R>, options : CollectionOptions ) : Elements {\r\n    const parsed = options.parse ? collection.parse( elements, options ) : elements; \r\n    return Array.isArray( parsed ) ? parsed : [ parsed ];\r\n}\r\n\r\nModel.Collection = Collection;\r\n\r\nclass LinkedIncludes extends Linked<boolean> {\r\n    constructor(\r\n        private collection,\r\n        private model : Model ){\r\n            super( collection.get( model ) )\r\n    }\r\n\r\n    set( x : boolean ) : void {\r\n        this.collection.toggle( this.model );\r\n    }\r\n}\r\n","import { Collection } from '../collection';\r\nimport { Model } from '../model';\r\nimport { CompiledReference } from '../traversable';\r\n\r\nexport type CollectionReference = ( ( self : any ) => Collection ) | Collection | string; \r\n\r\n/** @private */\r\nexport function parseReference( collectionRef : CollectionReference ) : ( root : Model ) => Collection {\r\n    switch( typeof collectionRef ){\r\n        case 'function' :\r\n            return root => (<any>collectionRef).call( root, root );\r\n        case 'object'   :\r\n            return () => <Collection>collectionRef;\r\n        case 'string'   :\r\n            const { resolve } = new CompiledReference( <string>collectionRef );\r\n            return resolve;\r\n    }\r\n}","import { AnyType, ChainableAttributeSpec, Model, Nullable } from '../model';\r\nimport { CollectionReference, parseReference } from './commons';\r\n\r\n\r\n/********\r\n * Reference to model by id.\r\n * \r\n * Untyped attribute. Holds model id, when unresolved. When resolved, is substituted\r\n * with a real model.\r\n * \r\n * No model changes are detected and counted as owner's change. That's intentional.\r\n */\r\n\r\n/** @private */\r\ntype ModelRefValue = Model | string;\r\n\r\n/** @private */\r\nclass ModelRefType extends AnyType {\r\n    // It is always serialized as an id, whenever it's resolved or not. \r\n    toJSON( value : ModelRefValue ){\r\n        return value && typeof value === 'object' ? value.id : value;\r\n    }\r\n\r\n    // Wne \r\n    clone( value : ModelRefValue ){\r\n        return value && typeof value === 'object' ? value.id : value;\r\n    }\r\n\r\n    // Model refs by id are equal when their ids are equal.\r\n    isChanged( a : ModelRefValue, b : ModelRefValue){\r\n        var aId = a && ( (<Model>a).id == null ? a : (<Model>a).id ),\r\n            bId = b && ( (<Model>b).id == null ? b : (<Model>b).id );\r\n\r\n        return aId !== bId;\r\n    }\r\n\r\n    // Refs are always valid.\r\n    validate( model, value, name ){}\r\n}\r\n\r\nfunction theMemberOf<R extends new () => Model>( this : void, masterCollection : CollectionReference, T? : R ) : ChainableAttributeSpec<Nullable<R>> {\r\n    const getMasterCollection = parseReference( masterCollection );\r\n\r\n    const typeSpec = new ChainableAttributeSpec<R>({\r\n        value : null,\r\n        _metatype : ModelRefType\r\n    });\r\n    \r\n    return typeSpec\r\n        .get( function( objOrId : ModelRefValue, name : string ) : Model {\r\n            if( typeof objOrId === 'object' ) return objOrId;\r\n\r\n            // So, we're dealing with an id reference. Resolve it.\r\n            const collection = getMasterCollection( this );\r\n            let   record : Model = null;\r\n\r\n            // If master collection exists and is not empty...\r\n            if( collection && collection.length ){\r\n                // Silently update attribute with record from this collection.\r\n                record = collection.get( objOrId ) || null;\r\n                this.attributes[ name ] = record;\r\n\r\n                // Subscribe for events manually. delegateEvents won't be invoked.\r\n                record && this._attributes[ name ].handleChange( record, null, this, {} );\r\n            }\r\n\r\n            return record;\r\n        }) as any;\r\n}\r\n\r\nexport { theMemberOf as memberOf }\r\n\r\ndeclare module '../model' {\r\n    namespace Model {\r\n        export const memberOf : <R extends new () => Model>( this : R, masterCollection : CollectionReference ) => ChainableAttributeSpec<Nullable<R>>;\r\n    }\r\n}\r\n\r\n( Model as any ).memberOf = theMemberOf;","import { Collection, CollectionConstructor, ElementsArg, CollectionOptions } from '../collection';\r\nimport { define, tools } from '@type-r/mixture';\r\nimport { AggregatedType, ChainableAttributeSpec, Model, type } from '../model';\r\nimport { ItemsBehavior, transactionApi } from '../transactions';\r\nimport { CollectionReference, parseReference } from './commons';\r\n\r\n\r\ntype ModelsIds = ( string | number )[];\r\n\r\n// TODO: Change the last parameter to be the Model constructor. Extract the proper Collection type.\r\nexport function subsetOf<X extends CollectionConstructor<R>, R extends Model>( this : void, masterCollection : CollectionReference, T? : X ) : ChainableAttributeSpec<SubsetCollectionConstructor<R>>{\r\n    const CollectionClass = T || Collection,\r\n        // Lazily define class for subset collection, if it's not defined already...\r\n        SubsetOf = CollectionClass._SubsetOf || ( CollectionClass._SubsetOf = defineSubsetCollection( CollectionClass as any ) as any ),\r\n        getMasterCollection = parseReference( masterCollection );\r\n\r\n    return type( SubsetOf ).get(\r\n        function( refs ){\r\n            !refs || refs.resolvedWith || refs.resolve( getMasterCollection( this ) );\r\n            return refs;\r\n        }\r\n    );\r\n}\r\n\r\n\r\ntype subsetOfType = typeof subsetOf;\r\n\r\ndeclare module \"../collection\" {\r\n    namespace Collection {\r\n        export const subsetOf : subsetOfType;\r\n    }    \r\n}\r\n\r\n( Collection as any ).subsetOf = subsetOf;\r\n\r\n\r\nCollection.prototype.createSubset = function<M extends Model>( this : Collection<M>, models : any, options ) : SubsetCollection<M> {\r\n    const SubsetOf = subsetOf( this, this.constructor as any ).options.type,\r\n          subset   = new SubsetOf( models, options );\r\n        \r\n    subset.resolve( this );\r\n    return subset as any;\r\n}\r\n\r\nconst subsetOfBehavior = ItemsBehavior.share | ItemsBehavior.persistent;\r\n\r\nfunction defineSubsetCollection( CollectionClass : typeof Collection ) {\r\n    @define class SubsetOfCollection extends CollectionClass {\r\n        refs : any[];\r\n        resolvedWith : Collection = null;\r\n\r\n        _metatype : AggregatedType\r\n\r\n        get __inner_state__(){ return this.refs || this.models; }\r\n\r\n        constructor( recordsOrIds?, options? ){\r\n            super( [], options, subsetOfBehavior );\r\n            this.refs = toArray( recordsOrIds );\r\n        }\r\n\r\n        // Remove should work fine as it already accepts ids. Add won't...\r\n        add( a_elements, options = {} ){\r\n            const { resolvedWith } = this,\r\n                    toAdd = toArray( a_elements );\r\n            \r\n            if( resolvedWith ){\r\n                // If the collection is resolved already, everything is simple.\r\n                return super.add( resolveRefs( resolvedWith, toAdd ), options );\r\n            }\r\n            else{\r\n                // Collection is not resolved yet. So, we prepare the delayed computation.\r\n                if( toAdd.length ){\r\n                    const isRoot = transactionApi.begin( this );\r\n\r\n                    // Save elements to resolve in future...\r\n                    this.refs = this.refs ? this.refs.concat( toAdd ) : toAdd.slice();\r\n\r\n                    transactionApi.markAsDirty( this, options );\r\n\r\n                    // And throw the 'changes' event.\r\n                    isRoot && transactionApi.commit( this );\r\n                }\r\n            }\r\n        }\r\n\r\n        reset( a_elements?, options = {} ){\r\n            const { resolvedWith } = this,\r\n                elements = toArray( a_elements );\r\n    \r\n            return resolvedWith ?\r\n                // Collection is resolved, so parse ids and forward the call to set.\r\n                super.reset( resolveRefs( resolvedWith, elements ), options ) :\r\n                // Collection is not resolved yet. So, we prepare the delayed computation.\r\n                delaySet( this, elements, options ) as any || [];\r\n        }\r\n\r\n        _createTransaction( a_elements, options? ){\r\n            const { resolvedWith } = this,\r\n                elements = toArray( a_elements );\r\n    \r\n            return resolvedWith ?\r\n                // Collection is resolved, so parse ids and forward the call to set.\r\n                super._createTransaction( resolveRefs( resolvedWith, elements ), options ) :\r\n                // Collection is not resolved yet. So, we prepare the delayed computation.\r\n                delaySet( this, elements, options );\r\n        }\r\n\r\n        // Serialized as an array of model ids.\r\n        toJSON() : ModelsIds {\r\n            return this.refs ?\r\n                this.refs.map( objOrId => objOrId.id || objOrId ) :\r\n                this.models.map( model => model.id );\r\n        }\r\n\r\n        // Subset is always valid.\r\n        _validateNested(){ return 0; }\r\n\r\n        get length() : number {\r\n            return this.models.length || ( this.refs ? this.refs.length : 0 );\r\n        }\r\n\r\n        // Must be shallow copied on clone.\r\n        clone( owner? ){\r\n            var Ctor = (<any>this).constructor,\r\n                copy = new Ctor( [], {\r\n                    model : this.model,\r\n                    comparator : this.comparator\r\n                });\r\n\r\n            if( this.resolvedWith ){\r\n                // TODO: bug here. \r\n                copy.resolvedWith = this.resolvedWith;\r\n                copy.refs = null;\r\n                copy.reset( this.models, { silent : true } );\r\n            }\r\n            else{\r\n                copy.refs = this.refs.slice();\r\n            }\r\n\r\n            return copy;\r\n        }\r\n\r\n        // Clean up the custom parse method possibly defined in the base class.\r\n        parse( raw : any ) : Model[] {\r\n            return raw;\r\n        }\r\n\r\n        resolve( collection : Collection ) : this {\r\n            if( collection && collection.length ){\r\n                this.resolvedWith = collection;\r\n\r\n                if( this.refs ){\r\n                    this.reset( this.refs, { silent : true } );\r\n                    this.refs = null;\r\n                }\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        getModelIds() : ModelsIds { return this.toJSON(); }\r\n\r\n        toggle( modelOrId : any, val : boolean ) : boolean {\r\n            return super.toggle( this.resolvedWith.get( modelOrId ), val );\r\n        }\r\n\r\n        addAll() : Model[] {\r\n            if( this.resolvedWith ){\r\n                this.set( this.resolvedWith.models );\r\n                return this.models;\r\n            }\r\n\r\n            throw new Error( \"Cannot add elemens because the subset collection is not resolved yet.\" );\r\n        }\r\n\r\n        toggleAll() : Model[] {\r\n            return this.length ? this.reset() : this.addAll();\r\n        }\r\n    }\r\n\r\n    // Clean up all custom item events to prevent memory leaks.\r\n    SubsetOfCollection.prototype._itemEvents = void 0;\r\n\r\n    return SubsetOfCollection;\r\n}\r\n\r\nexport interface SubsetCollection<M extends Model> extends Collection<M>{\r\n    getModelIds() : string[]\r\n    addAll() : M[]\r\n    toggleAll() : M[]\r\n    resolve( baseCollection : Collection<M> ) : this\r\n}\r\n\r\nexport interface SubsetCollectionConstructor<R extends Model = Model > {\r\n    new ( records? : ElementsArg<R> | string[], options?: CollectionOptions ) : SubsetCollection<R>\r\n    prototype : SubsetCollection<R>\r\n};\r\n\r\nfunction resolveRefs( master, elements ){\r\n    const records = [];\r\n    \r\n    for( let el of elements ){\r\n        const record = master.get( el );\r\n        if( record ) records.push( record );\r\n    }\r\n\r\n    return records;\r\n}\r\n\r\nfunction delaySet( collection, elements, options ) : void {\r\n    if( tools.notEqual( collection.refs, elements ) ){\r\n        const isRoot = transactionApi.begin( collection );\r\n\r\n        // Save elements to resolve in future...\r\n        collection.refs = elements.slice();\r\n\r\n        transactionApi.markAsDirty( collection, options );\r\n        \r\n        // And throw the 'changes' event.\r\n        isRoot && transactionApi.commit( collection );\r\n    }\r\n}\r\n\r\nfunction toArray( elements ){\r\n    return elements ? ( \r\n        Array.isArray( elements ) ? elements : [ elements ]\r\n    ) : [];\r\n}","import { Model } from '../model';\r\nimport { Transactional } from '../transactions';\r\n\r\nlet _store : Store = null;\r\n\r\nexport class Store extends Model {\r\n    getStore() : Store { return this; }\r\n \r\n    // delegate item lookup to owner, and to the global store if undefined\r\n    get( name : string ) : any {\r\n        // Lookup for resource in the current store. \r\n        let local = this[ name ];\r\n\r\n        // If something is found or it's the global store, return result.\r\n        if( local || this === this._defaultStore ) return local;\r\n\r\n        // Forward failed lookup to owner or global store.\r\n        return this._owner ? this._owner.get( name ) : this._defaultStore.get( name ); \r\n    }\r\n\r\n    static get global(){ return _store; }\r\n    static set global( store : Store ){\r\n        if( _store ){\r\n          _store.dispose();\r\n        }\r\n\r\n        Transactional.prototype._defaultStore = _store = store;\r\n    }\r\n}\r\n\r\nStore.global = new Store();","// Dummy polyfill to prevent exception in IE.\r\nif( typeof Symbol === 'undefined' ){\r\n    Object.defineProperty( window, 'Symbol', { value : { iterator : 'Symbol.iterator' }, configurable : true  });\r\n}\r\n\r\nimport { Events, Mixable as Class, log } from '@type-r/mixture';\r\nimport { CollectionConstructor } from './collection';\r\n// Define synonims for NestedTypes backward compatibility.\r\nimport { attributes, ChainableAttributeSpec, Model, type as _type, value } from './model';\r\nimport { AnonymousModelConstructor } from './model/define'\r\nimport { isEmpty } from '@type-r/mixture/lib/tools';\r\n\r\n/**\r\n * Export everything \r\n */\r\nexport { Linked } from '@linked/value';\r\nexport * from '@type-r/mixture';\r\nexport * from './collection';\r\nexport * from './io-tools';\r\nexport * from './model';\r\nexport * from './relations';\r\nexport * from './transactions';\r\nexport { Model as Record, Class };\r\n\r\n\r\nexport const { on, off, trigger, once, listenTo, stopListening, listenToOnce } = <any>Events;\r\n\r\n/** Wrap model or collection method in transaction. */\r\nexport function transaction< F extends Function >( method : F ) : F {\r\n    return <any>function( ...args ){\r\n        let result;\r\n        \r\n        this.transaction( () => {\r\n            result = method.apply( this, args );\r\n        });\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\nexport function type<T extends new ( ...args : any ) => Model>( t : T[] ) : ChainableAttributeSpec<CollectionConstructor<InstanceType<T>>>;\r\nexport function type<T extends object>( t : T[] ) : ChainableAttributeSpec<CollectionConstructor<InstanceType<AnonymousModelConstructor<T>>>>;\r\nexport function type<T extends Function>( t : T | ChainableAttributeSpec<T> ) : ChainableAttributeSpec<T>;\r\nexport function type<T extends object>( t : T ) : ChainableAttributeSpec<AnonymousModelConstructor<T>>;\r\nexport function type<T>( t : T ){\r\n    return Array.isArray( t ) ?\r\n        _type( _toModel( t[ 0 ] ).Collection ) :\r\n        _type( _toModel( t ) );\r\n}\r\n\r\nconst _toModel = t =>\r\n    t != null && Object.getPrototypeOf( t ) === Object.prototype ?\r\n        attributes( t ) :\r\n        t;\r\n\r\nChainableAttributeSpec.from = ( spec : any ) : ChainableAttributeSpec<any> => {\r\n    // Pass metatype through untouched...\r\n    if( spec && spec instanceof ChainableAttributeSpec ) {\r\n        return spec;\r\n    }\r\n\r\n    if( typeof spec === 'function' ) return type( spec );\r\n\r\n    if( Array.isArray( spec ) ){\r\n        if( spec.length !== 1 ||\r\n            !spec[ 0 ] || (\r\n                typeof spec[ 0 ] !== 'function' &&\r\n                Object.getPrototypeOf( spec[ 0 ] ) !== Object.prototype\r\n            )\r\n        ) {\r\n            log( 'error', 'Type-R:WrongDeclaration', `Since v4.1, [ ModelType ] and [{ attr1, attr2, }] declares collection of models. Use Array or value([ 1, 2, ... ]) to declare plain array attributes.` );\r\n            return value( spec );\r\n        }\r\n\r\n        return type( spec );\r\n    }\r\n\r\n    if( spec && typeof spec === 'object' ){\r\n        if( Object.getPrototypeOf( spec ) !== Object.prototype ){\r\n            log( 'error', 'Type-R:WrongDeclaration', `Since v4.1, non-primitive values must be wrapped in value(...). All objects are treated as attribute specs and define nested models.` );\r\n            return value( spec )\r\n        }\r\n\r\n        if( isEmpty( spec ) ){\r\n            log( 'error', 'Type-R:WrongDeclaration', `Since v4.1, objects are treated as attribute specs and define nested models. Use Object or value({...}) for an object attribute type.` );\r\n            return value( spec )\r\n        }\r\n\r\n        return type( spec )\r\n    }\r\n\r\n    return value( spec );\r\n}\r\n    "],"names":["defaults","dest","source","name","hasOwnProperty","arguments","length","i","other","isValidJSON","value","proto","Object","getPrototypeOf","prototype","Array","every","getBaseClass","Class","constructor","isEmpty","obj","key","some","fun","ArrayProto","arr","result","predicate","x","omit","discard","transform","assign","once","func","memo","first","apply","this","DateProto","Date","ObjectProto","notEqual","a","b","protoA","arraysNotEqual","keysA","keys","objectsNotEqual","HashProto","create","hashMap","hash","compare","av","valueOf","bv","definition","_i","names","names_1","_a","name_1","prop","desc","getOwnPropertyDescriptor","o","EventMap","map","handlers","concat","addEvent","split","eventSplitter","getBubblingHandler","callback","name_2","push","EventDescriptor","target","event_1","on","event_2","off","slice","addEventsMap","handler","_bubblingHandlers","event","c","d","e","trigger5","trigger3","trigger2","context","next","listOff","_events","filteredHead","prev","head","ev","_callback","listSend3","call","EventHandler","once_1","_once","name_3","strings","api","events","test","self","queue","all","listSend2","listSend4","listSend5","f","listSend6","extendStatics","setPrototypeOf","__proto__","p","__extends","__","__assign","t","s","n","__rest","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__decorate","decorators","r","Reflect","decorate","defineProperty","Mixable","protoProps","staticProps","BaseClass","mixins","defineMixin","merge","mergeObject","getStaticDefinitions","onDefine","definitions","mergeInheritedMembers","spec","statics","TheSubclass","__extends_1","predefine","define","Constructor","__super__","MixinsState","get","populate","onExtend","ClassOrDefinition","Ctor","rules","definitionRules","definitionDecorator","definitionKey","rule","appliedMixins","mixins_1","sourceMixins","mixin","isArray","mergeRules","ctors","ctors_1","unshift","object","ignore","dontMix","getOwnPropertyNames","forEachOwnProp","sourceProp","_this","assignProperty","mixinRules","protoValue","baseProto","resolveRule","function","caller","list","destProp","configurable","pipe","classFirst","classLast","_idCount","uniqueId","Messenger","eventsMap","localEvents","_localEvents","properties","defineProperties","toPropertyDescriptor","addReference","a_source","_listeningTo","removeAll","second","cid","_disposed","stopListening","initialize","Events","listener","isProduction","process","env","NODE_ENV","logEvents","Logger","level","filter","topic","msg","props","args","toString","console","Error","counter","_super","window","something","__inner_state__","body","join","JSON","stringify","logger","logEvents_1","logToConsole","throwingLogger","throwOn","log","trigger","bind","startIO","promise","options","thenDo","abortIO","_ioPromise","then","resp","triggerAndBubble","catch","err","abort","eventSource","collection","referenceMask","reference","splitTail","path","match","substr","tail","pop","local","resolve","Function","shift","resolveReference","root","action","skip","getStore","getOwner","ValidationError","iteratee","error","nested","each","eachError","_validateNested","validate","helpers","arrayHelpers","objectHelpers","dummyHelpers","Linked","clone","link","remove","iterator","element","mapped","at","array","splice","j","y","set","ClonedValueLink","checked","onChange","Boolean","update","truthyValue","EqualsValueLink","undefined","defaultValue","EnabledValueLink","ContainsRef","_","PropValueLink","links","_value$","whenValid","defaultError","CustomValueLink","state","unwrap","sourceVal","sourceKey","trim","tslib_1.__extends","parent","nextValue","el","removeAt","field","values","ItemsBehavior","Transactional","endpoint","_endpoint","Transactional_1","_owner","_ownerKey","_changeEventName","listenTo","isRoot","transactionApi","begin","commit","transaction","_changeToken","json","strict","validationError","eachValidationError","getClassName","data","_defaultStore","getOwnerEndpoint","_endpoints","_validationError","getValidationError","cidPrefix","_transaction","markAsDirty","dirty","silent","_isDirty","initiator","originalOptions","_onChildrenChange","aquire","owner","child","ReferenceError","free","_begin","_markAsDirty","setAttribute","record","_attributes","doUpdate","attributes","_previousAttributes","AttributesCopy","_changedAttributes","UpdateModelMixin","attribute","propagateChanges","forceAttributeChange","_createTransaction","a_values","unknown","changes","parse","shouldBeAnObject","unknownAttrsWarning","ModelTransaction","nested_1","_log","nested_2","changes_1","_b","emptyOptions","AnyType","model","handleChange","toJSON","type","getHook","v","isChanged","code","text","New value","Prev. value","a_options","getHooks","transforms","changeHandlers","getHook_1","validate_1","changeEvents","hasCustomDefault","tools.isValidJSON","isRequired","convert","reduce","chainGetHooks","chainTransforms","chainChangeHandlers","doInit","prevHook","nextHook","prevTransform","nextTransform","prevHandler","nextHandler","ImmutableClassType","PrimitiveType","NumericType","num","isFinite","ArrayType","ObjectType","doNothing","FunctionType","DateType","date","timestamp","getTime","toISOString","supportsDate","isNaN","struct","minutesOffset","isoDatePattern","exec","k","numericKeys","UTC","safeParseDate","AggregatedType","canBeUpdated","nestedTransaction","_shared","persistent","_handleChange","unset","dispose","shareAndListen","listen","share","SharedType","implicitObject","_onChange","builtins","String","Number","metatypes","getMetatype","_metatype","idx","ChainableAttributeSpec","check","metadata","required","ref","a_value","a_key","emptyFunction","changed","eventMap","unsubscribe","subscribe","cloned","Type","attrDef","shared","inferType","Symbol","LinkedAttr","attr","_error","_token","createAttribute","from","createAttributesMixin","attributesDefinition","baseClassAttributes","myAttributes","_.transform","allAttributes","_.defaults","ConstructorsMixin","attrDefs","attrs","Attributes","constructorsMixin","_attributesArray","createPropertyDescriptor","attrSpecs","eventsApi.EventMap","watcher","localEventsMixin","IOModelMixin","save","getEndpoint","ioMethod","isNew","id","fetch","read","destroy","_cidCounter","Model","asc","idAttribute","extend","_attributes$","__Attributes$","diff","hasChanged","val","old","nullify","forEach","_attributesArray_1","copy","pinStore","errors","asJson","l","newModel","clear","a_logger","Attributes definition","a_fun","tools.transform","ModelEntriesIterator","Collection","typeCheck","BaseModelAttributes","BaseModelAttributesCopy","IdAttribute","metatype","done","models","md","coll","last","First","toMix","AnonimousModel","DefaultCollection","dynamicMixin","AttributeRefs","__ModelAttrRef","isMutableType","addAttributeLinks","_aquire","_free","convertAndAquire","_aggregationError","_itemEvents","sortElements","_comparator","sort","addIndex","index","removeIndex","updateIndex","previous","CollectionTransaction","logAggregationError","added","removed","added_1","_d","removed_1","_e","sorted","addTransaction","items","a_items","forceMerge","_byId","prevLength","a_items_1","item","appendElements","needSort","length_1","moveElements","sortOrMoveElements","ArrayMixin","mapFilter","res","doWhile","init","end","modelOrId","idOrObj","toPredicateFunction","m","firstMatch","find","entries","a_index","a_reducer","reducer","defaultGrouping","results","acc","noOp","keys_1","keys_2","removeMany","toRemove","_removeFromIndex","_reallocate","silentOptions","emptySetTransaction","len","src","_reallocateEmpty","setTransaction","_prevById","prevModels","toAdd","orderKept","reusedCount","previous_1","children","children_1","addedOrChanged","_count","CollectionRefsType","Refs","RefsCollection","_SubsetOf","Collection_1","Subset","itemEvents","comparator","aa","bb","_store","objOrId","count","elements","add","reset","enabled","liveUpdates","filter_1","_liveUpdates","updated","aggregated","a_elements","previousModels","toElements","previousModels_1","toDispose","recordsOrIds","notify","LinkedIncludes","a_next","Argument","Attributes spec","records","parsed","toggle","parseReference","collectionRef","ModelRefType","theMemberOf","masterCollection","T","getMasterCollection","subsetOf","CollectionClass","SubsetOf","subsetOfBehavior","refs","toArray","SubsetOfCollection","resolvedWith","resolveRefs","delaySet","raw","addAll","memberOf","createSubset","subset","master","elements_1","tools.notEqual","Store","store","global","listenToOnce","_type","_toModel","attrName","getMetadata","value_1","as","reject","onAbort","fn","Promise","a_resolve","a_reject","listName","method"],"mappings":"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"}