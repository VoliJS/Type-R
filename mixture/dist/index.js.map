{"version":3,"file":"index.js","sources":["../src/tools.ts","../src/eventsource.ts","../../node_modules/tslib/tslib.es6.js","../src/mixins.ts","../src/events.ts","../src/logging.ts"],"sourcesContent":[" /** Similar to underscore `_.defaults` */\r\nexport function defaults< T >( dest : T, ...sources : Object[] ) : T\r\nexport function defaults< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) && !dest.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && defaults( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Check if value is raw JSON */\r\nexport function isValidJSON( value : any ) : boolean {\r\n    if( value === null ){\r\n        return true;\r\n    }\r\n\r\n    switch( typeof value ){\r\n    case 'number' :\r\n    case 'string' :\r\n    case 'boolean' :\r\n        return true;\r\n\r\n    case 'object':\r\n        var proto = Object.getPrototypeOf( value );\r\n\r\n        if( proto === Object.prototype || proto === Array.prototype ){\r\n            return every( value, isValidJSON );\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Get the base class constructor function.\r\n * @param Class Subclass constructor function.\r\n * @returns Base class constructor function.\r\n */\r\nexport function getBaseClass( Class : Function ) {\r\n    return Object.getPrototypeOf( Class.prototype ).constructor\r\n}\r\n\r\nexport function assignToClassProto<T, K extends keyof T>( Class, definition : T, ...names : K[] ) : void {\r\n    for( let name of names ){\r\n        const value = definition[ name ];\r\n        value === void 0 || ( Class.prototype[ name ] = value );\r\n    }\r\n}\r\n\r\n/** Checks whenever given object is an empty hash `{}` */\r\nexport function isEmpty( obj : {} ) : boolean {\r\n    if( obj ){\r\n        for( let key in obj ){\r\n            if( obj.hasOwnProperty( key ) ){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport type Iteratee = ( value : any, key? : string | number ) => any;\r\n\r\nfunction someArray( arr : any[], fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let i = 0; i < arr.length; i++ ){\r\n        if( result = fun( arr[ i ], i ) ){\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction someObject( obj : {}, fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let key in obj ){\r\n        if( obj.hasOwnProperty( key ) ){\r\n            if( result = fun( obj[ key ], key ) ){\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.some` */\r\nexport function some( obj, fun : Iteratee ) : any {\r\n    if( Object.getPrototypeOf( obj ) === ArrayProto ){\r\n        return someArray( obj, fun );\r\n    }\r\n    else{\r\n        return someObject( obj, fun );\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.every` */\r\nexport function every( obj : { }, predicate : Iteratee ) : boolean {\r\n    return !some( obj, x => !predicate( x ) );\r\n}\r\n\r\n/** Similar to `getOwnPropertyDescriptor`, but traverse the whole prototype chain. */\r\nexport function getPropertyDescriptor( obj : {}, prop : string ) : PropertyDescriptor {\r\n    let desc : PropertyDescriptor;\r\n\r\n    for( let proto = obj; !desc && proto; proto = Object.getPrototypeOf( proto ) ) {\r\n        desc = Object.getOwnPropertyDescriptor( proto, prop );\r\n    }\r\n\r\n    return desc;\r\n}\r\n\r\n/** Similar to underscore `_.omit` */\r\nexport function omit( source : {}, ...rest : string[] ) : {}\r\nexport function omit( source ) : {} {\r\n    const dest = {}, discard = {};\r\n\r\n    for( let i = 1; i < arguments.length; i ++ ){\r\n        discard[ arguments[ i ] ] = true;\r\n    }\r\n\r\n    for( var name in source ) {\r\n        if( !discard.hasOwnProperty( name ) && source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** map `source` object properties with a given function, and assign the result to the `dest` object.\r\n * When `fun` returns `undefined`, skip this value. \r\n */\r\nexport function transform< A, B >( dest : { [ key : string ] : A }, source : { [ key : string ] : B }, fun : ( value : B, key : string ) => A | void ) : { [ key : string ] : A } {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            var value = fun( source[ name ], name );\r\n            value === void 0 || ( dest[ name ] = < A >value );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastAssign< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        dest[ name ] = source[ name ];\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastDefaults< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        if( dest[ name ] === void 0 ){\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.extend` and `Object.assign` */\r\nexport function assign< T >( dest : T, ...sources : Object[] ) : T\r\nexport function assign< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && assign( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.keys` */\r\nexport function keys( o : any ) : string[]{\r\n    return o ? Object.keys( o ) : [];\r\n}\r\n\r\n/** Similar to underscore `_.once` */\r\nexport function once( func : Function ) : Function {\r\n    var memo, first = true;\r\n    return function() {\r\n        if ( first ) {\r\n            first = false;\r\n            memo = func.apply(this, arguments);\r\n            func = null;\r\n        }\r\n        return memo;\r\n    };\r\n}\r\n\r\nconst ArrayProto = Array.prototype,\r\n      DateProto = Date.prototype,\r\n      ObjectProto = Object.prototype;\r\n\r\n/**\r\n * Determine whenever two values are not equal, deeply traversing \r\n * arrays and plain JS objects (hashes). Dates are compared by enclosed timestamps, all other\r\n * values are compared with strict comparison.\r\n */\r\nexport function notEqual( a : any, b : any) : boolean {\r\n    if( a === b ) return false;\r\n\r\n    if( a && b && typeof a == 'object' && typeof b == 'object' ) {\r\n        const protoA = Object.getPrototypeOf( a );\r\n\r\n        if( protoA !== Object.getPrototypeOf( b ) ) return true;\r\n\r\n        switch( protoA ){\r\n            case DateProto   : return +a !== +b;\r\n            case ArrayProto  : return arraysNotEqual( a, b );\r\n            case ObjectProto :\r\n            case null:\r\n                return objectsNotEqual( a, b );\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction objectsNotEqual( a, b ) {\r\n    const keysA = Object.keys( a );\r\n\r\n    if( keysA.length !== Object.keys( b ).length ) return true;\r\n\r\n    for( let i = 0; i < keysA.length; i++ ) {\r\n        const key = keysA[ i ];\r\n\r\n        if( !b.hasOwnProperty( key ) || notEqual( a[ key ], b[ key ] ) ) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction arraysNotEqual( a, b ) {\r\n    if( a.length !== b.length ) return true;\r\n\r\n    for( let i = 0; i < a.length; i++ ) {\r\n        if( notEqual( a[ i ], b[ i ] ) ) return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Create an object without Object prototype members except hasOwnProperty.\r\n * @param obj - optional parameter to populate the hash map from.\r\n */\r\nconst HashProto = Object.create( null );\r\nHashProto.hasOwnProperty = ObjectProto.hasOwnProperty;\r\n\r\nexport function hashMap( obj? ){\r\n    const hash = Object.create( HashProto );\r\n    return obj ? assign( hash, obj ) : hash;\r\n}\r\n\r\nexport function compare( a : any, b : any ) : -1 | 0 | 1 {\r\n    // Handle strictly equal values.\r\n    if( a == b ) return 0;\r\n\r\n    // Handle nulls.\r\n    if( a == null ) return -1;\r\n    if( b == null ) return 1;\r\n\r\n    // No nulls. Convert values to primitives.\r\n    const av = a.valueOf(),\r\n        bv = b.valueOf();\r\n\r\n    return  av < bv ? -1 :\r\n            av > bv ? 1 :\r\n            0;\r\n}","import { once as _once } from './tools'\r\n\r\n/*******************\r\n * Prebuilt events map, used for optimized bulk event subscriptions.\r\n *\r\n * const events = new EventMap({\r\n *      'change' : true, // Resend this event from self as it is.\r\n *      'change:attr' : 'localTargetFunction',\r\n *      'executedInTargetContext' : function(){ ... }\r\n *      'executedInNativeContext' : '^props.handler'\r\n * })\r\n */\r\nexport interface EventsDefinition {\r\n    [ events : string ] : Function | string | boolean\r\n}\r\n\r\nexport class EventMap {\r\n    handlers : EventDescriptor[] = [];\r\n\r\n    constructor( map? : EventsDefinition | EventMap ){\r\n        if( map ){\r\n            if( map instanceof EventMap ){\r\n                this.handlers = map.handlers.slice();\r\n            }\r\n            else{\r\n                map && this.addEventsMap( map );\r\n            }\r\n        }\r\n    }\r\n\r\n    merge( map : EventMap ){\r\n        this.handlers = this.handlers.concat( map.handlers );\r\n    }\r\n\r\n    addEventsMap( map : EventsDefinition ){\r\n        for( let names in map ){\r\n            this.addEvent( names, map[ names ] )\r\n        }\r\n    }\r\n\r\n    bubbleEvents( names : string ){\r\n        for( let name of names.split( eventSplitter ) ){\r\n            this.addEvent( name, getBubblingHandler( name ) );\r\n        }\r\n    }\r\n\r\n    addEvent( names : string, callback : Function | string | boolean ){\r\n        const { handlers } = this;\r\n\r\n        for( let name of names.split( eventSplitter ) ){\r\n            handlers.push( new EventDescriptor( name, callback ) );\r\n        }\r\n    }\r\n\r\n    subscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            on( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n\r\n    unsubscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            off( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n}\r\n\r\nexport class EventDescriptor {\r\n    callback : Function\r\n\r\n    constructor(\r\n        public name : string,\r\n        callback : Function | string | boolean\r\n    ){\r\n        if( callback === true ){\r\n            this.callback = getBubblingHandler( name );\r\n        }\r\n        else if( typeof callback === 'string' ){\r\n            this.callback =\r\n                function localCallback(){\r\n                    const handler = this[ callback ];\r\n                    handler && handler.apply( this, arguments );\r\n                };\r\n        }\r\n        else{\r\n            this.callback = <Function>callback;\r\n        }\r\n    }\r\n}\r\n\r\nconst _bubblingHandlers = {};\r\n\r\nfunction getBubblingHandler( event : string ){\r\n    return _bubblingHandlers[ event ] || (\r\n        _bubblingHandlers[ event ] = function( a?, b?, c?, d?, e? ){\r\n            if( d !== void 0 || e !== void 0 ) trigger5( this, event, a, b, c, d, e );\r\n            if( c !== void 0 ) trigger3( this, event, a, b, c );\r\n            else trigger2( this, event, a, b );\r\n        }\r\n    );\r\n}\r\n\r\nexport interface HandlersByEvent {\r\n    [ name : string ] : EventHandler\r\n}\r\n\r\nexport class EventHandler {\r\n    constructor( public callback : Callback, public context : any, public next = null ){}\r\n}\r\n\r\nfunction listOff( _events : HandlersByEvent, name : string, callback : Callback, context : any ){\r\n    const head = _events[ name ];\r\n\r\n    let filteredHead, prev;\r\n\r\n    for( let ev = head; ev; ev = ev.next ){\r\n        // Element must be kept\r\n        if( ( callback && callback !== ev.callback && callback !== ev.callback._callback ) ||\r\n            ( context && context !== ev.context ) ){\r\n            \r\n            prev = ev;\r\n            filteredHead || ( filteredHead = ev );\r\n        }\r\n        // Element must be skipped\r\n        else{\r\n            if( prev ) prev.next = ev.next;\r\n        }\r\n    }\r\n\r\n    if( head !== filteredHead ) _events[ name ] = filteredHead;\r\n}\r\n\r\nfunction listSend2( head : EventHandler, a, b ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b );\r\n}\r\n\r\nfunction listSend3( head : EventHandler, a, b, c ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c );\r\n}\r\n\r\nfunction listSend4( head : EventHandler, a, b, c, d ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d );\r\n}\r\n\r\nfunction listSend5( head : EventHandler, a, b, c, d, e ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e );\r\n}\r\n\r\nfunction listSend6( head : EventHandler, a, b, c, d, e, f ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e, f );\r\n}\r\n\r\nexport interface Callback extends Function {\r\n    _callback? : Function\r\n}\r\n\r\nexport function on( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const _events = source._events || ( source._events = Object.create( null ) );\r\n        _events[ name ] = new EventHandler( callback, context, _events[ name ] );\r\n    }\r\n}\r\n\r\nexport function once( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const once : Callback = _once( function(){\r\n            off( source, name, once );\r\n            callback.apply(this, arguments);\r\n        });\r\n\r\n        once._callback = callback;\r\n        on( source, name, once, context );\r\n    }\r\n}\r\n\r\nexport function off( source : EventSource, name? : string, callback? : Callback, context? : any ) : void {\r\n    const { _events } = source;\r\n    if( _events ){\r\n        if( callback || context ) {\r\n            if( name ){\r\n                listOff( _events, name, callback, context );\r\n            }\r\n            else{\r\n                for( let name in _events ){\r\n                    listOff( _events, name, callback, context );\r\n                }\r\n            }\r\n        }\r\n        else if( name ){\r\n            _events[ name ] = void 0;\r\n        }\r\n        else{\r\n            source._events = void 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport interface EventSource {\r\n    /** @internal */\r\n    _events : HandlersByEvent\r\n}\r\n\r\nconst eventSplitter = /\\s+/;\r\n\r\nexport function strings( api : ApiEntry, source : EventSource, events : string, callback : Callback, context ){\r\n    if( eventSplitter.test( events ) ){\r\n        const names = events.split( eventSplitter );\r\n        for( let name of names ) api( source, name, callback, context );\r\n    }\r\n    else api( source, events, callback, context );\r\n}\r\n\r\nexport type ApiEntry = ( source : EventSource, event : string, callback : Callback, context? : any ) => void\r\n\r\n/*********************************\r\n * Event-triggering API\r\n */\r\n\r\n export function trigger2( self : EventSource, name : string, a, b ) : void {\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend2( queue, a, b );\r\n        listSend3( all, name, a, b );\r\n    }\r\n};\r\n\r\nexport function trigger3( self : EventSource, name : string, a, b, c ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend3( queue, a, b, c );\r\n        listSend4( all, name, a, b, c );\r\n    }\r\n};\r\n\r\nexport function trigger5( self : EventSource, name : string, a, b, c, d, e ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend5( queue, a, b, c, d, e );\r\n        listSend6( all, name, a, b, c, d, e );\r\n    }\r\n};","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/*****************************************************************\r\n * Mixins engine and @define metaprogramming class extensions\r\n *\r\n * Vlad Balin & Volicon, (c) 2016-2017\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { assign, defaults, getBaseClass, hashMap, transform } from './tools';\r\n\r\nexport interface Subclass< T > extends MixableConstructor {\r\n    new ( ...args ) : T\r\n    prototype : T\r\n}\r\n\r\nexport interface MixableConstructor extends Function{\r\n    __super__? : object;\r\n    mixins? : MixinsState;\r\n    onExtend? : ( BaseClass : Function ) => void;\r\n    onDefine? : ( definition : object, BaseClass : Function ) => void;\r\n    define? : ( definition? : object, statics? : object ) => MixableConstructor;\r\n    extend? : <T extends object>( definition? : T, statics? : object ) => Subclass<T>;\r\n}\r\n\r\nexport interface MixableDefinition {\r\n    mixins? : Mixin[]\r\n}\r\n\r\n/**\r\n * Base class, holding metaprogramming class extensions.\r\n * Supports mixins and Class.define metaprogramming method.\r\n */\r\nexport class Mixable {\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static onDefine : ( definition : object, BaseClass : Function ) => object;    \r\n    static __super__ : object\r\n    static mixins : MixinsState;\r\n\r\n    /** \r\n     *  Must be called after inheritance and before 'define'.\r\n     */\r\n    static define( protoProps : MixableDefinition = {}, staticProps? : object ) : MixableConstructor {\r\n        const BaseClass : MixableConstructor = getBaseClass( this );\r\n\r\n        // Assign statics.\r\n        staticProps && assign( this, staticProps );\r\n\r\n        // Extract and apply mixins from the definition.\r\n        const { mixins, ...defineMixin } = protoProps;\r\n        mixins && this.mixins.merge( mixins );\r\n\r\n        // Unshift definition to the the prototype.\r\n        this.mixins.mergeObject( this.prototype, defineMixin, true );\r\n\r\n        // Unshift definition from statics to the prototype.\r\n        this.mixins.mergeObject( this.prototype, this.mixins.getStaticDefinitions( BaseClass ), true );\r\n\r\n        // Call onDefine hook, if it's present.\r\n        this.onDefine && this.onDefine( this.mixins.definitions, BaseClass );\r\n        \r\n        // Apply merge rules to inherited members. No mixins can be added after this point.\r\n        this.mixins.mergeInheritedMembers( BaseClass );\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Backbone-compatible extend method to be used in ES5 and for backward compatibility */\r\n    static extend< T extends object>(spec? : T, statics? : {} ) : Subclass< T > {\r\n        let TheSubclass : Subclass< T >;\r\n\r\n        // 1. Create the subclass (ES5 compatibility shim).\r\n        // If constructor function is given...\r\n        if( spec && spec.hasOwnProperty( 'constructor' ) ){\r\n            // ...we need to manually call internal TypeScript __extend function. Hack! Hack!\r\n            TheSubclass = spec.constructor as any;\r\n            __extends( TheSubclass, this );\r\n        }\r\n        // Otherwise, create the subclall in usual way.\r\n        else{\r\n            TheSubclass = class Subclass extends this {} as any;\r\n        }\r\n\r\n        predefine( TheSubclass );\r\n        spec && TheSubclass.define( spec, statics );\r\n\r\n        return TheSubclass;\r\n    }\r\n}\r\n\r\n/** @decorator `@predefine` for forward definitions. Can be used with [[Mixable]] classes only.\r\n * Forwards the call to the [[Mixable.predefine]];\r\n */\r\nexport function predefine( Constructor : MixableConstructor ) : void {\r\n    const BaseClass : MixableConstructor = getBaseClass( Constructor );\r\n\r\n    // Legacy systems support\r\n    Constructor.__super__ = BaseClass.prototype;\r\n    \r\n    // Initialize mixins structures...\r\n    Constructor.define || MixinsState.get( Mixable ).populate( Constructor );\r\n\r\n    // Make sure Ctor.mixins are ready before the callback...\r\n    MixinsState.get( Constructor );\r\n\r\n    // Call extend hook.\r\n    Constructor.onExtend && Constructor.onExtend( BaseClass );\r\n}\r\n\r\n/** @decorator `@define` for metaprogramming magic. Can be used with [[Mixable]] classes only.\r\n *  Forwards the call to [[Mixable.define]].\r\n */\r\nexport function define( ClassOrDefinition : Function ) : void;\r\nexport function define( ClassOrDefinition : object ) : ClassDecorator;\r\nexport function define( ClassOrDefinition : object | MixableConstructor ){\r\n    // @define class\r\n    if( typeof ClassOrDefinition === 'function' ){\r\n        predefine( ClassOrDefinition );\r\n        ( ClassOrDefinition as MixableConstructor ).define();\r\n    }\r\n    // @define({ prop : val, ... }) class\r\n    else{\r\n        return function( Ctor : MixableConstructor ){\r\n            predefine( Ctor );\r\n            Ctor.define( ClassOrDefinition );\r\n        } as any;\r\n    }\r\n}\r\n\r\nexport function definitions( rules : MixinMergeRules ) : ClassDecorator {\r\n    return ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.definitionRules = defaults( hashMap(), rules, mixins.definitionRules );\r\n    }\r\n}\r\n\r\n// Create simple property list decorator\r\nexport function propertyListDecorator( listName: string ) : PropertyDecorator {\r\n    return function propList(proto, name : string) {\r\n        const list = proto.hasOwnProperty( listName ) ?\r\n            proto[ listName ] : (proto[ listName ] = (proto[ listName ] || []).slice());  \r\n\r\n        list.push(name);\r\n    }\r\n}\r\n\r\nexport function definitionDecorator( definitionKey, value ){\r\n    return ( proto : object, name : string ) => {\r\n        MixinsState\r\n            .get( proto.constructor )\r\n            .mergeObject( proto, {\r\n                [ definitionKey ] : {\r\n                    [ name ] : value\r\n                }\r\n            });\r\n    }\r\n}\r\n\r\nexport class MixinsState {\r\n    mergeRules : MixinMergeRules;\r\n    definitionRules : MixinMergeRules;\r\n    definitions : object = {};\r\n    appliedMixins : Mixin[];\r\n\r\n    // Return mixins state for the class. Initialize if it's not exist.\r\n    static get( Class ) : MixinsState {\r\n        const { mixins } = Class;\r\n    \r\n        return mixins && Class === mixins.Class ? mixins :\r\n             Class.mixins = new MixinsState( Class );\r\n    }\r\n\r\n    constructor( public Class : MixableConstructor ){\r\n        const { mixins } = getBaseClass( Class );\r\n\r\n        this.mergeRules = ( mixins && mixins.mergeRules ) || hashMap();\r\n        this.definitionRules = ( mixins && mixins.definitionRules ) || hashMap();\r\n        this.appliedMixins = ( mixins && mixins.appliedMixins ) || [];\r\n    }\r\n\r\n    getStaticDefinitions( BaseClass : Function ){\r\n        const definitions = hashMap(),\r\n            { Class } = this;\r\n\r\n        return transform( definitions, this.definitionRules, ( rule, name ) =>{\r\n            if( BaseClass[ name ] !== Class[ name ]){\r\n                return Class[ name ];\r\n            }\r\n        });\r\n    }\r\n\r\n    merge( mixins : Mixin[] ){\r\n        const proto      = this.Class.prototype,\r\n            { mergeRules } = this;\r\n\r\n        // Copy applied mixins array as it's going to be updated.\r\n        const appliedMixins = this.appliedMixins = this.appliedMixins.slice();\r\n\r\n        // Apply mixins in sequence...\r\n        for( let mixin of mixins ) {\r\n            // Mixins array should be flattened.\r\n            if( Array.isArray( mixin ) ) {\r\n                this.merge( mixin );\r\n            }\r\n            // Don't apply mixins twice.\r\n            else if( appliedMixins.indexOf( mixin ) < 0 ){\r\n                appliedMixins.push( mixin );\r\n\r\n                // For constructors, merge _both_ static and prototype members.\r\n                if( typeof mixin === 'function' ){\r\n                    // Merge static members\r\n                    this.mergeObject( this.Class, mixin );\r\n\r\n                    // merge definitionRules and mergeRules\r\n                    const sourceMixins = ( mixin as any ).mixins;\r\n                    if( sourceMixins ){\r\n                        this.mergeRules = defaults( hashMap(), this.mergeRules, sourceMixins.mergeRules );\r\n                        this.definitionRules = defaults( hashMap(), this.definitionRules, sourceMixins.definitionRules );\r\n                        this.appliedMixins = this.appliedMixins.concat( sourceMixins.appliedMixins );\r\n                    }\r\n\r\n                    // Prototypes are merged according with rules.\r\n                    this.mergeObject( proto, mixin.prototype );\r\n                }\r\n                // Handle plain object mixins.\r\n                else {\r\n                    this.mergeObject( proto, mixin );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    populate( ...ctors : Function[] ){\r\n        for( let Ctor of ctors ) {\r\n            MixinsState.get( Ctor ).merge([ this.Class ]);\r\n        }\r\n    }\r\n\r\n    mergeObject( dest : object, source : object, unshift? : boolean ) {\r\n        forEachOwnProp( source, name => {\r\n            const sourceProp = Object.getOwnPropertyDescriptor( source, name );\r\n            let rule : MixinMergeRule;\r\n\r\n            if( rule = this.definitionRules[ name ] ){\r\n                assignProperty( this.definitions, name, sourceProp, rule, unshift );\r\n            }\r\n\r\n            if( !rule || rule === mixinRules.protoValue  ){\r\n                assignProperty( dest, name, sourceProp, this.mergeRules[ name ], unshift );\r\n            }\r\n        });\r\n    }\r\n\r\n    mergeInheritedMembers( BaseClass : Function ){\r\n        const { mergeRules, Class } = this;\r\n\r\n        if( mergeRules ){\r\n            const proto = Class.prototype,\r\n                baseProto = BaseClass.prototype;\r\n\r\n            for( let name in mergeRules ) {\r\n                const rule = mergeRules[ name ];\r\n\r\n                if( proto.hasOwnProperty( name ) && name in baseProto ){\r\n                    proto[ name ] = resolveRule( proto[ name ], baseProto[ name ], rule );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst dontMix = {\r\n    function : hashMap({\r\n        length : true,\r\n        prototype : true,\r\n        caller : true,\r\n        arguments : true,\r\n        name : true,\r\n        __super__ : true\r\n    }),\r\n    \r\n    object : hashMap({\r\n        constructor : true\r\n    })    \r\n}\r\n\r\nfunction forEachOwnProp( object : object, fun : ( name : string ) => void ){\r\n    const ignore = dontMix[ typeof object ];\r\n\r\n    for( let name of Object.getOwnPropertyNames( object ) ) {\r\n        ignore[ name ] || fun( name );\r\n    }\r\n}\r\n\r\nexport interface MixinMergeRules {\r\n    [ name : string ] : MixinMergeRule\r\n}\r\n\r\nexport type MixinMergeRule = ( a : any, b : any ) => any\r\nexport type Mixin = { [ key : string ] : any } | Function\r\n\r\n// @mixins( A, B, ... ) decorator.\r\nexport interface MixinRulesDecorator {\r\n    ( rules : MixinMergeRules ) : ClassDecorator\r\n    value( a : object, b : object) : object;\r\n    protoValue( a : object, b : object) : object;\r\n    merge( a : object, b : object ) : object;\r\n    pipe( a: Function, b : Function ) : Function;\r\n    defaults( a: Function, b : Function ) : Function;\r\n    classFirst( a: Function, b : Function ) : Function;\r\n    classLast( a: Function, b : Function ) : Function;\r\n    every( a: Function, b : Function ) : Function;\r\n    some( a: Function, b : Function ) : Function;\r\n}\r\n\r\nexport const mixins = ( ...list : Mixin[] ) => (\r\n    ( Class : Function ) => MixinsState.get( Class ).merge( list )\r\n);\r\n\r\n// @mixinRules({ name : rule, ... }) decorator.\r\nexport const mixinRules = ( ( rules : MixinMergeRules ) => (\r\n    ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.mergeRules = defaults( rules, mixins.mergeRules );\r\n    }\r\n) ) as MixinRulesDecorator;\r\n\r\n// Pre-defined mixin merge rules\r\n\r\nmixinRules.value = ( a, b ) => a;\r\n\r\nmixinRules.protoValue = ( a, b ) => a;\r\n\r\n// Recursively merge members\r\nmixinRules.merge = ( a, b ) => defaults( {}, a, b );\r\n\r\n    // Execute methods in pipe, with the class method executed last.\r\nmixinRules.pipe = ( a, b ) => (\r\n    function( x : any ) : any {\r\n        return a.call( this, b.call( this, x ) );\r\n    }\r\n);\r\n\r\n    // Assume methods return an object, and merge results with defaults (class method executed first)\r\nmixinRules.defaults = ( a : Function, b : Function ) => (\r\n    function() : object {\r\n        return defaults( a.apply( this, arguments ), b.apply( this, arguments ) );\r\n    }\r\n);\r\n\r\n// Execute methods in sequence staring with the class method.\r\nmixinRules.classFirst = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        a.apply( this, arguments );\r\n        b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n    // Execute methods in sequence ending with the class method.\r\nmixinRules.classLast = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        b.apply( this, arguments );\r\n        a.apply( this, arguments );\r\n    }\r\n)\r\n\r\n    // Execute methods in sequence returning the first falsy result.\r\nmixinRules.every = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) && b.apply( this, arguments );\r\n    }\r\n);\r\n    // Execute methods in sequence returning the first truthy result.\r\nmixinRules.some = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) || b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nfunction assignProperty( dest : object, name : string, sourceProp : PropertyDescriptor, rule : MixinMergeRule, unshift? : boolean ){\r\n// Destination prop is defined, thus the merge rules must be applied.\r\n    if( dest.hasOwnProperty( name ) ){\r\n        const destProp = Object.getOwnPropertyDescriptor( dest, name );\r\n\r\n        if( destProp.configurable && 'value' in destProp ){\r\n            dest[ name ] = unshift ?\r\n                resolveRule( sourceProp.value, destProp.value, rule ) :\r\n                resolveRule( destProp.value, sourceProp.value, rule ) ;\r\n        }\r\n    }\r\n    // If destination is empty, just copy the prop over.\r\n    else{\r\n        Object.defineProperty( dest, name, sourceProp );\r\n    }\r\n}\r\n\r\nfunction resolveRule( dest, source, rule : MixinMergeRule ){\r\n    // When destination is empty, take the source.\r\n    if( dest === void 0 ) return source;\r\n\r\n    // In these cases we take non-empty destination:\r\n    if( !rule || source === void 0 ) return dest;\r\n\r\n    // In other cases we must merge values.\r\n    return rule( dest, source );\r\n}","import * as _eventsApi from './eventsource';\r\nimport { EventMap, EventsDefinition, EventSource, HandlersByEvent } from './eventsource';\r\nimport { define, definitions, Mixable, MixableConstructor, mixinRules, MixinsState } from './mixins';\r\nimport { omit, transform } from './tools';\r\n\r\nconst { strings, on, off, once, trigger5, trigger2, trigger3 } = _eventsApi;\r\n\r\nlet _idCount = 0;\r\n\r\nfunction uniqueId() : string {\r\n    return 'l' + _idCount++;\r\n}\r\n\r\nexport { EventMap, EventsDefinition };\r\n\r\nexport interface MessengerDefinition {\r\n    _localEvents? : EventMap\r\n    localEvents? : EventsDefinition\r\n    properties? : PropertyMap\r\n    [ name : string ] : any\r\n}\r\n\r\nexport interface PropertyMap {\r\n    [ name : string ] : Property\r\n}\r\n\r\nexport type Property = PropertyDescriptor | ( () => any )\r\n\r\nexport interface MessengersByCid {\r\n    [ cid : string ] : Messenger\r\n}\r\n\r\nexport type EventCallbacks<Context> = { [ events : string ] : EventCallback<Context> }\r\nexport type EventCallback<Context> = ( ...args : any[] ) => void\r\n\r\n/*************************\r\n * Messenger is mixable class with capabilities of sending and receiving synchronous events.\r\n * This class itself can serve as both mixin and base class.\r\n */\r\n\r\n@define\r\n@definitions({\r\n    properties : mixinRules.merge,\r\n    localEvents : mixinRules.merge\r\n})\r\nexport class Messenger implements Mixable, EventSource {\r\n    // Define extendable mixin static properties.\r\n    /** @internal */\r\n    static __super__ : object;\r\n    static mixins : MixinsState;\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static define : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static extend : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static onDefine({ localEvents, _localEvents, properties } : MessengerDefinition, BaseClass? : typeof Mixable ){\r\n        // Handle localEvents definition\r\n        if( localEvents || _localEvents ){\r\n            const eventsMap = new EventMap( this.prototype._localEvents );\r\n\r\n            localEvents && eventsMap.addEventsMap( localEvents );\r\n            _localEvents && eventsMap.merge( _localEvents );\r\n            \r\n            this.prototype._localEvents = eventsMap;\r\n        }\r\n\r\n        // Handle properties definitions...\r\n        if( properties ){\r\n            Object.defineProperties( this.prototype, transform( {}, <PropertyMap>properties, toPropertyDescriptor ) );\r\n        }\r\n    }\r\n\r\n    /** @internal */ \r\n    _events : HandlersByEvent = void 0;\r\n\r\n    /** @internal */ \r\n    _listeningTo : MessengersByCid = void 0\r\n\r\n    /** Unique client-only id. */\r\n    cid : string\r\n\r\n    /** Prototype-only property to manage automatic local events subscription */ \r\n    protected _localEvents : EventMap\r\n\r\n    constructor(){\r\n        this.cid = uniqueId();\r\n        this.initialize.apply( this, arguments );\r\n\r\n        // TODO: local events subscribe?\r\n    }\r\n\r\n    /** Method is called at the end of the constructor */\r\n    initialize() : void {}\r\n    \r\n    on( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( on, this, events, callback, context );\r\n        else for( let name in events ) strings( on, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    once( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( once, this, events, callback, context );\r\n        else for( let name in events ) strings( once, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    off( events? : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( !events ) off( this, void 0, callback, context );\r\n        else if( typeof events === 'string' ) strings( off, this, events, callback, context );\r\n        else for( let name in events ) strings( off, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\r\n    // passed the same arguments as `trigger` is, apart from the event name\r\n    // (unless you're listening on `\"all\"`, which will cause your callback to\r\n    // receive the true name of the event as the first argument).\r\n    trigger(name : string, a?, b?, c?, d?, e? ) : this {\r\n        if( d !== void 0 || e !== void 0 ) trigger5( this, name, a, b, c, d, e );\r\n        else if( c !== void 0 ) trigger3( this, name, a, b, c );\r\n        else trigger2( this, name, a, b );\r\n        return this;\r\n    }\r\n\r\n    listenTo( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.on( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    listenToOnce( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.once( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    stopListening( a_source? : Messenger, a? : string | EventCallbacks<this>, b? : Function ) : this {\r\n        const { _listeningTo } = this;\r\n        if( _listeningTo ){\r\n            const removeAll = !( a || b ),\r\n                  second = !b && typeof a === 'object' ? this : b;\r\n\r\n            if( a_source ){\r\n                const source = _listeningTo[ a_source.cid ];\r\n                if( source ){\r\n                    if( removeAll ) delete _listeningTo[ a_source.cid ];\r\n                    source.off( a, second, this );\r\n                }\r\n            }\r\n            else if( a_source == null ){\r\n                for( let cid in _listeningTo ) _listeningTo[ cid ].off( a, second, this );\r\n\r\n                if( removeAll ) ( this._listeningTo = void 0 );\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destructor. Stops messenger from listening to all objects,\r\n     * and stop others from listening to the messenger. \r\n     */\r\n    _disposed : boolean\r\n\r\n    dispose() : void {\r\n        if( this._disposed ) return;\r\n\r\n        this.stopListening();\r\n        this.off();\r\n\r\n        this._disposed = true;\r\n    }\r\n}\r\n\r\n/**\r\n * Backbone 1.2 API conformant Events mixin.\r\n */\r\nexport const Events : Messenger = <Messenger> omit( Messenger.prototype, 'constructor', 'initialize' );\r\n\r\n/**\r\n * Messenger Private Helpers \r\n */\r\n\r\nfunction toPropertyDescriptor( x : Property ) : PropertyDescriptor {\r\n    if( x ){\r\n        return typeof x === 'function' ? { get : < () => any >x, configurable : true } : <PropertyDescriptor> x;\r\n    }\r\n}\r\n\r\nfunction addReference( listener : Messenger, source : Messenger ){\r\n      const listeningTo = listener._listeningTo || (listener._listeningTo = Object.create( null ) ),\r\n            cid = source.cid || ( source.cid = uniqueId() );\r\n\r\n      listeningTo[ cid ] = source;\r\n}","import { Messenger } from './events'\r\nimport { define } from './mixins';\r\n\r\nexport type LogLevel = 'error' | 'warn' | 'debug' | 'info' | 'log';\r\nexport type LoggerEventHandler = ( topic : string, msg : string, props : object )  => void;\r\n\r\nexport const isProduction = typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production',\r\n    logEvents : LogLevel[] =  isProduction ?\r\n        [ 'error', 'info' ] :\r\n        [ 'error', 'warn', 'debug', 'info', 'log' ];\r\n\r\n@define\r\nexport class Logger extends Messenger {\r\n    counter : { [ level in LogLevel ]? : number } = {}\r\n\r\n    // Log events of the given log level to the console, optionally filtered by topic\r\n    logToConsole( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                const args = [ `[${topic}] ${msg}` ];\r\n        \r\n                for( let name in props ){\r\n                    args.push( `\\n\\t${name}:`, toString( props[ name ] ) );\r\n                }\r\n        \r\n                console[ level ].apply( console, args );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Fire exception on the events of the given log level, optionally filtered by topic\r\n    throwOn( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                throw new Error( `[${topic}] ${msg}` );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Count log events of the given level, optionally filtered by topic\r\n    count( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                this.counter[ level ] = ( this.counter[ level ] || 0 ) + 1;\r\n            }\r\n        });\r\n    }\r\n\r\n    trigger : ( level : LogLevel, topic : string, message : string, props? : object ) => this;\r\n    \r\n    off : ( event? : LogLevel ) => this;\r\n\r\n\r\n    on( handlers : { [ name in LogLevel ] : LoggerEventHandler } ) : this;\r\n    on( handlers : LogLevel, handler : LoggerEventHandler ) : this;\r\n    on( handlers : 'all', handler : ( level : LogLevel, topic : string, msg : string, props : object )  => void ) : this;\r\n    on( a : any, b? : any ){\r\n        return super.on( a, b );\r\n    }\r\n}\r\n\r\n/**\r\n * Convert objects to the plain text friendly format.\r\n * primitives as in JSON.\r\n */\r\nlet toString = typeof window === 'undefined' ? \r\n    something => {\r\n        if( something && typeof something === 'object' ){\r\n            // Support custom object wrappers...\r\n            const value = something.__inner_state__ || something,\r\n                isArray = Array.isArray( value );\r\n\r\n            const body = isArray ? `[ length = ${ value.length } ]` : `{ ${ Object.keys( value ).join( ', ' )} }`;\r\n\r\n            return something.constructor.name + ' ' + body;\r\n        }\r\n\r\n        return JSON.stringify( something );\r\n    }\r\n    : x => x;\r\n\r\nexport const logger = new Logger();\r\n\r\nif( typeof console !== 'undefined' ) {\r\n    for( let event of logEvents ){\r\n        logger.logToConsole( event );\r\n    }\r\n}\r\n\r\nexport const throwingLogger = new Logger();\r\nthrowingLogger.throwOn( 'error' ).throwOn( 'warn' );\r\n\r\nexport const log : typeof logger.trigger = logger.trigger.bind( logger );"],"names":["defaults","dest","source","name","hasOwnProperty","arguments","length","i","other","getBaseClass","Class","Object","getPrototypeOf","prototype","constructor","some","obj","fun","ArrayProto","arr","result","key","every","predicate","x","omit","discard","transform","value","assign","once","func","memo","first","apply","this","Array","DateProto","Date","ObjectProto","notEqual","a","b","protoA","arraysNotEqual","keysA","keys","objectsNotEqual","HashProto","create","hashMap","hash","isValidJSON","proto","definition","_i","names","names_1","_a","name_1","prop","desc","getOwnPropertyDescriptor","o","av","valueOf","bv","EventMap","map","handlers","concat","addEvent","split","eventSplitter","getBubblingHandler","callback","name_2","push","EventDescriptor","target","event_1","on","event_2","off","slice","addEventsMap","handler","_bubblingHandlers","event","c","d","e","trigger5","trigger3","trigger2","context","next","listOff","_events","filteredHead","prev","head","ev","_callback","listSend3","call","EventHandler","once_1","_once","name_3","strings","api","events","test","self","queue","all","listSend2","listSend4","listSend5","f","listSend6","extendStatics","setPrototypeOf","__proto__","p","__extends","__","__decorate","decorators","r","Reflect","decorate","defineProperty","Mixable","protoProps","staticProps","BaseClass","mixins","defineMixin","s","t","indexOf","getOwnPropertySymbols","propertyIsEnumerable","merge","mergeObject","getStaticDefinitions","onDefine","definitions","mergeInheritedMembers","spec","statics","TheSubclass","__extends_1","predefine","define","Constructor","__super__","MixinsState","get","populate","onExtend","ClassOrDefinition","Ctor","rules","definitionRules","rule","appliedMixins","mixins_1","sourceMixins","mixin","isArray","mergeRules","ctors","ctors_1","unshift","object","ignore","dontMix","getOwnPropertyNames","forEachOwnProp","sourceProp","_this","assignProperty","mixinRules","protoValue","baseProto","resolveRule","function","caller","destProp","configurable","pipe","classFirst","classLast","_idCount","uniqueId","Messenger","eventsMap","localEvents","_localEvents","properties","defineProperties","toPropertyDescriptor","addReference","a_source","_listeningTo","removeAll","second","cid","_disposed","stopListening","initialize","Events","listener","isProduction","process","env","NODE_ENV","logEvents","Logger","level","filter","topic","msg","props","args","toString","console","Error","counter","_super","window","something","__inner_state__","body","join","JSON","stringify","logger","logEvents_1","logToConsole","throwingLogger","throwOn","log","trigger","bind","definitionKey","list","listName"],"mappings":"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"}