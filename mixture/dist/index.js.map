{"version":3,"file":"index.js","sources":["../src/tools.ts","../src/eventsource.ts","../../node_modules/tslib/tslib.es6.js","../src/mixins.ts","../src/events.ts","../src/logging.ts"],"sourcesContent":[" /** Similar to underscore `_.defaults` */\r\nexport function defaults< T >( dest : T, ...sources : Object[] ) : T\r\nexport function defaults< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) && !dest.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && defaults( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Check if value is raw JSON */\r\nexport function isValidJSON( value : any ) : boolean {\r\n    if( value === null ){\r\n        return true;\r\n    }\r\n\r\n    switch( typeof value ){\r\n    case 'number' :\r\n    case 'string' :\r\n    case 'boolean' :\r\n        return true;\r\n\r\n    case 'object':\r\n        var proto = Object.getPrototypeOf( value );\r\n\r\n        if( proto === Object.prototype || proto === Array.prototype ){\r\n            return every( value, isValidJSON );\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Get the base class constructor function.\r\n * @param Class Subclass constructor function.\r\n * @returns Base class constructor function.\r\n */\r\nexport function getBaseClass( Class : Function ) {\r\n    return Object.getPrototypeOf( Class.prototype ).constructor\r\n}\r\n\r\nexport function assignToClassProto<T, K extends keyof T>( Class, definition : T, ...names : K[] ) : void {\r\n    for( let name of names ){\r\n        const value = definition[ name ];\r\n        value === void 0 || ( Class.prototype[ name ] = value );\r\n    }\r\n}\r\n\r\n/** Checks whenever given object is an empty hash `{}` */\r\nexport function isEmpty( obj : {} ) : boolean {\r\n    if( obj ){\r\n        for( let key in obj ){\r\n            if( obj.hasOwnProperty( key ) ){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport type Iteratee = ( value : any, key? : string | number ) => any;\r\n\r\nfunction someArray( arr : any[], fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let i = 0; i < arr.length; i++ ){\r\n        if( result = fun( arr[ i ], i ) ){\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction someObject( obj : {}, fun : Iteratee ) : any {\r\n    let result;\r\n\r\n    for( let key in obj ){\r\n        if( obj.hasOwnProperty( key ) ){\r\n            if( result = fun( obj[ key ], key ) ){\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.some` */\r\nexport function some( obj, fun : Iteratee ) : any {\r\n    if( Object.getPrototypeOf( obj ) === ArrayProto ){\r\n        return someArray( obj, fun );\r\n    }\r\n    else{\r\n        return someObject( obj, fun );\r\n    }\r\n}\r\n\r\n/** Similar to underscore `_.every` */\r\nexport function every( obj : { }, predicate : Iteratee ) : boolean {\r\n    return !some( obj, x => !predicate( x ) );\r\n}\r\n\r\n/** Similar to `getOwnPropertyDescriptor`, but traverse the whole prototype chain. */\r\nexport function getPropertyDescriptor( obj : {}, prop : string ) : PropertyDescriptor {\r\n    let desc : PropertyDescriptor;\r\n\r\n    for( let proto = obj; !desc && proto; proto = Object.getPrototypeOf( proto ) ) {\r\n        desc = Object.getOwnPropertyDescriptor( proto, prop );\r\n    }\r\n\r\n    return desc;\r\n}\r\n\r\n/** Similar to underscore `_.omit` */\r\nexport function omit( source : {}, ...rest : string[] ) : {}\r\nexport function omit( source ) : {} {\r\n    const dest = {}, discard = {};\r\n\r\n    for( let i = 1; i < arguments.length; i ++ ){\r\n        discard[ arguments[ i ] ] = true;\r\n    }\r\n\r\n    for( var name in source ) {\r\n        if( !discard.hasOwnProperty( name ) && source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** map `source` object properties with a given function, and assign the result to the `dest` object.\r\n * When `fun` returns `undefined`, skip this value. \r\n */\r\nexport function transform< A, B >( dest : { [ key : string ] : A }, source : { [ key : string ] : B }, fun : ( value : B, key : string ) => A | void ) : { [ key : string ] : A } {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            var value = fun( source[ name ], name );\r\n            value === void 0 || ( dest[ name ] = < A >value );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastAssign< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        dest[ name ] = source[ name ];\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nexport function fastDefaults< A >( dest : A, source : {} ) : A {\r\n    for( var name in source ) {\r\n        if( dest[ name ] === void 0 ){\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.extend` and `Object.assign` */\r\nexport function assign< T >( dest : T, ...sources : Object[] ) : T\r\nexport function assign< T >( dest : T, source : Object ) : T {\r\n    for( var name in source ) {\r\n        if( source.hasOwnProperty( name ) ) {\r\n            dest[ name ] = source[ name ];\r\n        }\r\n    }\r\n\r\n    if( arguments.length > 2 ){\r\n        for( let i = 2; i < arguments.length; i++ ){\r\n            const other = arguments[ i ];\r\n            other && assign( dest, other );\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\n/** Similar to underscore `_.keys` */\r\nexport function keys( o : any ) : string[]{\r\n    return o ? Object.keys( o ) : [];\r\n}\r\n\r\n/** Similar to underscore `_.once` */\r\nexport function once( func : Function ) : Function {\r\n    var memo, first = true;\r\n    return function() {\r\n        if ( first ) {\r\n            first = false;\r\n            memo = func.apply(this, arguments);\r\n            func = null;\r\n        }\r\n        return memo;\r\n    };\r\n}\r\n\r\nconst ArrayProto = Array.prototype,\r\n      DateProto = Date.prototype,\r\n      ObjectProto = Object.prototype;\r\n\r\n/**\r\n * Determine whenever two values are not equal, deeply traversing \r\n * arrays and plain JS objects (hashes). Dates are compared by enclosed timestamps, all other\r\n * values are compared with strict comparison.\r\n */\r\nexport function notEqual( a : any, b : any) : boolean {\r\n    if( a === b ) return false;\r\n\r\n    if( a && b && typeof a == 'object' && typeof b == 'object' ) {\r\n        const protoA = Object.getPrototypeOf( a );\r\n\r\n        if( protoA !== Object.getPrototypeOf( b ) ) return true;\r\n\r\n        switch( protoA ){\r\n            case DateProto   : return +a !== +b;\r\n            case ArrayProto  : return arraysNotEqual( a, b );\r\n            case ObjectProto :\r\n            case null:\r\n                return objectsNotEqual( a, b );\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction objectsNotEqual( a, b ) {\r\n    const keysA = Object.keys( a );\r\n\r\n    if( keysA.length !== Object.keys( b ).length ) return true;\r\n\r\n    for( let i = 0; i < keysA.length; i++ ) {\r\n        const key = keysA[ i ];\r\n\r\n        if( !b.hasOwnProperty( key ) || notEqual( a[ key ], b[ key ] ) ) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction arraysNotEqual( a, b ) {\r\n    if( a.length !== b.length ) return true;\r\n\r\n    for( let i = 0; i < a.length; i++ ) {\r\n        if( notEqual( a[ i ], b[ i ] ) ) return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Create an object without Object prototype members except hasOwnProperty.\r\n * @param obj - optional parameter to populate the hash map from.\r\n */\r\nconst HashProto = Object.create( null );\r\nHashProto.hasOwnProperty = ObjectProto.hasOwnProperty;\r\n\r\nexport function hashMap( obj? ){\r\n    const hash = Object.create( HashProto );\r\n    return obj ? assign( hash, obj ) : hash;\r\n}","import { once as _once } from './tools'\r\n\r\n/*******************\r\n * Prebuilt events map, used for optimized bulk event subscriptions.\r\n *\r\n * const events = new EventMap({\r\n *      'change' : true, // Resend this event from self as it is.\r\n *      'change:attr' : 'localTargetFunction',\r\n *      'executedInTargetContext' : function(){ ... }\r\n *      'executedInNativeContext' : '^props.handler'\r\n * })\r\n */\r\nexport interface EventsDefinition {\r\n    [ events : string ] : Function | string | boolean\r\n}\r\n\r\nexport class EventMap {\r\n    handlers : EventDescriptor[] = [];\r\n\r\n    constructor( map? : EventsDefinition | EventMap ){\r\n        if( map ){\r\n            if( map instanceof EventMap ){\r\n                this.handlers = map.handlers.slice();\r\n            }\r\n            else{\r\n                map && this.addEventsMap( map );\r\n            }\r\n        }\r\n    }\r\n\r\n    merge( map : EventMap ){\r\n        this.handlers = this.handlers.concat( map.handlers );\r\n    }\r\n\r\n    addEventsMap( map : EventsDefinition ){\r\n        for( let names in map ){\r\n            this.addEvent( names, map[ names ] )\r\n        }\r\n    }\r\n\r\n    bubbleEvents( names : string ){\r\n        for( let name of names.split( eventSplitter ) ){\r\n            this.addEvent( name, getBubblingHandler( name ) );\r\n        }\r\n    }\r\n\r\n    addEvent( names : string, callback : Function | string | boolean ){\r\n        const { handlers } = this;\r\n\r\n        for( let name of names.split( eventSplitter ) ){\r\n            handlers.push( new EventDescriptor( name, callback ) );\r\n        }\r\n    }\r\n\r\n    subscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            on( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n\r\n    unsubscribe( target : {}, source : EventSource ){\r\n        for( let event of this.handlers ){\r\n            off( source, event.name, event.callback, target );\r\n        }\r\n    }\r\n}\r\n\r\nexport class EventDescriptor {\r\n    callback : Function\r\n\r\n    constructor(\r\n        public name : string,\r\n        callback : Function | string | boolean\r\n    ){\r\n        if( callback === true ){\r\n            this.callback = getBubblingHandler( name );\r\n        }\r\n        else if( typeof callback === 'string' ){\r\n            this.callback =\r\n                function localCallback(){\r\n                    const handler = this[ callback ];\r\n                    handler && handler.apply( this, arguments );\r\n                };\r\n        }\r\n        else{\r\n            this.callback = <Function>callback;\r\n        }\r\n    }\r\n}\r\n\r\nconst _bubblingHandlers = {};\r\n\r\nfunction getBubblingHandler( event : string ){\r\n    return _bubblingHandlers[ event ] || (\r\n        _bubblingHandlers[ event ] = function( a?, b?, c?, d?, e? ){\r\n            if( d !== void 0 || e !== void 0 ) trigger5( this, event, a, b, c, d, e );\r\n            if( c !== void 0 ) trigger3( this, event, a, b, c );\r\n            else trigger2( this, event, a, b );\r\n        }\r\n    );\r\n}\r\n\r\nexport interface HandlersByEvent {\r\n    [ name : string ] : EventHandler\r\n}\r\n\r\nexport class EventHandler {\r\n    constructor( public callback : Callback, public context : any, public next = null ){}\r\n}\r\n\r\nfunction listOff( _events : HandlersByEvent, name : string, callback : Callback, context : any ){\r\n    const head = _events[ name ];\r\n\r\n    let filteredHead, prev;\r\n\r\n    for( let ev = head; ev; ev = ev.next ){\r\n        // Element must be kept\r\n        if( ( callback && callback !== ev.callback && callback !== ev.callback._callback ) ||\r\n            ( context && context !== ev.context ) ){\r\n            \r\n            prev = ev;\r\n            filteredHead || ( filteredHead = ev );\r\n        }\r\n        // Element must be skipped\r\n        else{\r\n            if( prev ) prev.next = ev.next;\r\n        }\r\n    }\r\n\r\n    if( head !== filteredHead ) _events[ name ] = filteredHead;\r\n}\r\n\r\nfunction listSend2( head : EventHandler, a, b ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b );\r\n}\r\n\r\nfunction listSend3( head : EventHandler, a, b, c ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c );\r\n}\r\n\r\nfunction listSend4( head : EventHandler, a, b, c, d ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d );\r\n}\r\n\r\nfunction listSend5( head : EventHandler, a, b, c, d, e ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e );\r\n}\r\n\r\nfunction listSend6( head : EventHandler, a, b, c, d, e, f ){\r\n    for( let ev = head; ev; ev = ev.next ) ev.callback.call( ev.context, a, b, c, d, e, f );\r\n}\r\n\r\nexport interface Callback extends Function {\r\n    _callback? : Function\r\n}\r\n\r\nexport function on( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const _events = source._events || ( source._events = Object.create( null ) );\r\n        _events[ name ] = new EventHandler( callback, context, _events[ name ] );\r\n    }\r\n}\r\n\r\nexport function once( source : EventSource, name : string, callback : Callback, context? : any ) : void {\r\n    if( callback ){\r\n        const once : Callback = _once( function(){\r\n            off( source, name, once );\r\n            callback.apply(this, arguments);\r\n        });\r\n\r\n        once._callback = callback;\r\n        on( source, name, once, context );\r\n    }\r\n}\r\n\r\nexport function off( source : EventSource, name? : string, callback? : Callback, context? : any ) : void {\r\n    const { _events } = source;\r\n    if( _events ){\r\n        if( callback || context ) {\r\n            if( name ){\r\n                listOff( _events, name, callback, context );\r\n            }\r\n            else{\r\n                for( let name in _events ){\r\n                    listOff( _events, name, callback, context );\r\n                }\r\n            }\r\n        }\r\n        else if( name ){\r\n            _events[ name ] = void 0;\r\n        }\r\n        else{\r\n            source._events = void 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport interface EventSource {\r\n    /** @internal */\r\n    _events : HandlersByEvent\r\n}\r\n\r\nconst eventSplitter = /\\s+/;\r\n\r\nexport function strings( api : ApiEntry, source : EventSource, events : string, callback : Callback, context ){\r\n    if( eventSplitter.test( events ) ){\r\n        const names = events.split( eventSplitter );\r\n        for( let name of names ) api( source, name, callback, context );\r\n    }\r\n    else api( source, events, callback, context );\r\n}\r\n\r\nexport type ApiEntry = ( source : EventSource, event : string, callback : Callback, context? : any ) => void\r\n\r\n/*********************************\r\n * Event-triggering API\r\n */\r\n\r\n export function trigger2( self : EventSource, name : string, a, b ) : void {\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend2( queue, a, b );\r\n        listSend3( all, name, a, b );\r\n    }\r\n};\r\n\r\nexport function trigger3( self : EventSource, name : string, a, b, c ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend3( queue, a, b, c );\r\n        listSend4( all, name, a, b, c );\r\n    }\r\n};\r\n\r\nexport function trigger5( self : EventSource, name : string, a, b, c, d, e ) : void{\r\n    const { _events } = self;\r\n    if( _events ){\r\n        const queue = _events[ name ],\r\n            { all } = _events;\r\n\r\n        listSend5( queue, a, b, c, d, e );\r\n        listSend6( all, name, a, b, c, d, e );\r\n    }\r\n};","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/*****************************************************************\r\n * Mixins engine and @define metaprogramming class extensions\r\n *\r\n * Vlad Balin & Volicon, (c) 2016-2017\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { assign, defaults, getBaseClass, hashMap, transform } from './tools';\r\n\r\nexport interface Subclass< T > extends MixableConstructor {\r\n    new ( ...args ) : T\r\n    prototype : T\r\n}\r\n\r\nexport interface MixableConstructor extends Function{\r\n    __super__? : object;\r\n    mixins? : MixinsState;\r\n    onExtend? : ( BaseClass : Function ) => void;\r\n    onDefine? : ( definition : object, BaseClass : Function ) => void;\r\n    define? : ( definition? : object, statics? : object ) => MixableConstructor;\r\n    extend? : <T extends object>( definition? : T, statics? : object ) => Subclass<T>;\r\n}\r\n\r\nexport interface MixableDefinition {\r\n    mixins? : Mixin[]\r\n}\r\n\r\n/**\r\n * Base class, holding metaprogramming class extensions.\r\n * Supports mixins and Class.define metaprogramming method.\r\n */\r\nexport class Mixable {\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static onDefine : ( definition : object, BaseClass : Function ) => object;    \r\n    static __super__ : object\r\n    static mixins : MixinsState;\r\n\r\n    /** \r\n     *  Must be called after inheritance and before 'define'.\r\n     */\r\n    static define( protoProps : MixableDefinition = {}, staticProps? : object ) : MixableConstructor {\r\n        const BaseClass : MixableConstructor = getBaseClass( this );\r\n\r\n        // Assign statics.\r\n        staticProps && assign( this, staticProps );\r\n\r\n        // Extract and apply mixins from the definition.\r\n        const { mixins, ...defineMixin } = protoProps;\r\n        mixins && this.mixins.merge( mixins );\r\n\r\n        // Unshift definition to the the prototype.\r\n        this.mixins.mergeObject( this.prototype, defineMixin, true );\r\n\r\n        // Unshift definition from statics to the prototype.\r\n        this.mixins.mergeObject( this.prototype, this.mixins.getStaticDefinitions( BaseClass ), true );\r\n\r\n        // Call onDefine hook, if it's present.\r\n        this.onDefine && this.onDefine( this.mixins.definitions, BaseClass );\r\n        \r\n        // Apply merge rules to inherited members. No mixins can be added after this point.\r\n        this.mixins.mergeInheritedMembers( BaseClass );\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Backbone-compatible extend method to be used in ES5 and for backward compatibility */\r\n    static extend< T extends object>(spec? : T, statics? : {} ) : Subclass< T > {\r\n        let TheSubclass : Subclass< T >;\r\n\r\n        // 1. Create the subclass (ES5 compatibility shim).\r\n        // If constructor function is given...\r\n        if( spec && spec.hasOwnProperty( 'constructor' ) ){\r\n            // ...we need to manually call internal TypeScript __extend function. Hack! Hack!\r\n            TheSubclass = spec.constructor as any;\r\n            __extends( TheSubclass, this );\r\n        }\r\n        // Otherwise, create the subclall in usual way.\r\n        else{\r\n            TheSubclass = class Subclass extends this {} as any;\r\n        }\r\n\r\n        predefine( TheSubclass );\r\n        spec && TheSubclass.define( spec, statics );\r\n\r\n        return TheSubclass;\r\n    }\r\n}\r\n\r\n/** @decorator `@predefine` for forward definitions. Can be used with [[Mixable]] classes only.\r\n * Forwards the call to the [[Mixable.predefine]];\r\n */\r\nexport function predefine( Constructor : MixableConstructor ) : void {\r\n    const BaseClass : MixableConstructor = getBaseClass( Constructor );\r\n\r\n    // Legacy systems support\r\n    Constructor.__super__ = BaseClass.prototype;\r\n    \r\n    // Initialize mixins structures...\r\n    Constructor.define || MixinsState.get( Mixable ).populate( Constructor );\r\n\r\n    // Make sure Ctor.mixins are ready before the callback...\r\n    MixinsState.get( Constructor );\r\n\r\n    // Call extend hook.\r\n    Constructor.onExtend && Constructor.onExtend( BaseClass );\r\n}\r\n\r\n/** @decorator `@define` for metaprogramming magic. Can be used with [[Mixable]] classes only.\r\n *  Forwards the call to [[Mixable.define]].\r\n */\r\nexport function define( ClassOrDefinition : Function ) : void;\r\nexport function define( ClassOrDefinition : object ) : ClassDecorator;\r\nexport function define( ClassOrDefinition : object | MixableConstructor ){\r\n    // @define class\r\n    if( typeof ClassOrDefinition === 'function' ){\r\n        predefine( ClassOrDefinition );\r\n        ( ClassOrDefinition as MixableConstructor ).define();\r\n    }\r\n    // @define({ prop : val, ... }) class\r\n    else{\r\n        return function( Ctor : MixableConstructor ){\r\n            predefine( Ctor );\r\n            Ctor.define( ClassOrDefinition );\r\n        } as any;\r\n    }\r\n}\r\n\r\nexport function definitions( rules : MixinMergeRules ) : ClassDecorator {\r\n    return ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.definitionRules = defaults( hashMap(), rules, mixins.definitionRules );\r\n    }\r\n}\r\n\r\n// Create simple property list decorator\r\nexport function propertyListDecorator( listName: string ) : PropertyDecorator {\r\n    return function propList(proto, name : string) {\r\n        const list = proto.hasOwnProperty( listName ) ?\r\n            proto[ listName ] : (proto[ listName ] = (proto[ listName ] || []).slice());  \r\n\r\n        list.push(name);\r\n    }\r\n}\r\n\r\nexport function definitionDecorator( definitionKey, value ){\r\n    return ( proto : object, name : string ) => {\r\n        MixinsState\r\n            .get( proto.constructor )\r\n            .mergeObject( proto, {\r\n                [ definitionKey ] : {\r\n                    [ name ] : value\r\n                }\r\n            });\r\n    }\r\n}\r\n\r\nexport class MixinsState {\r\n    mergeRules : MixinMergeRules;\r\n    definitionRules : MixinMergeRules;\r\n    definitions : object = {};\r\n    appliedMixins : Mixin[];\r\n\r\n    // Return mixins state for the class. Initialize if it's not exist.\r\n    static get( Class ) : MixinsState {\r\n        const { mixins } = Class;\r\n    \r\n        return mixins && Class === mixins.Class ? mixins :\r\n             Class.mixins = new MixinsState( Class );\r\n    }\r\n\r\n    constructor( public Class : MixableConstructor ){\r\n        const { mixins } = getBaseClass( Class );\r\n\r\n        this.mergeRules = ( mixins && mixins.mergeRules ) || hashMap();\r\n        this.definitionRules = ( mixins && mixins.definitionRules ) || hashMap();\r\n        this.appliedMixins = ( mixins && mixins.appliedMixins ) || [];\r\n    }\r\n\r\n    getStaticDefinitions( BaseClass : Function ){\r\n        const definitions = hashMap(),\r\n            { Class } = this;\r\n\r\n        return transform( definitions, this.definitionRules, ( rule, name ) =>{\r\n            if( BaseClass[ name ] !== Class[ name ]){\r\n                return Class[ name ];\r\n            }\r\n        });\r\n    }\r\n\r\n    merge( mixins : Mixin[] ){\r\n        const proto      = this.Class.prototype,\r\n            { mergeRules } = this;\r\n\r\n        // Copy applied mixins array as it's going to be updated.\r\n        const appliedMixins = this.appliedMixins = this.appliedMixins.slice();\r\n\r\n        // Apply mixins in sequence...\r\n        for( let mixin of mixins ) {\r\n            // Mixins array should be flattened.\r\n            if( Array.isArray( mixin ) ) {\r\n                this.merge( mixin );\r\n            }\r\n            // Don't apply mixins twice.\r\n            else if( appliedMixins.indexOf( mixin ) < 0 ){\r\n                appliedMixins.push( mixin );\r\n\r\n                // For constructors, merge _both_ static and prototype members.\r\n                if( typeof mixin === 'function' ){\r\n                    // Merge static members\r\n                    this.mergeObject( this.Class, mixin );\r\n\r\n                    // merge definitionRules and mergeRules\r\n                    const sourceMixins = ( mixin as any ).mixins;\r\n                    if( sourceMixins ){\r\n                        this.mergeRules = defaults( hashMap(), this.mergeRules, sourceMixins.mergeRules );\r\n                        this.definitionRules = defaults( hashMap(), this.definitionRules, sourceMixins.definitionRules );\r\n                        this.appliedMixins = this.appliedMixins.concat( sourceMixins.appliedMixins );\r\n                    }\r\n\r\n                    // Prototypes are merged according with rules.\r\n                    this.mergeObject( proto, mixin.prototype );\r\n                }\r\n                // Handle plain object mixins.\r\n                else {\r\n                    this.mergeObject( proto, mixin );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    populate( ...ctors : Function[] ){\r\n        for( let Ctor of ctors ) {\r\n            MixinsState.get( Ctor ).merge([ this.Class ]);\r\n        }\r\n    }\r\n\r\n    mergeObject( dest : object, source : object, unshift? : boolean ) {\r\n        forEachOwnProp( source, name => {\r\n            const sourceProp = Object.getOwnPropertyDescriptor( source, name );\r\n            let rule : MixinMergeRule;\r\n\r\n            if( rule = this.definitionRules[ name ] ){\r\n                assignProperty( this.definitions, name, sourceProp, rule, unshift );\r\n            }\r\n\r\n            if( !rule || rule === mixinRules.protoValue  ){\r\n                assignProperty( dest, name, sourceProp, this.mergeRules[ name ], unshift );\r\n            }\r\n        });\r\n    }\r\n\r\n    mergeInheritedMembers( BaseClass : Function ){\r\n        const { mergeRules, Class } = this;\r\n\r\n        if( mergeRules ){\r\n            const proto = Class.prototype,\r\n                baseProto = BaseClass.prototype;\r\n\r\n            for( let name in mergeRules ) {\r\n                const rule = mergeRules[ name ];\r\n\r\n                if( proto.hasOwnProperty( name ) && name in baseProto ){\r\n                    proto[ name ] = resolveRule( proto[ name ], baseProto[ name ], rule );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst dontMix = {\r\n    function : hashMap({\r\n        length : true,\r\n        prototype : true,\r\n        caller : true,\r\n        arguments : true,\r\n        name : true,\r\n        __super__ : true\r\n    }),\r\n    \r\n    object : hashMap({\r\n        constructor : true\r\n    })    \r\n}\r\n\r\nfunction forEachOwnProp( object : object, fun : ( name : string ) => void ){\r\n    const ignore = dontMix[ typeof object ];\r\n\r\n    for( let name of Object.getOwnPropertyNames( object ) ) {\r\n        ignore[ name ] || fun( name );\r\n    }\r\n}\r\n\r\nexport interface MixinMergeRules {\r\n    [ name : string ] : MixinMergeRule\r\n}\r\n\r\nexport type MixinMergeRule = ( a : any, b : any ) => any\r\nexport type Mixin = { [ key : string ] : any } | Function\r\n\r\n// @mixins( A, B, ... ) decorator.\r\nexport interface MixinRulesDecorator {\r\n    ( rules : MixinMergeRules ) : ClassDecorator\r\n    value( a : object, b : object) : object;\r\n    protoValue( a : object, b : object) : object;\r\n    merge( a : object, b : object ) : object;\r\n    pipe( a: Function, b : Function ) : Function;\r\n    defaults( a: Function, b : Function ) : Function;\r\n    classFirst( a: Function, b : Function ) : Function;\r\n    classLast( a: Function, b : Function ) : Function;\r\n    every( a: Function, b : Function ) : Function;\r\n    some( a: Function, b : Function ) : Function;\r\n}\r\n\r\nexport const mixins = ( ...list : Mixin[] ) => (\r\n    ( Class : Function ) => MixinsState.get( Class ).merge( list )\r\n);\r\n\r\n// @mixinRules({ name : rule, ... }) decorator.\r\nexport const mixinRules = ( ( rules : MixinMergeRules ) => (\r\n    ( Class : Function ) => {\r\n        const mixins = MixinsState.get( Class );\r\n        mixins.mergeRules = defaults( rules, mixins.mergeRules );\r\n    }\r\n) ) as MixinRulesDecorator;\r\n\r\n// Pre-defined mixin merge rules\r\n\r\nmixinRules.value = ( a, b ) => a;\r\n\r\nmixinRules.protoValue = ( a, b ) => a;\r\n\r\n// Recursively merge members\r\nmixinRules.merge = ( a, b ) => defaults( {}, a, b );\r\n\r\n    // Execute methods in pipe, with the class method executed last.\r\nmixinRules.pipe = ( a, b ) => (\r\n    function( x : any ) : any {\r\n        return a.call( this, b.call( this, x ) );\r\n    }\r\n);\r\n\r\n    // Assume methods return an object, and merge results with defaults (class method executed first)\r\nmixinRules.defaults = ( a : Function, b : Function ) => (\r\n    function() : object {\r\n        return defaults( a.apply( this, arguments ), b.apply( this, arguments ) );\r\n    }\r\n);\r\n\r\n// Execute methods in sequence staring with the class method.\r\nmixinRules.classFirst = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        a.apply( this, arguments );\r\n        b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n    // Execute methods in sequence ending with the class method.\r\nmixinRules.classLast = ( a : Function, b : Function ) => (\r\n    function() : void {\r\n        b.apply( this, arguments );\r\n        a.apply( this, arguments );\r\n    }\r\n)\r\n\r\n    // Execute methods in sequence returning the first falsy result.\r\nmixinRules.every = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) && b.apply( this, arguments );\r\n    }\r\n);\r\n    // Execute methods in sequence returning the first truthy result.\r\nmixinRules.some = ( a : Function, b : Function ) =>(\r\n    function() : any {\r\n        return a.apply( this, arguments ) || b.apply( this, arguments );\r\n    }\r\n);\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nfunction assignProperty( dest : object, name : string, sourceProp : PropertyDescriptor, rule : MixinMergeRule, unshift? : boolean ){\r\n// Destination prop is defined, thus the merge rules must be applied.\r\n    if( dest.hasOwnProperty( name ) ){\r\n        const destProp = Object.getOwnPropertyDescriptor( dest, name );\r\n\r\n        if( destProp.configurable && 'value' in destProp ){\r\n            dest[ name ] = unshift ?\r\n                resolveRule( sourceProp.value, destProp.value, rule ) :\r\n                resolveRule( destProp.value, sourceProp.value, rule ) ;\r\n        }\r\n    }\r\n    // If destination is empty, just copy the prop over.\r\n    else{\r\n        Object.defineProperty( dest, name, sourceProp );\r\n    }\r\n}\r\n\r\nfunction resolveRule( dest, source, rule : MixinMergeRule ){\r\n    // When destination is empty, take the source.\r\n    if( dest === void 0 ) return source;\r\n\r\n    // In these cases we take non-empty destination:\r\n    if( !rule || source === void 0 ) return dest;\r\n\r\n    // In other cases we must merge values.\r\n    return rule( dest, source );\r\n}","import * as _eventsApi from './eventsource';\r\nimport { EventMap, EventsDefinition, EventSource, HandlersByEvent } from './eventsource';\r\nimport { define, definitions, Mixable, MixableConstructor, mixinRules, MixinsState } from './mixins';\r\nimport { omit, transform } from './tools';\r\n\r\nconst { strings, on, off, once, trigger5, trigger2, trigger3 } = _eventsApi;\r\n\r\nlet _idCount = 0;\r\n\r\nfunction uniqueId() : string {\r\n    return 'l' + _idCount++;\r\n}\r\n\r\nexport { EventMap, EventsDefinition };\r\n\r\nexport interface MessengerDefinition {\r\n    _localEvents? : EventMap\r\n    localEvents? : EventsDefinition\r\n    properties? : PropertyMap\r\n    [ name : string ] : any\r\n}\r\n\r\nexport interface PropertyMap {\r\n    [ name : string ] : Property\r\n}\r\n\r\nexport type Property = PropertyDescriptor | ( () => any )\r\n\r\nexport interface MessengersByCid {\r\n    [ cid : string ] : Messenger\r\n}\r\n\r\nexport type EventCallbacks<Context> = { [ events : string ] : EventCallback<Context> }\r\nexport type EventCallback<Context> = ( this : Context, ...args : any[] ) => void\r\n\r\n/*************************\r\n * Messenger is mixable class with capabilities of sending and receiving synchronous events.\r\n * This class itself can serve as both mixin and base class.\r\n */\r\n\r\n@define\r\n@definitions({\r\n    properties : mixinRules.merge,\r\n    localEvents : mixinRules.merge\r\n})\r\nexport class Messenger implements Mixable, EventSource {\r\n    // Define extendable mixin static properties.\r\n    /** @internal */\r\n    static __super__ : object;\r\n    static mixins : MixinsState;\r\n    static onExtend : ( BaseClass : Function ) => void;\r\n    static define : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static extend : ( definition? : MessengerDefinition, statics? : object ) => MixableConstructor;\r\n    static onDefine({ localEvents, _localEvents, properties } : MessengerDefinition, BaseClass? : typeof Mixable ){\r\n        // Handle localEvents definition\r\n        if( localEvents || _localEvents ){\r\n            const eventsMap = new EventMap( this.prototype._localEvents );\r\n\r\n            localEvents && eventsMap.addEventsMap( localEvents );\r\n            _localEvents && eventsMap.merge( _localEvents );\r\n            \r\n            this.prototype._localEvents = eventsMap;\r\n        }\r\n\r\n        // Handle properties definitions...\r\n        if( properties ){\r\n            Object.defineProperties( this.prototype, transform( {}, <PropertyMap>properties, toPropertyDescriptor ) );\r\n        }\r\n    }\r\n\r\n    /** @internal */ \r\n    _events : HandlersByEvent = void 0;\r\n\r\n    /** @internal */ \r\n    _listeningTo : MessengersByCid = void 0\r\n\r\n    /** Unique client-only id. */\r\n    cid : string\r\n\r\n    /** Prototype-only property to manage automatic local events subscription */ \r\n    protected _localEvents : EventMap\r\n\r\n    constructor(){\r\n        this.cid = uniqueId();\r\n        this.initialize.apply( this, arguments );\r\n\r\n        // TODO: local events subscribe?\r\n    }\r\n\r\n    /** Method is called at the end of the constructor */\r\n    initialize() : void {}\r\n    \r\n    on( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( on, this, events, callback, context );\r\n        else for( let name in events ) strings( on, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    once( events : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( typeof events === 'string' ) strings( once, this, events, callback, context );\r\n        else for( let name in events ) strings( once, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    off( events? : string | EventCallbacks<this>, callback?, context? ) : this {\r\n        if( !events ) off( this, void 0, callback, context );\r\n        else if( typeof events === 'string' ) strings( off, this, events, callback, context );\r\n        else for( let name in events ) strings( off, this, name, events[ name ], context || callback );\r\n\r\n        return this;\r\n    }\r\n\r\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\r\n    // passed the same arguments as `trigger` is, apart from the event name\r\n    // (unless you're listening on `\"all\"`, which will cause your callback to\r\n    // receive the true name of the event as the first argument).\r\n    trigger(name : string, a?, b?, c?, d?, e? ) : this {\r\n        if( d !== void 0 || e !== void 0 ) trigger5( this, name, a, b, c, d, e );\r\n        else if( c !== void 0 ) trigger3( this, name, a, b, c );\r\n        else trigger2( this, name, a, b );\r\n        return this;\r\n    }\r\n\r\n    listenTo( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.on( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    listenToOnce( source : Messenger, a : string | EventCallbacks<this>, b? : Function ) : this {\r\n        if( source ){\r\n            addReference( this, source );\r\n            source.once( a, !b && typeof a === 'object' ? this : b, this );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    stopListening( a_source? : Messenger, a? : string | EventCallbacks<this>, b? : Function ) : this {\r\n        const { _listeningTo } = this;\r\n        if( _listeningTo ){\r\n            const removeAll = !( a || b ),\r\n                  second = !b && typeof a === 'object' ? this : b;\r\n\r\n            if( a_source ){\r\n                const source = _listeningTo[ a_source.cid ];\r\n                if( source ){\r\n                    if( removeAll ) delete _listeningTo[ a_source.cid ];\r\n                    source.off( a, second, this );\r\n                }\r\n            }\r\n            else if( a_source == null ){\r\n                for( let cid in _listeningTo ) _listeningTo[ cid ].off( a, second, this );\r\n\r\n                if( removeAll ) ( this._listeningTo = void 0 );\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destructor. Stops messenger from listening to all objects,\r\n     * and stop others from listening to the messenger. \r\n     */\r\n    _disposed : boolean\r\n\r\n    dispose() : void {\r\n        if( this._disposed ) return;\r\n\r\n        this.stopListening();\r\n        this.off();\r\n\r\n        this._disposed = true;\r\n    }\r\n}\r\n\r\n/**\r\n * Backbone 1.2 API conformant Events mixin.\r\n */\r\nexport const Events : Messenger = <Messenger> omit( Messenger.prototype, 'constructor', 'initialize' );\r\n\r\n/**\r\n * Messenger Private Helpers \r\n */\r\n\r\nfunction toPropertyDescriptor( x : Property ) : PropertyDescriptor {\r\n    if( x ){\r\n        return typeof x === 'function' ? { get : < () => any >x, configurable : true } : <PropertyDescriptor> x;\r\n    }\r\n}\r\n\r\nfunction addReference( listener : Messenger, source : Messenger ){\r\n      const listeningTo = listener._listeningTo || (listener._listeningTo = Object.create( null ) ),\r\n            cid = source.cid || ( source.cid = uniqueId() );\r\n\r\n      listeningTo[ cid ] = source;\r\n}","import { Messenger } from './events'\r\nimport { define } from './mixins';\r\n\r\nexport type LogLevel = 'error' | 'warn' | 'debug' | 'info' | 'log';\r\nexport type LoggerEventHandler = ( topic : string, msg : string, props : object )  => void;\r\n\r\nexport const isProduction = typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production',\r\n    logEvents : LogLevel[] =  isProduction ?\r\n        [ 'error', 'info' ] :\r\n        [ 'error', 'warn', 'debug', 'info', 'log' ];\r\n\r\n@define\r\nexport class Logger extends Messenger {\r\n    counter : { [ level in LogLevel ]? : number } = {}\r\n\r\n    // Log events of the given log level to the console, optionally filtered by topic\r\n    logToConsole( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                const args = [ `[${topic}] ${msg}` ];\r\n        \r\n                for( let name in props ){\r\n                    args.push( `\\n\\t${name}:`, toString( props[ name ] ) );\r\n                }\r\n        \r\n                console[ level ].apply( console, args );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Fire exception on the events of the given log level, optionally filtered by topic\r\n    throwOn( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                throw new Error( `[${topic}] ${msg}` );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Count log events of the given level, optionally filtered by topic\r\n    count( level : LogLevel, filter? : RegExp ) : this {\r\n        return this.on( level, ( topic, msg, props ) => {\r\n            if( !filter || filter.test( topic ) ){\r\n                this.counter[ level ] = ( this.counter[ level ] || 0 ) + 1;\r\n            }\r\n        });\r\n    }\r\n\r\n    trigger : ( level : LogLevel, topic : string, message : string, props? : object ) => this;\r\n    \r\n    off : ( event? : LogLevel ) => this;\r\n\r\n\r\n    on( handlers : { [ name in LogLevel ] : LoggerEventHandler } ) : this;\r\n    on( handlers : LogLevel, handler : LoggerEventHandler ) : this;\r\n    on( handlers : 'all', handler : ( level : LogLevel, topic : string, msg : string, props : object )  => void ) : this;\r\n    on( a : any, b? : any ){\r\n        return super.on( a, b );\r\n    }\r\n}\r\n\r\n/**\r\n * Convert objects to the plain text friendly format.\r\n * primitives as in JSON.\r\n */\r\nlet toString = typeof window === 'undefined' ? \r\n    something => {\r\n        if( something && typeof something === 'object' ){\r\n            // Support custom object wrappers...\r\n            const value = something.__inner_state__ || something,\r\n                isArray = Array.isArray( value );\r\n\r\n            const body = isArray ? `[ length = ${ value.length } ]` : `{ ${ Object.keys( value ).join( ', ' )} }`;\r\n\r\n            return something.constructor.name + ' ' + body;\r\n        }\r\n\r\n        return JSON.stringify( something );\r\n    }\r\n    : x => x;\r\n\r\nexport const logger = new Logger();\r\n\r\nif( typeof console !== 'undefined' ) {\r\n    for( let event of logEvents ){\r\n        logger.logToConsole( event );\r\n    }\r\n}\r\n\r\nexport const throwingLogger = new Logger();\r\nthrowingLogger.throwOn( 'error' ).throwOn( 'warn' );\r\n\r\nexport const log : typeof logger.trigger = logger.trigger.bind( logger );"],"names":["defaults","dest","source","name","hasOwnProperty","arguments","length","i","other","getBaseClass","Class","Object","getPrototypeOf","prototype","constructor","some","obj","fun","ArrayProto","arr","result","someArray","key","someObject","every","predicate","x","omit","discard","transform","value","assign","once","func","memo","first","apply","this","Array","DateProto","Date","ObjectProto","notEqual","a","b","protoA","arraysNotEqual","keysA","keys","objectsNotEqual","HashProto","create","hashMap","hash","isValidJSON","proto","definition","_i","names","names_1","_a","name_1","prop","desc","getOwnPropertyDescriptor","o","EventMap","map","handlers","concat","addEvent","split","eventSplitter","getBubblingHandler","callback","name_2","push","EventDescriptor","target","event_1","on","event_2","off","slice","addEventsMap","handler","_bubblingHandlers","event","c","d","e","trigger5","trigger3","trigger2","context","next","listOff","_events","filteredHead","prev","head","ev","_callback","listSend3","call","EventHandler","once_1","_once","name_3","strings","api","events","test","self","queue","all","listSend2","listSend4","listSend5","f","listSend6","extendStatics","setPrototypeOf","__proto__","p","__extends","__","__decorate","decorators","r","Reflect","decorate","defineProperty","Mixable","protoProps","staticProps","BaseClass","mixins","defineMixin","s","t","indexOf","getOwnPropertySymbols","propertyIsEnumerable","merge","mergeObject","getStaticDefinitions","onDefine","definitions","mergeInheritedMembers","spec","statics","TheSubclass","tslib_1.__extends","predefine","define","Constructor","__super__","MixinsState","get","populate","onExtend","ClassOrDefinition","Ctor","rules","definitionRules","rule","appliedMixins","mixins_1","mixin","isArray","sourceMixins","mergeRules","ctors","ctors_1","unshift","object","ignore","dontMix","getOwnPropertyNames","forEachOwnProp","sourceProp","_this","assignProperty","mixinRules","protoValue","baseProto","resolveRule","function","caller","destProp","configurable","pipe","classFirst","classLast","_idCount","uniqueId","Messenger","localEvents","_localEvents","properties","eventsMap","defineProperties","toPropertyDescriptor","addReference","a_source","_listeningTo","removeAll","second","cid","_disposed","stopListening","initialize","Events","listener","isProduction","process","env","NODE_ENV","logEvents","Logger","level","filter","topic","msg","props","args","toString","console","Error","counter","_super","window","something","__inner_state__","body","join","JSON","stringify","logger","logEvents_1","logToConsole","throwingLogger","throwOn","log","trigger","bind","definitionKey","list","listName"],"mappings":"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"}